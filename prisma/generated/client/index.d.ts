
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Utilisateur
 * 
 */
export type Utilisateur = $Result.DefaultSelection<Prisma.$UtilisateurPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Adresse
 * 
 */
export type Adresse = $Result.DefaultSelection<Prisma.$AdressePayload>
/**
 * Model ReseauSocial
 * 
 */
export type ReseauSocial = $Result.DefaultSelection<Prisma.$ReseauSocialPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Etudiant
 * 
 */
export type Etudiant = $Result.DefaultSelection<Prisma.$EtudiantPayload>
/**
 * Model Professeur
 * 
 */
export type Professeur = $Result.DefaultSelection<Prisma.$ProfesseurPayload>
/**
 * Model Inscription
 * 
 */
export type Inscription = $Result.DefaultSelection<Prisma.$InscriptionPayload>
/**
 * Model Domaine
 * 
 */
export type Domaine = $Result.DefaultSelection<Prisma.$DomainePayload>
/**
 * Model Mention
 * 
 */
export type Mention = $Result.DefaultSelection<Prisma.$MentionPayload>
/**
 * Model Specialite
 * 
 */
export type Specialite = $Result.DefaultSelection<Prisma.$SpecialitePayload>
/**
 * Model Diplome
 * 
 */
export type Diplome = $Result.DefaultSelection<Prisma.$DiplomePayload>
/**
 * Model Semestre
 * 
 */
export type Semestre = $Result.DefaultSelection<Prisma.$SemestrePayload>
/**
 * Model UniteEnseignement
 * 
 */
export type UniteEnseignement = $Result.DefaultSelection<Prisma.$UniteEnseignementPayload>
/**
 * Model Matiere
 * 
 */
export type Matiere = $Result.DefaultSelection<Prisma.$MatierePayload>
/**
 * Model Etablissement
 * 
 */
export type Etablissement = $Result.DefaultSelection<Prisma.$EtablissementPayload>
/**
 * Model Classe
 * 
 */
export type Classe = $Result.DefaultSelection<Prisma.$ClassePayload>
/**
 * Model AnneeScolaire
 * 
 */
export type AnneeScolaire = $Result.DefaultSelection<Prisma.$AnneeScolairePayload>
/**
 * Model EvaluationEtudiants
 * 
 */
export type EvaluationEtudiants = $Result.DefaultSelection<Prisma.$EvaluationEtudiantsPayload>
/**
 * Model NoteEtudiant
 * 
 */
export type NoteEtudiant = $Result.DefaultSelection<Prisma.$NoteEtudiantPayload>
/**
 * Model Cours
 * 
 */
export type Cours = $Result.DefaultSelection<Prisma.$CoursPayload>
/**
 * Model Salle
 * 
 */
export type Salle = $Result.DefaultSelection<Prisma.$SallePayload>
/**
 * Model FeuillePresence
 * 
 */
export type FeuillePresence = $Result.DefaultSelection<Prisma.$FeuillePresencePayload>
/**
 * Model EmploiDuTemps
 * 
 */
export type EmploiDuTemps = $Result.DefaultSelection<Prisma.$EmploiDuTempsPayload>
/**
 * Model Paiement
 * 
 */
export type Paiement = $Result.DefaultSelection<Prisma.$PaiementPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  UTILISATEUR: 'UTILISATEUR',
  ETUDIANT: 'ETUDIANT',
  PROFESSEUR: 'PROFESSEUR',
  COMPTABLE: 'COMPTABLE',
  SURVEILLANT: 'SURVEILLANT',
  SUPERVISEUR: 'SUPERVISEUR'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Genre: {
  Masculin: 'Masculin',
  Feminin: 'Feminin'
};

export type Genre = (typeof Genre)[keyof typeof Genre]


export const GroupeSanguin: {
  A: 'A',
  B: 'B',
  AB: 'AB',
  O: 'O',
  O_NEGATIF: 'O_NEGATIF',
  A_NEGATIF: 'A_NEGATIF',
  B_NEGATIF: 'B_NEGATIF',
  AB_NEGATIF: 'AB_NEGATIF'
};

export type GroupeSanguin = (typeof GroupeSanguin)[keyof typeof GroupeSanguin]


export const TypeDiplome: {
  LICENCE_GENERALE: 'LICENCE_GENERALE',
  LICENCE_PROFESSIONNELLE: 'LICENCE_PROFESSIONNELLE',
  MASTER_PROFESSIONNEL: 'MASTER_PROFESSIONNEL',
  MASTER_RECHERCHE: 'MASTER_RECHERCHE',
  DOCTORAT: 'DOCTORAT'
};

export type TypeDiplome = (typeof TypeDiplome)[keyof typeof TypeDiplome]


export const TypeEvaluation: {
  CONTROLE_CONTINU: 'CONTROLE_CONTINU',
  EXAMEN: 'EXAMEN',
  TEST: 'TEST',
  TP: 'TP',
  TD: 'TD',
  PROJET: 'PROJET',
  RAPPORT: 'RAPPORT',
  MEMOIRE: 'MEMOIRE',
  STAGE: 'STAGE',
  AUTRE: 'AUTRE'
};

export type TypeEvaluation = (typeof TypeEvaluation)[keyof typeof TypeEvaluation]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Genre = $Enums.Genre

export const Genre: typeof $Enums.Genre

export type GroupeSanguin = $Enums.GroupeSanguin

export const GroupeSanguin: typeof $Enums.GroupeSanguin

export type TypeDiplome = $Enums.TypeDiplome

export const TypeDiplome: typeof $Enums.TypeDiplome

export type TypeEvaluation = $Enums.TypeEvaluation

export const TypeEvaluation: typeof $Enums.TypeEvaluation

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.utilisateur`: Exposes CRUD operations for the **Utilisateur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utilisateurs
    * const utilisateurs = await prisma.utilisateur.findMany()
    * ```
    */
  get utilisateur(): Prisma.UtilisateurDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.adresse`: Exposes CRUD operations for the **Adresse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adresses
    * const adresses = await prisma.adresse.findMany()
    * ```
    */
  get adresse(): Prisma.AdresseDelegate<ExtArgs>;

  /**
   * `prisma.reseauSocial`: Exposes CRUD operations for the **ReseauSocial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReseauSocials
    * const reseauSocials = await prisma.reseauSocial.findMany()
    * ```
    */
  get reseauSocial(): Prisma.ReseauSocialDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.etudiant`: Exposes CRUD operations for the **Etudiant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etudiants
    * const etudiants = await prisma.etudiant.findMany()
    * ```
    */
  get etudiant(): Prisma.EtudiantDelegate<ExtArgs>;

  /**
   * `prisma.professeur`: Exposes CRUD operations for the **Professeur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Professeurs
    * const professeurs = await prisma.professeur.findMany()
    * ```
    */
  get professeur(): Prisma.ProfesseurDelegate<ExtArgs>;

  /**
   * `prisma.inscription`: Exposes CRUD operations for the **Inscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inscriptions
    * const inscriptions = await prisma.inscription.findMany()
    * ```
    */
  get inscription(): Prisma.InscriptionDelegate<ExtArgs>;

  /**
   * `prisma.domaine`: Exposes CRUD operations for the **Domaine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domaines
    * const domaines = await prisma.domaine.findMany()
    * ```
    */
  get domaine(): Prisma.DomaineDelegate<ExtArgs>;

  /**
   * `prisma.mention`: Exposes CRUD operations for the **Mention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentions
    * const mentions = await prisma.mention.findMany()
    * ```
    */
  get mention(): Prisma.MentionDelegate<ExtArgs>;

  /**
   * `prisma.specialite`: Exposes CRUD operations for the **Specialite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialites
    * const specialites = await prisma.specialite.findMany()
    * ```
    */
  get specialite(): Prisma.SpecialiteDelegate<ExtArgs>;

  /**
   * `prisma.diplome`: Exposes CRUD operations for the **Diplome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diplomes
    * const diplomes = await prisma.diplome.findMany()
    * ```
    */
  get diplome(): Prisma.DiplomeDelegate<ExtArgs>;

  /**
   * `prisma.semestre`: Exposes CRUD operations for the **Semestre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Semestres
    * const semestres = await prisma.semestre.findMany()
    * ```
    */
  get semestre(): Prisma.SemestreDelegate<ExtArgs>;

  /**
   * `prisma.uniteEnseignement`: Exposes CRUD operations for the **UniteEnseignement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UniteEnseignements
    * const uniteEnseignements = await prisma.uniteEnseignement.findMany()
    * ```
    */
  get uniteEnseignement(): Prisma.UniteEnseignementDelegate<ExtArgs>;

  /**
   * `prisma.matiere`: Exposes CRUD operations for the **Matiere** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matieres
    * const matieres = await prisma.matiere.findMany()
    * ```
    */
  get matiere(): Prisma.MatiereDelegate<ExtArgs>;

  /**
   * `prisma.etablissement`: Exposes CRUD operations for the **Etablissement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etablissements
    * const etablissements = await prisma.etablissement.findMany()
    * ```
    */
  get etablissement(): Prisma.EtablissementDelegate<ExtArgs>;

  /**
   * `prisma.classe`: Exposes CRUD operations for the **Classe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.classe.findMany()
    * ```
    */
  get classe(): Prisma.ClasseDelegate<ExtArgs>;

  /**
   * `prisma.anneeScolaire`: Exposes CRUD operations for the **AnneeScolaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnneeScolaires
    * const anneeScolaires = await prisma.anneeScolaire.findMany()
    * ```
    */
  get anneeScolaire(): Prisma.AnneeScolaireDelegate<ExtArgs>;

  /**
   * `prisma.evaluationEtudiants`: Exposes CRUD operations for the **EvaluationEtudiants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationEtudiants
    * const evaluationEtudiants = await prisma.evaluationEtudiants.findMany()
    * ```
    */
  get evaluationEtudiants(): Prisma.EvaluationEtudiantsDelegate<ExtArgs>;

  /**
   * `prisma.noteEtudiant`: Exposes CRUD operations for the **NoteEtudiant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteEtudiants
    * const noteEtudiants = await prisma.noteEtudiant.findMany()
    * ```
    */
  get noteEtudiant(): Prisma.NoteEtudiantDelegate<ExtArgs>;

  /**
   * `prisma.cours`: Exposes CRUD operations for the **Cours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cours
    * const cours = await prisma.cours.findMany()
    * ```
    */
  get cours(): Prisma.CoursDelegate<ExtArgs>;

  /**
   * `prisma.salle`: Exposes CRUD operations for the **Salle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salles
    * const salles = await prisma.salle.findMany()
    * ```
    */
  get salle(): Prisma.SalleDelegate<ExtArgs>;

  /**
   * `prisma.feuillePresence`: Exposes CRUD operations for the **FeuillePresence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeuillePresences
    * const feuillePresences = await prisma.feuillePresence.findMany()
    * ```
    */
  get feuillePresence(): Prisma.FeuillePresenceDelegate<ExtArgs>;

  /**
   * `prisma.emploiDuTemps`: Exposes CRUD operations for the **EmploiDuTemps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmploiDuTemps
    * const emploiDuTemps = await prisma.emploiDuTemps.findMany()
    * ```
    */
  get emploiDuTemps(): Prisma.EmploiDuTempsDelegate<ExtArgs>;

  /**
   * `prisma.paiement`: Exposes CRUD operations for the **Paiement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paiements
    * const paiements = await prisma.paiement.findMany()
    * ```
    */
  get paiement(): Prisma.PaiementDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Utilisateur: 'Utilisateur',
    Permission: 'Permission',
    Adresse: 'Adresse',
    ReseauSocial: 'ReseauSocial',
    Contact: 'Contact',
    Etudiant: 'Etudiant',
    Professeur: 'Professeur',
    Inscription: 'Inscription',
    Domaine: 'Domaine',
    Mention: 'Mention',
    Specialite: 'Specialite',
    Diplome: 'Diplome',
    Semestre: 'Semestre',
    UniteEnseignement: 'UniteEnseignement',
    Matiere: 'Matiere',
    Etablissement: 'Etablissement',
    Classe: 'Classe',
    AnneeScolaire: 'AnneeScolaire',
    EvaluationEtudiants: 'EvaluationEtudiants',
    NoteEtudiant: 'NoteEtudiant',
    Cours: 'Cours',
    Salle: 'Salle',
    FeuillePresence: 'FeuillePresence',
    EmploiDuTemps: 'EmploiDuTemps',
    Paiement: 'Paiement'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'account' | 'utilisateur' | 'permission' | 'adresse' | 'reseauSocial' | 'contact' | 'etudiant' | 'professeur' | 'inscription' | 'domaine' | 'mention' | 'specialite' | 'diplome' | 'semestre' | 'uniteEnseignement' | 'matiere' | 'etablissement' | 'classe' | 'anneeScolaire' | 'evaluationEtudiants' | 'noteEtudiant' | 'cours' | 'salle' | 'feuillePresence' | 'emploiDuTemps' | 'paiement'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Utilisateur: {
        payload: Prisma.$UtilisateurPayload<ExtArgs>
        fields: Prisma.UtilisateurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UtilisateurFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UtilisateurFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findFirst: {
            args: Prisma.UtilisateurFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UtilisateurFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findMany: {
            args: Prisma.UtilisateurFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          create: {
            args: Prisma.UtilisateurCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          createMany: {
            args: Prisma.UtilisateurCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UtilisateurDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          update: {
            args: Prisma.UtilisateurUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          deleteMany: {
            args: Prisma.UtilisateurDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UtilisateurUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UtilisateurUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          aggregate: {
            args: Prisma.UtilisateurAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUtilisateur>
          }
          groupBy: {
            args: Prisma.UtilisateurGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UtilisateurGroupByOutputType>[]
          }
          count: {
            args: Prisma.UtilisateurCountArgs<ExtArgs>,
            result: $Utils.Optional<UtilisateurCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>,
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Adresse: {
        payload: Prisma.$AdressePayload<ExtArgs>
        fields: Prisma.AdresseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdresseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdressePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdresseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          findFirst: {
            args: Prisma.AdresseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdressePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdresseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          findMany: {
            args: Prisma.AdresseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>[]
          }
          create: {
            args: Prisma.AdresseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          createMany: {
            args: Prisma.AdresseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdresseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          update: {
            args: Prisma.AdresseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          deleteMany: {
            args: Prisma.AdresseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdresseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdresseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          aggregate: {
            args: Prisma.AdresseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdresse>
          }
          groupBy: {
            args: Prisma.AdresseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdresseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdresseCountArgs<ExtArgs>,
            result: $Utils.Optional<AdresseCountAggregateOutputType> | number
          }
        }
      }
      ReseauSocial: {
        payload: Prisma.$ReseauSocialPayload<ExtArgs>
        fields: Prisma.ReseauSocialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReseauSocialFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReseauSocialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReseauSocialFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReseauSocialPayload>
          }
          findFirst: {
            args: Prisma.ReseauSocialFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReseauSocialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReseauSocialFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReseauSocialPayload>
          }
          findMany: {
            args: Prisma.ReseauSocialFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReseauSocialPayload>[]
          }
          create: {
            args: Prisma.ReseauSocialCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReseauSocialPayload>
          }
          createMany: {
            args: Prisma.ReseauSocialCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReseauSocialDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReseauSocialPayload>
          }
          update: {
            args: Prisma.ReseauSocialUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReseauSocialPayload>
          }
          deleteMany: {
            args: Prisma.ReseauSocialDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReseauSocialUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReseauSocialUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReseauSocialPayload>
          }
          aggregate: {
            args: Prisma.ReseauSocialAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReseauSocial>
          }
          groupBy: {
            args: Prisma.ReseauSocialGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReseauSocialGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReseauSocialCountArgs<ExtArgs>,
            result: $Utils.Optional<ReseauSocialCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Etudiant: {
        payload: Prisma.$EtudiantPayload<ExtArgs>
        fields: Prisma.EtudiantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtudiantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtudiantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          findFirst: {
            args: Prisma.EtudiantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtudiantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          findMany: {
            args: Prisma.EtudiantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>[]
          }
          create: {
            args: Prisma.EtudiantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          createMany: {
            args: Prisma.EtudiantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EtudiantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          update: {
            args: Prisma.EtudiantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          deleteMany: {
            args: Prisma.EtudiantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EtudiantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EtudiantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          aggregate: {
            args: Prisma.EtudiantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEtudiant>
          }
          groupBy: {
            args: Prisma.EtudiantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EtudiantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtudiantCountArgs<ExtArgs>,
            result: $Utils.Optional<EtudiantCountAggregateOutputType> | number
          }
        }
      }
      Professeur: {
        payload: Prisma.$ProfesseurPayload<ExtArgs>
        fields: Prisma.ProfesseurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfesseurFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfesseurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfesseurFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfesseurPayload>
          }
          findFirst: {
            args: Prisma.ProfesseurFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfesseurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfesseurFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfesseurPayload>
          }
          findMany: {
            args: Prisma.ProfesseurFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfesseurPayload>[]
          }
          create: {
            args: Prisma.ProfesseurCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfesseurPayload>
          }
          createMany: {
            args: Prisma.ProfesseurCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProfesseurDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfesseurPayload>
          }
          update: {
            args: Prisma.ProfesseurUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfesseurPayload>
          }
          deleteMany: {
            args: Prisma.ProfesseurDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProfesseurUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProfesseurUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfesseurPayload>
          }
          aggregate: {
            args: Prisma.ProfesseurAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfesseur>
          }
          groupBy: {
            args: Prisma.ProfesseurGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfesseurGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfesseurCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfesseurCountAggregateOutputType> | number
          }
        }
      }
      Inscription: {
        payload: Prisma.$InscriptionPayload<ExtArgs>
        fields: Prisma.InscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InscriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InscriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InscriptionPayload>
          }
          findFirst: {
            args: Prisma.InscriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InscriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InscriptionPayload>
          }
          findMany: {
            args: Prisma.InscriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InscriptionPayload>[]
          }
          create: {
            args: Prisma.InscriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InscriptionPayload>
          }
          createMany: {
            args: Prisma.InscriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InscriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InscriptionPayload>
          }
          update: {
            args: Prisma.InscriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InscriptionPayload>
          }
          deleteMany: {
            args: Prisma.InscriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InscriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InscriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InscriptionPayload>
          }
          aggregate: {
            args: Prisma.InscriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInscription>
          }
          groupBy: {
            args: Prisma.InscriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InscriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<InscriptionCountAggregateOutputType> | number
          }
        }
      }
      Domaine: {
        payload: Prisma.$DomainePayload<ExtArgs>
        fields: Prisma.DomaineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomaineFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomaineFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          findFirst: {
            args: Prisma.DomaineFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomaineFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          findMany: {
            args: Prisma.DomaineFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>[]
          }
          create: {
            args: Prisma.DomaineCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          createMany: {
            args: Prisma.DomaineCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DomaineDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          update: {
            args: Prisma.DomaineUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          deleteMany: {
            args: Prisma.DomaineDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DomaineUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DomaineUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          aggregate: {
            args: Prisma.DomaineAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDomaine>
          }
          groupBy: {
            args: Prisma.DomaineGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DomaineGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomaineCountArgs<ExtArgs>,
            result: $Utils.Optional<DomaineCountAggregateOutputType> | number
          }
        }
      }
      Mention: {
        payload: Prisma.$MentionPayload<ExtArgs>
        fields: Prisma.MentionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MentionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          findFirst: {
            args: Prisma.MentionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MentionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          findMany: {
            args: Prisma.MentionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>[]
          }
          create: {
            args: Prisma.MentionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          createMany: {
            args: Prisma.MentionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MentionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          update: {
            args: Prisma.MentionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          deleteMany: {
            args: Prisma.MentionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MentionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MentionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          aggregate: {
            args: Prisma.MentionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMention>
          }
          groupBy: {
            args: Prisma.MentionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MentionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentionCountArgs<ExtArgs>,
            result: $Utils.Optional<MentionCountAggregateOutputType> | number
          }
        }
      }
      Specialite: {
        payload: Prisma.$SpecialitePayload<ExtArgs>
        fields: Prisma.SpecialiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialiteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialiteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          findFirst: {
            args: Prisma.SpecialiteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialiteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          findMany: {
            args: Prisma.SpecialiteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>[]
          }
          create: {
            args: Prisma.SpecialiteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          createMany: {
            args: Prisma.SpecialiteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpecialiteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          update: {
            args: Prisma.SpecialiteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          deleteMany: {
            args: Prisma.SpecialiteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialiteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpecialiteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          aggregate: {
            args: Prisma.SpecialiteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpecialite>
          }
          groupBy: {
            args: Prisma.SpecialiteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpecialiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialiteCountArgs<ExtArgs>,
            result: $Utils.Optional<SpecialiteCountAggregateOutputType> | number
          }
        }
      }
      Diplome: {
        payload: Prisma.$DiplomePayload<ExtArgs>
        fields: Prisma.DiplomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiplomeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiplomeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          findFirst: {
            args: Prisma.DiplomeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiplomeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          findMany: {
            args: Prisma.DiplomeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>[]
          }
          create: {
            args: Prisma.DiplomeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          createMany: {
            args: Prisma.DiplomeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DiplomeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          update: {
            args: Prisma.DiplomeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          deleteMany: {
            args: Prisma.DiplomeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DiplomeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DiplomeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          aggregate: {
            args: Prisma.DiplomeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDiplome>
          }
          groupBy: {
            args: Prisma.DiplomeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiplomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiplomeCountArgs<ExtArgs>,
            result: $Utils.Optional<DiplomeCountAggregateOutputType> | number
          }
        }
      }
      Semestre: {
        payload: Prisma.$SemestrePayload<ExtArgs>
        fields: Prisma.SemestreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SemestreFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemestrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemestreFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemestrePayload>
          }
          findFirst: {
            args: Prisma.SemestreFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemestrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemestreFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemestrePayload>
          }
          findMany: {
            args: Prisma.SemestreFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemestrePayload>[]
          }
          create: {
            args: Prisma.SemestreCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemestrePayload>
          }
          createMany: {
            args: Prisma.SemestreCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SemestreDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemestrePayload>
          }
          update: {
            args: Prisma.SemestreUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemestrePayload>
          }
          deleteMany: {
            args: Prisma.SemestreDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SemestreUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SemestreUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemestrePayload>
          }
          aggregate: {
            args: Prisma.SemestreAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSemestre>
          }
          groupBy: {
            args: Prisma.SemestreGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SemestreGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemestreCountArgs<ExtArgs>,
            result: $Utils.Optional<SemestreCountAggregateOutputType> | number
          }
        }
      }
      UniteEnseignement: {
        payload: Prisma.$UniteEnseignementPayload<ExtArgs>
        fields: Prisma.UniteEnseignementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UniteEnseignementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniteEnseignementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UniteEnseignementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniteEnseignementPayload>
          }
          findFirst: {
            args: Prisma.UniteEnseignementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniteEnseignementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UniteEnseignementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniteEnseignementPayload>
          }
          findMany: {
            args: Prisma.UniteEnseignementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniteEnseignementPayload>[]
          }
          create: {
            args: Prisma.UniteEnseignementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniteEnseignementPayload>
          }
          createMany: {
            args: Prisma.UniteEnseignementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UniteEnseignementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniteEnseignementPayload>
          }
          update: {
            args: Prisma.UniteEnseignementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniteEnseignementPayload>
          }
          deleteMany: {
            args: Prisma.UniteEnseignementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UniteEnseignementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UniteEnseignementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniteEnseignementPayload>
          }
          aggregate: {
            args: Prisma.UniteEnseignementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUniteEnseignement>
          }
          groupBy: {
            args: Prisma.UniteEnseignementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UniteEnseignementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UniteEnseignementCountArgs<ExtArgs>,
            result: $Utils.Optional<UniteEnseignementCountAggregateOutputType> | number
          }
        }
      }
      Matiere: {
        payload: Prisma.$MatierePayload<ExtArgs>
        fields: Prisma.MatiereFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatiereFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatierePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatiereFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          findFirst: {
            args: Prisma.MatiereFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatierePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatiereFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          findMany: {
            args: Prisma.MatiereFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>[]
          }
          create: {
            args: Prisma.MatiereCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          createMany: {
            args: Prisma.MatiereCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MatiereDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          update: {
            args: Prisma.MatiereUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          deleteMany: {
            args: Prisma.MatiereDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MatiereUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MatiereUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          aggregate: {
            args: Prisma.MatiereAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMatiere>
          }
          groupBy: {
            args: Prisma.MatiereGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MatiereGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatiereCountArgs<ExtArgs>,
            result: $Utils.Optional<MatiereCountAggregateOutputType> | number
          }
        }
      }
      Etablissement: {
        payload: Prisma.$EtablissementPayload<ExtArgs>
        fields: Prisma.EtablissementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtablissementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtablissementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtablissementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtablissementPayload>
          }
          findFirst: {
            args: Prisma.EtablissementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtablissementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtablissementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtablissementPayload>
          }
          findMany: {
            args: Prisma.EtablissementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtablissementPayload>[]
          }
          create: {
            args: Prisma.EtablissementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtablissementPayload>
          }
          createMany: {
            args: Prisma.EtablissementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EtablissementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtablissementPayload>
          }
          update: {
            args: Prisma.EtablissementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtablissementPayload>
          }
          deleteMany: {
            args: Prisma.EtablissementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EtablissementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EtablissementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtablissementPayload>
          }
          aggregate: {
            args: Prisma.EtablissementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEtablissement>
          }
          groupBy: {
            args: Prisma.EtablissementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EtablissementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtablissementCountArgs<ExtArgs>,
            result: $Utils.Optional<EtablissementCountAggregateOutputType> | number
          }
        }
      }
      Classe: {
        payload: Prisma.$ClassePayload<ExtArgs>
        fields: Prisma.ClasseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClasseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClasseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          findFirst: {
            args: Prisma.ClasseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClasseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          findMany: {
            args: Prisma.ClasseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>[]
          }
          create: {
            args: Prisma.ClasseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          createMany: {
            args: Prisma.ClasseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClasseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          update: {
            args: Prisma.ClasseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          deleteMany: {
            args: Prisma.ClasseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClasseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClasseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          aggregate: {
            args: Prisma.ClasseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClasse>
          }
          groupBy: {
            args: Prisma.ClasseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClasseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClasseCountArgs<ExtArgs>,
            result: $Utils.Optional<ClasseCountAggregateOutputType> | number
          }
        }
      }
      AnneeScolaire: {
        payload: Prisma.$AnneeScolairePayload<ExtArgs>
        fields: Prisma.AnneeScolaireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnneeScolaireFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnneeScolairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnneeScolaireFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnneeScolairePayload>
          }
          findFirst: {
            args: Prisma.AnneeScolaireFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnneeScolairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnneeScolaireFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnneeScolairePayload>
          }
          findMany: {
            args: Prisma.AnneeScolaireFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnneeScolairePayload>[]
          }
          create: {
            args: Prisma.AnneeScolaireCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnneeScolairePayload>
          }
          createMany: {
            args: Prisma.AnneeScolaireCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AnneeScolaireDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnneeScolairePayload>
          }
          update: {
            args: Prisma.AnneeScolaireUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnneeScolairePayload>
          }
          deleteMany: {
            args: Prisma.AnneeScolaireDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnneeScolaireUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnneeScolaireUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnneeScolairePayload>
          }
          aggregate: {
            args: Prisma.AnneeScolaireAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnneeScolaire>
          }
          groupBy: {
            args: Prisma.AnneeScolaireGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnneeScolaireGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnneeScolaireCountArgs<ExtArgs>,
            result: $Utils.Optional<AnneeScolaireCountAggregateOutputType> | number
          }
        }
      }
      EvaluationEtudiants: {
        payload: Prisma.$EvaluationEtudiantsPayload<ExtArgs>
        fields: Prisma.EvaluationEtudiantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationEtudiantsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationEtudiantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationEtudiantsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationEtudiantsPayload>
          }
          findFirst: {
            args: Prisma.EvaluationEtudiantsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationEtudiantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationEtudiantsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationEtudiantsPayload>
          }
          findMany: {
            args: Prisma.EvaluationEtudiantsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationEtudiantsPayload>[]
          }
          create: {
            args: Prisma.EvaluationEtudiantsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationEtudiantsPayload>
          }
          createMany: {
            args: Prisma.EvaluationEtudiantsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EvaluationEtudiantsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationEtudiantsPayload>
          }
          update: {
            args: Prisma.EvaluationEtudiantsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationEtudiantsPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationEtudiantsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationEtudiantsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationEtudiantsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationEtudiantsPayload>
          }
          aggregate: {
            args: Prisma.EvaluationEtudiantsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvaluationEtudiants>
          }
          groupBy: {
            args: Prisma.EvaluationEtudiantsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationEtudiantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationEtudiantsCountArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationEtudiantsCountAggregateOutputType> | number
          }
        }
      }
      NoteEtudiant: {
        payload: Prisma.$NoteEtudiantPayload<ExtArgs>
        fields: Prisma.NoteEtudiantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteEtudiantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NoteEtudiantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteEtudiantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NoteEtudiantPayload>
          }
          findFirst: {
            args: Prisma.NoteEtudiantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NoteEtudiantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteEtudiantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NoteEtudiantPayload>
          }
          findMany: {
            args: Prisma.NoteEtudiantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NoteEtudiantPayload>[]
          }
          create: {
            args: Prisma.NoteEtudiantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NoteEtudiantPayload>
          }
          createMany: {
            args: Prisma.NoteEtudiantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NoteEtudiantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NoteEtudiantPayload>
          }
          update: {
            args: Prisma.NoteEtudiantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NoteEtudiantPayload>
          }
          deleteMany: {
            args: Prisma.NoteEtudiantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NoteEtudiantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NoteEtudiantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NoteEtudiantPayload>
          }
          aggregate: {
            args: Prisma.NoteEtudiantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNoteEtudiant>
          }
          groupBy: {
            args: Prisma.NoteEtudiantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NoteEtudiantGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteEtudiantCountArgs<ExtArgs>,
            result: $Utils.Optional<NoteEtudiantCountAggregateOutputType> | number
          }
        }
      }
      Cours: {
        payload: Prisma.$CoursPayload<ExtArgs>
        fields: Prisma.CoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoursFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoursFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursPayload>
          }
          findFirst: {
            args: Prisma.CoursFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoursFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursPayload>
          }
          findMany: {
            args: Prisma.CoursFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursPayload>[]
          }
          create: {
            args: Prisma.CoursCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursPayload>
          }
          createMany: {
            args: Prisma.CoursCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CoursDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursPayload>
          }
          update: {
            args: Prisma.CoursUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursPayload>
          }
          deleteMany: {
            args: Prisma.CoursDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CoursUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CoursUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursPayload>
          }
          aggregate: {
            args: Prisma.CoursAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCours>
          }
          groupBy: {
            args: Prisma.CoursGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoursCountArgs<ExtArgs>,
            result: $Utils.Optional<CoursCountAggregateOutputType> | number
          }
        }
      }
      Salle: {
        payload: Prisma.$SallePayload<ExtArgs>
        fields: Prisma.SalleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SallePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          findFirst: {
            args: Prisma.SalleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SallePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          findMany: {
            args: Prisma.SalleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SallePayload>[]
          }
          create: {
            args: Prisma.SalleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          createMany: {
            args: Prisma.SalleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SalleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          update: {
            args: Prisma.SalleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          deleteMany: {
            args: Prisma.SalleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SalleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SalleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          aggregate: {
            args: Prisma.SalleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSalle>
          }
          groupBy: {
            args: Prisma.SalleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SalleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalleCountArgs<ExtArgs>,
            result: $Utils.Optional<SalleCountAggregateOutputType> | number
          }
        }
      }
      FeuillePresence: {
        payload: Prisma.$FeuillePresencePayload<ExtArgs>
        fields: Prisma.FeuillePresenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeuillePresenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeuillePresencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeuillePresenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeuillePresencePayload>
          }
          findFirst: {
            args: Prisma.FeuillePresenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeuillePresencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeuillePresenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeuillePresencePayload>
          }
          findMany: {
            args: Prisma.FeuillePresenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeuillePresencePayload>[]
          }
          create: {
            args: Prisma.FeuillePresenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeuillePresencePayload>
          }
          createMany: {
            args: Prisma.FeuillePresenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeuillePresenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeuillePresencePayload>
          }
          update: {
            args: Prisma.FeuillePresenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeuillePresencePayload>
          }
          deleteMany: {
            args: Prisma.FeuillePresenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeuillePresenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeuillePresenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeuillePresencePayload>
          }
          aggregate: {
            args: Prisma.FeuillePresenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeuillePresence>
          }
          groupBy: {
            args: Prisma.FeuillePresenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeuillePresenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeuillePresenceCountArgs<ExtArgs>,
            result: $Utils.Optional<FeuillePresenceCountAggregateOutputType> | number
          }
        }
      }
      EmploiDuTemps: {
        payload: Prisma.$EmploiDuTempsPayload<ExtArgs>
        fields: Prisma.EmploiDuTempsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmploiDuTempsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploiDuTempsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmploiDuTempsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploiDuTempsPayload>
          }
          findFirst: {
            args: Prisma.EmploiDuTempsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploiDuTempsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmploiDuTempsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploiDuTempsPayload>
          }
          findMany: {
            args: Prisma.EmploiDuTempsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploiDuTempsPayload>[]
          }
          create: {
            args: Prisma.EmploiDuTempsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploiDuTempsPayload>
          }
          createMany: {
            args: Prisma.EmploiDuTempsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmploiDuTempsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploiDuTempsPayload>
          }
          update: {
            args: Prisma.EmploiDuTempsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploiDuTempsPayload>
          }
          deleteMany: {
            args: Prisma.EmploiDuTempsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmploiDuTempsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmploiDuTempsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploiDuTempsPayload>
          }
          aggregate: {
            args: Prisma.EmploiDuTempsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmploiDuTemps>
          }
          groupBy: {
            args: Prisma.EmploiDuTempsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmploiDuTempsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmploiDuTempsCountArgs<ExtArgs>,
            result: $Utils.Optional<EmploiDuTempsCountAggregateOutputType> | number
          }
        }
      }
      Paiement: {
        payload: Prisma.$PaiementPayload<ExtArgs>
        fields: Prisma.PaiementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaiementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaiementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findFirst: {
            args: Prisma.PaiementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaiementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findMany: {
            args: Prisma.PaiementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          create: {
            args: Prisma.PaiementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          createMany: {
            args: Prisma.PaiementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaiementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          update: {
            args: Prisma.PaiementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          deleteMany: {
            args: Prisma.PaiementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaiementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaiementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          aggregate: {
            args: Prisma.PaiementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePaiement>
          }
          groupBy: {
            args: Prisma.PaiementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaiementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaiementCountArgs<ExtArgs>,
            result: $Utils.Optional<PaiementCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UtilisateurCountOutputType
   */

  export type UtilisateurCountOutputType = {
    permissions: number
  }

  export type UtilisateurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | UtilisateurCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilisateurCountOutputType
     */
    select?: UtilisateurCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }



  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    utilisateurs: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateurs?: boolean | PermissionCountOutputTypeCountUtilisateursArgs
  }

  // Custom InputTypes

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilisateurWhereInput
  }



  /**
   * Count Type AdresseCountOutputType
   */

  export type AdresseCountOutputType = {
    utilisateurs: number
    etablissements: number
  }

  export type AdresseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateurs?: boolean | AdresseCountOutputTypeCountUtilisateursArgs
    etablissements?: boolean | AdresseCountOutputTypeCountEtablissementsArgs
  }

  // Custom InputTypes

  /**
   * AdresseCountOutputType without action
   */
  export type AdresseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdresseCountOutputType
     */
    select?: AdresseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AdresseCountOutputType without action
   */
  export type AdresseCountOutputTypeCountUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilisateurWhereInput
  }


  /**
   * AdresseCountOutputType without action
   */
  export type AdresseCountOutputTypeCountEtablissementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtablissementWhereInput
  }



  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    reseauxSociaux: number
    utilisateurs: number
    etablissements: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reseauxSociaux?: boolean | ContactCountOutputTypeCountReseauxSociauxArgs
    utilisateurs?: boolean | ContactCountOutputTypeCountUtilisateursArgs
    etablissements?: boolean | ContactCountOutputTypeCountEtablissementsArgs
  }

  // Custom InputTypes

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountReseauxSociauxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReseauSocialWhereInput
  }


  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilisateurWhereInput
  }


  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountEtablissementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtablissementWhereInput
  }



  /**
   * Count Type EtudiantCountOutputType
   */

  export type EtudiantCountOutputType = {
    inscriptions: number
    notes: number
    feuillePresences: number
    Paiement: number
  }

  export type EtudiantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscriptions?: boolean | EtudiantCountOutputTypeCountInscriptionsArgs
    notes?: boolean | EtudiantCountOutputTypeCountNotesArgs
    feuillePresences?: boolean | EtudiantCountOutputTypeCountFeuillePresencesArgs
    Paiement?: boolean | EtudiantCountOutputTypeCountPaiementArgs
  }

  // Custom InputTypes

  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantCountOutputType
     */
    select?: EtudiantCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountInscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscriptionWhereInput
  }


  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteEtudiantWhereInput
  }


  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountFeuillePresencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeuillePresenceWhereInput
  }


  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountPaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }



  /**
   * Count Type ProfesseurCountOutputType
   */

  export type ProfesseurCountOutputType = {
    cours: number
    EmploiDuTemps: number
  }

  export type ProfesseurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cours?: boolean | ProfesseurCountOutputTypeCountCoursArgs
    EmploiDuTemps?: boolean | ProfesseurCountOutputTypeCountEmploiDuTempsArgs
  }

  // Custom InputTypes

  /**
   * ProfesseurCountOutputType without action
   */
  export type ProfesseurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurCountOutputType
     */
    select?: ProfesseurCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProfesseurCountOutputType without action
   */
  export type ProfesseurCountOutputTypeCountCoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursWhereInput
  }


  /**
   * ProfesseurCountOutputType without action
   */
  export type ProfesseurCountOutputTypeCountEmploiDuTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploiDuTempsWhereInput
  }



  /**
   * Count Type DomaineCountOutputType
   */

  export type DomaineCountOutputType = {
    etablissements: number
    mentions: number
  }

  export type DomaineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etablissements?: boolean | DomaineCountOutputTypeCountEtablissementsArgs
    mentions?: boolean | DomaineCountOutputTypeCountMentionsArgs
  }

  // Custom InputTypes

  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomaineCountOutputType
     */
    select?: DomaineCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeCountEtablissementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtablissementWhereInput
  }


  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeCountMentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentionWhereInput
  }



  /**
   * Count Type MentionCountOutputType
   */

  export type MentionCountOutputType = {
    specialites: number
  }

  export type MentionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specialites?: boolean | MentionCountOutputTypeCountSpecialitesArgs
  }

  // Custom InputTypes

  /**
   * MentionCountOutputType without action
   */
  export type MentionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentionCountOutputType
     */
    select?: MentionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MentionCountOutputType without action
   */
  export type MentionCountOutputTypeCountSpecialitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialiteWhereInput
  }



  /**
   * Count Type SpecialiteCountOutputType
   */

  export type SpecialiteCountOutputType = {
    Classe: number
    Diplome: number
  }

  export type SpecialiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Classe?: boolean | SpecialiteCountOutputTypeCountClasseArgs
    Diplome?: boolean | SpecialiteCountOutputTypeCountDiplomeArgs
  }

  // Custom InputTypes

  /**
   * SpecialiteCountOutputType without action
   */
  export type SpecialiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialiteCountOutputType
     */
    select?: SpecialiteCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SpecialiteCountOutputType without action
   */
  export type SpecialiteCountOutputTypeCountClasseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClasseWhereInput
  }


  /**
   * SpecialiteCountOutputType without action
   */
  export type SpecialiteCountOutputTypeCountDiplomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiplomeWhereInput
  }



  /**
   * Count Type DiplomeCountOutputType
   */

  export type DiplomeCountOutputType = {
    inscriptions: number
  }

  export type DiplomeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscriptions?: boolean | DiplomeCountOutputTypeCountInscriptionsArgs
  }

  // Custom InputTypes

  /**
   * DiplomeCountOutputType without action
   */
  export type DiplomeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiplomeCountOutputType
     */
    select?: DiplomeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DiplomeCountOutputType without action
   */
  export type DiplomeCountOutputTypeCountInscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscriptionWhereInput
  }



  /**
   * Count Type SemestreCountOutputType
   */

  export type SemestreCountOutputType = {
    uniteEnseignement: number
  }

  export type SemestreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uniteEnseignement?: boolean | SemestreCountOutputTypeCountUniteEnseignementArgs
  }

  // Custom InputTypes

  /**
   * SemestreCountOutputType without action
   */
  export type SemestreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemestreCountOutputType
     */
    select?: SemestreCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SemestreCountOutputType without action
   */
  export type SemestreCountOutputTypeCountUniteEnseignementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniteEnseignementWhereInput
  }



  /**
   * Count Type UniteEnseignementCountOutputType
   */

  export type UniteEnseignementCountOutputType = {
    matieres: number
  }

  export type UniteEnseignementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matieres?: boolean | UniteEnseignementCountOutputTypeCountMatieresArgs
  }

  // Custom InputTypes

  /**
   * UniteEnseignementCountOutputType without action
   */
  export type UniteEnseignementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignementCountOutputType
     */
    select?: UniteEnseignementCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UniteEnseignementCountOutputType without action
   */
  export type UniteEnseignementCountOutputTypeCountMatieresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatiereWhereInput
  }



  /**
   * Count Type MatiereCountOutputType
   */

  export type MatiereCountOutputType = {
    cours: number
  }

  export type MatiereCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cours?: boolean | MatiereCountOutputTypeCountCoursArgs
  }

  // Custom InputTypes

  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatiereCountOutputType
     */
    select?: MatiereCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountCoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursWhereInput
  }



  /**
   * Count Type EtablissementCountOutputType
   */

  export type EtablissementCountOutputType = {
    utilisateurs: number
    domaines: number
    classes: number
    salle: number
  }

  export type EtablissementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateurs?: boolean | EtablissementCountOutputTypeCountUtilisateursArgs
    domaines?: boolean | EtablissementCountOutputTypeCountDomainesArgs
    classes?: boolean | EtablissementCountOutputTypeCountClassesArgs
    salle?: boolean | EtablissementCountOutputTypeCountSalleArgs
  }

  // Custom InputTypes

  /**
   * EtablissementCountOutputType without action
   */
  export type EtablissementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtablissementCountOutputType
     */
    select?: EtablissementCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EtablissementCountOutputType without action
   */
  export type EtablissementCountOutputTypeCountUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilisateurWhereInput
  }


  /**
   * EtablissementCountOutputType without action
   */
  export type EtablissementCountOutputTypeCountDomainesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomaineWhereInput
  }


  /**
   * EtablissementCountOutputType without action
   */
  export type EtablissementCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClasseWhereInput
  }


  /**
   * EtablissementCountOutputType without action
   */
  export type EtablissementCountOutputTypeCountSalleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalleWhereInput
  }



  /**
   * Count Type ClasseCountOutputType
   */

  export type ClasseCountOutputType = {
    semestres: number
    inscriptions: number
    Cours: number
    EmploiDuTemps: number
  }

  export type ClasseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semestres?: boolean | ClasseCountOutputTypeCountSemestresArgs
    inscriptions?: boolean | ClasseCountOutputTypeCountInscriptionsArgs
    Cours?: boolean | ClasseCountOutputTypeCountCoursArgs
    EmploiDuTemps?: boolean | ClasseCountOutputTypeCountEmploiDuTempsArgs
  }

  // Custom InputTypes

  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClasseCountOutputType
     */
    select?: ClasseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeCountSemestresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemestreWhereInput
  }


  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeCountInscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscriptionWhereInput
  }


  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeCountCoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursWhereInput
  }


  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeCountEmploiDuTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploiDuTempsWhereInput
  }



  /**
   * Count Type AnneeScolaireCountOutputType
   */

  export type AnneeScolaireCountOutputType = {
    classes: number
  }

  export type AnneeScolaireCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | AnneeScolaireCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes

  /**
   * AnneeScolaireCountOutputType without action
   */
  export type AnneeScolaireCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaireCountOutputType
     */
    select?: AnneeScolaireCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AnneeScolaireCountOutputType without action
   */
  export type AnneeScolaireCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClasseWhereInput
  }



  /**
   * Count Type EvaluationEtudiantsCountOutputType
   */

  export type EvaluationEtudiantsCountOutputType = {
    NoteEtudiant: number
  }

  export type EvaluationEtudiantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NoteEtudiant?: boolean | EvaluationEtudiantsCountOutputTypeCountNoteEtudiantArgs
  }

  // Custom InputTypes

  /**
   * EvaluationEtudiantsCountOutputType without action
   */
  export type EvaluationEtudiantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiantsCountOutputType
     */
    select?: EvaluationEtudiantsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EvaluationEtudiantsCountOutputType without action
   */
  export type EvaluationEtudiantsCountOutputTypeCountNoteEtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteEtudiantWhereInput
  }



  /**
   * Count Type CoursCountOutputType
   */

  export type CoursCountOutputType = {
    evaluationEtudiant: number
    feuillePresences: number
    emploiDuTemps: number
  }

  export type CoursCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationEtudiant?: boolean | CoursCountOutputTypeCountEvaluationEtudiantArgs
    feuillePresences?: boolean | CoursCountOutputTypeCountFeuillePresencesArgs
    emploiDuTemps?: boolean | CoursCountOutputTypeCountEmploiDuTempsArgs
  }

  // Custom InputTypes

  /**
   * CoursCountOutputType without action
   */
  export type CoursCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursCountOutputType
     */
    select?: CoursCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CoursCountOutputType without action
   */
  export type CoursCountOutputTypeCountEvaluationEtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationEtudiantsWhereInput
  }


  /**
   * CoursCountOutputType without action
   */
  export type CoursCountOutputTypeCountFeuillePresencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeuillePresenceWhereInput
  }


  /**
   * CoursCountOutputType without action
   */
  export type CoursCountOutputTypeCountEmploiDuTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploiDuTempsWhereInput
  }



  /**
   * Count Type SalleCountOutputType
   */

  export type SalleCountOutputType = {
    cours: number
    EmploiDuTemps: number
  }

  export type SalleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cours?: boolean | SalleCountOutputTypeCountCoursArgs
    EmploiDuTemps?: boolean | SalleCountOutputTypeCountEmploiDuTempsArgs
  }

  // Custom InputTypes

  /**
   * SalleCountOutputType without action
   */
  export type SalleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalleCountOutputType
     */
    select?: SalleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SalleCountOutputType without action
   */
  export type SalleCountOutputTypeCountCoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursWhereInput
  }


  /**
   * SalleCountOutputType without action
   */
  export type SalleCountOutputTypeCountEmploiDuTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploiDuTempsWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    uid: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    password: string | null
    isActive: boolean | null
    userId: number | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    password: string | null
    isActive: boolean | null
    userId: number | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    uid: number
    createdAt: number
    updatedAt: number
    username: number
    password: number
    roles: number
    isActive: number
    userId: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    uid?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    password?: true
    isActive?: true
    userId?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    uid?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    password?: true
    isActive?: true
    userId?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    uid?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    password?: true
    roles?: true
    isActive?: true
    userId?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    uid: string
    createdAt: Date
    updatedAt: Date
    username: string
    password: string
    roles: $Enums.Role[]
    isActive: boolean
    userId: number
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    password?: boolean
    roles?: boolean
    isActive?: boolean
    userId?: boolean
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    uid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    password?: boolean
    roles?: boolean
    isActive?: boolean
    userId?: boolean
  }


  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uid: string
      createdAt: Date
      updatedAt: Date
      username: string
      password: string
      roles: $Enums.Role[]
      isActive: boolean
      userId: number
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly uid: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly username: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly roles: FieldRef<"Account", 'Role[]'>
    readonly isActive: FieldRef<"Account", 'Boolean'>
    readonly userId: FieldRef<"Account", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
  }



  /**
   * Model Utilisateur
   */

  export type AggregateUtilisateur = {
    _count: UtilisateurCountAggregateOutputType | null
    _avg: UtilisateurAvgAggregateOutputType | null
    _sum: UtilisateurSumAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  export type UtilisateurAvgAggregateOutputType = {
    id: number | null
    etablissementId: number | null
    contactId: number | null
    adresseId: number | null
    accountId: number | null
  }

  export type UtilisateurSumAggregateOutputType = {
    id: number | null
    etablissementId: number | null
    contactId: number | null
    adresseId: number | null
    accountId: number | null
  }

  export type UtilisateurMinAggregateOutputType = {
    id: number | null
    matricule: string | null
    createdAt: Date | null
    updatedAt: Date | null
    prenom: string | null
    nom: string | null
    dateNaissance: Date | null
    lieuNaissance: string | null
    cni: string | null
    genre: $Enums.Genre | null
    nationalite: string | null
    groupeSanguin: $Enums.GroupeSanguin | null
    etablissementId: number | null
    statutCompte: string | null
    contactId: number | null
    adresseId: number | null
    accountId: number | null
  }

  export type UtilisateurMaxAggregateOutputType = {
    id: number | null
    matricule: string | null
    createdAt: Date | null
    updatedAt: Date | null
    prenom: string | null
    nom: string | null
    dateNaissance: Date | null
    lieuNaissance: string | null
    cni: string | null
    genre: $Enums.Genre | null
    nationalite: string | null
    groupeSanguin: $Enums.GroupeSanguin | null
    etablissementId: number | null
    statutCompte: string | null
    contactId: number | null
    adresseId: number | null
    accountId: number | null
  }

  export type UtilisateurCountAggregateOutputType = {
    id: number
    matricule: number
    createdAt: number
    updatedAt: number
    prenom: number
    nom: number
    dateNaissance: number
    lieuNaissance: number
    cni: number
    genre: number
    nationalite: number
    groupeSanguin: number
    etablissementId: number
    statutCompte: number
    roles: number
    contactId: number
    adresseId: number
    accountId: number
    _all: number
  }


  export type UtilisateurAvgAggregateInputType = {
    id?: true
    etablissementId?: true
    contactId?: true
    adresseId?: true
    accountId?: true
  }

  export type UtilisateurSumAggregateInputType = {
    id?: true
    etablissementId?: true
    contactId?: true
    adresseId?: true
    accountId?: true
  }

  export type UtilisateurMinAggregateInputType = {
    id?: true
    matricule?: true
    createdAt?: true
    updatedAt?: true
    prenom?: true
    nom?: true
    dateNaissance?: true
    lieuNaissance?: true
    cni?: true
    genre?: true
    nationalite?: true
    groupeSanguin?: true
    etablissementId?: true
    statutCompte?: true
    contactId?: true
    adresseId?: true
    accountId?: true
  }

  export type UtilisateurMaxAggregateInputType = {
    id?: true
    matricule?: true
    createdAt?: true
    updatedAt?: true
    prenom?: true
    nom?: true
    dateNaissance?: true
    lieuNaissance?: true
    cni?: true
    genre?: true
    nationalite?: true
    groupeSanguin?: true
    etablissementId?: true
    statutCompte?: true
    contactId?: true
    adresseId?: true
    accountId?: true
  }

  export type UtilisateurCountAggregateInputType = {
    id?: true
    matricule?: true
    createdAt?: true
    updatedAt?: true
    prenom?: true
    nom?: true
    dateNaissance?: true
    lieuNaissance?: true
    cni?: true
    genre?: true
    nationalite?: true
    groupeSanguin?: true
    etablissementId?: true
    statutCompte?: true
    roles?: true
    contactId?: true
    adresseId?: true
    accountId?: true
    _all?: true
  }

  export type UtilisateurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateur to aggregate.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Utilisateurs
    **/
    _count?: true | UtilisateurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtilisateurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtilisateurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtilisateurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtilisateurMaxAggregateInputType
  }

  export type GetUtilisateurAggregateType<T extends UtilisateurAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilisateur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilisateur[P]>
      : GetScalarType<T[P], AggregateUtilisateur[P]>
  }




  export type UtilisateurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilisateurWhereInput
    orderBy?: UtilisateurOrderByWithAggregationInput | UtilisateurOrderByWithAggregationInput[]
    by: UtilisateurScalarFieldEnum[] | UtilisateurScalarFieldEnum
    having?: UtilisateurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtilisateurCountAggregateInputType | true
    _avg?: UtilisateurAvgAggregateInputType
    _sum?: UtilisateurSumAggregateInputType
    _min?: UtilisateurMinAggregateInputType
    _max?: UtilisateurMaxAggregateInputType
  }

  export type UtilisateurGroupByOutputType = {
    id: number
    matricule: string
    createdAt: Date
    updatedAt: Date
    prenom: string
    nom: string
    dateNaissance: Date | null
    lieuNaissance: string | null
    cni: string | null
    genre: $Enums.Genre
    nationalite: string | null
    groupeSanguin: $Enums.GroupeSanguin | null
    etablissementId: number | null
    statutCompte: string | null
    roles: $Enums.Role[]
    contactId: number | null
    adresseId: number | null
    accountId: number | null
    _count: UtilisateurCountAggregateOutputType | null
    _avg: UtilisateurAvgAggregateOutputType | null
    _sum: UtilisateurSumAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  type GetUtilisateurGroupByPayload<T extends UtilisateurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtilisateurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtilisateurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
            : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
        }
      >
    >


  export type UtilisateurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matricule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prenom?: boolean
    nom?: boolean
    dateNaissance?: boolean
    lieuNaissance?: boolean
    cni?: boolean
    genre?: boolean
    nationalite?: boolean
    groupeSanguin?: boolean
    etablissementId?: boolean
    statutCompte?: boolean
    roles?: boolean
    contactId?: boolean
    adresseId?: boolean
    accountId?: boolean
    contact?: boolean | Utilisateur$contactArgs<ExtArgs>
    adresse?: boolean | Utilisateur$adresseArgs<ExtArgs>
    etablissement?: boolean | Utilisateur$etablissementArgs<ExtArgs>
    etudiant?: boolean | Utilisateur$etudiantArgs<ExtArgs>
    permissions?: boolean | Utilisateur$permissionsArgs<ExtArgs>
    Professeur?: boolean | Utilisateur$ProfesseurArgs<ExtArgs>
    _count?: boolean | UtilisateurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectScalar = {
    id?: boolean
    matricule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prenom?: boolean
    nom?: boolean
    dateNaissance?: boolean
    lieuNaissance?: boolean
    cni?: boolean
    genre?: boolean
    nationalite?: boolean
    groupeSanguin?: boolean
    etablissementId?: boolean
    statutCompte?: boolean
    roles?: boolean
    contactId?: boolean
    adresseId?: boolean
    accountId?: boolean
  }

  export type UtilisateurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | Utilisateur$contactArgs<ExtArgs>
    adresse?: boolean | Utilisateur$adresseArgs<ExtArgs>
    etablissement?: boolean | Utilisateur$etablissementArgs<ExtArgs>
    etudiant?: boolean | Utilisateur$etudiantArgs<ExtArgs>
    permissions?: boolean | Utilisateur$permissionsArgs<ExtArgs>
    Professeur?: boolean | Utilisateur$ProfesseurArgs<ExtArgs>
    _count?: boolean | UtilisateurCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UtilisateurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Utilisateur"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs> | null
      adresse: Prisma.$AdressePayload<ExtArgs> | null
      etablissement: Prisma.$EtablissementPayload<ExtArgs> | null
      etudiant: Prisma.$EtudiantPayload<ExtArgs> | null
      permissions: Prisma.$PermissionPayload<ExtArgs>[]
      Professeur: Prisma.$ProfesseurPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      matricule: string
      createdAt: Date
      updatedAt: Date
      prenom: string
      nom: string
      dateNaissance: Date | null
      lieuNaissance: string | null
      cni: string | null
      genre: $Enums.Genre
      nationalite: string | null
      groupeSanguin: $Enums.GroupeSanguin | null
      etablissementId: number | null
      statutCompte: string | null
      /**
       * user role
       */
      roles: $Enums.Role[]
      contactId: number | null
      adresseId: number | null
      accountId: number | null
    }, ExtArgs["result"]["utilisateur"]>
    composites: {}
  }


  type UtilisateurGetPayload<S extends boolean | null | undefined | UtilisateurDefaultArgs> = $Result.GetResult<Prisma.$UtilisateurPayload, S>

  type UtilisateurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UtilisateurFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UtilisateurCountAggregateInputType | true
    }

  export interface UtilisateurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Utilisateur'], meta: { name: 'Utilisateur' } }
    /**
     * Find zero or one Utilisateur that matches the filter.
     * @param {UtilisateurFindUniqueArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UtilisateurFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurFindUniqueArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Utilisateur that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UtilisateurFindUniqueOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UtilisateurFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Utilisateur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UtilisateurFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurFindFirstArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Utilisateur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UtilisateurFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany()
     * 
     * // Get first 10 Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const utilisateurWithIdOnly = await prisma.utilisateur.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UtilisateurFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Utilisateur.
     * @param {UtilisateurCreateArgs} args - Arguments to create a Utilisateur.
     * @example
     * // Create one Utilisateur
     * const Utilisateur = await prisma.utilisateur.create({
     *   data: {
     *     // ... data to create a Utilisateur
     *   }
     * })
     * 
    **/
    create<T extends UtilisateurCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurCreateArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Utilisateurs.
     *     @param {UtilisateurCreateManyArgs} args - Arguments to create many Utilisateurs.
     *     @example
     *     // Create many Utilisateurs
     *     const utilisateur = await prisma.utilisateur.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UtilisateurCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Utilisateur.
     * @param {UtilisateurDeleteArgs} args - Arguments to delete one Utilisateur.
     * @example
     * // Delete one Utilisateur
     * const Utilisateur = await prisma.utilisateur.delete({
     *   where: {
     *     // ... filter to delete one Utilisateur
     *   }
     * })
     * 
    **/
    delete<T extends UtilisateurDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurDeleteArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Utilisateur.
     * @param {UtilisateurUpdateArgs} args - Arguments to update one Utilisateur.
     * @example
     * // Update one Utilisateur
     * const utilisateur = await prisma.utilisateur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UtilisateurUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurUpdateArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Utilisateurs.
     * @param {UtilisateurDeleteManyArgs} args - Arguments to filter Utilisateurs to delete.
     * @example
     * // Delete a few Utilisateurs
     * const { count } = await prisma.utilisateur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UtilisateurDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utilisateurs
     * const utilisateur = await prisma.utilisateur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UtilisateurUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Utilisateur.
     * @param {UtilisateurUpsertArgs} args - Arguments to update or create a Utilisateur.
     * @example
     * // Update or create a Utilisateur
     * const utilisateur = await prisma.utilisateur.upsert({
     *   create: {
     *     // ... data to create a Utilisateur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utilisateur we want to update
     *   }
     * })
    **/
    upsert<T extends UtilisateurUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurUpsertArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurCountArgs} args - Arguments to filter Utilisateurs to count.
     * @example
     * // Count the number of Utilisateurs
     * const count = await prisma.utilisateur.count({
     *   where: {
     *     // ... the filter for the Utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends UtilisateurCountArgs>(
      args?: Subset<T, UtilisateurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtilisateurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtilisateurAggregateArgs>(args: Subset<T, UtilisateurAggregateArgs>): Prisma.PrismaPromise<GetUtilisateurAggregateType<T>>

    /**
     * Group by Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UtilisateurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UtilisateurGroupByArgs['orderBy'] }
        : { orderBy?: UtilisateurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UtilisateurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtilisateurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Utilisateur model
   */
  readonly fields: UtilisateurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Utilisateur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UtilisateurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contact<T extends Utilisateur$contactArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    adresse<T extends Utilisateur$adresseArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$adresseArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    etablissement<T extends Utilisateur$etablissementArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$etablissementArgs<ExtArgs>>): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    etudiant<T extends Utilisateur$etudiantArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$etudiantArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    permissions<T extends Utilisateur$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    Professeur<T extends Utilisateur$ProfesseurArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$ProfesseurArgs<ExtArgs>>): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Utilisateur model
   */ 
  interface UtilisateurFieldRefs {
    readonly id: FieldRef<"Utilisateur", 'Int'>
    readonly matricule: FieldRef<"Utilisateur", 'String'>
    readonly createdAt: FieldRef<"Utilisateur", 'DateTime'>
    readonly updatedAt: FieldRef<"Utilisateur", 'DateTime'>
    readonly prenom: FieldRef<"Utilisateur", 'String'>
    readonly nom: FieldRef<"Utilisateur", 'String'>
    readonly dateNaissance: FieldRef<"Utilisateur", 'DateTime'>
    readonly lieuNaissance: FieldRef<"Utilisateur", 'String'>
    readonly cni: FieldRef<"Utilisateur", 'String'>
    readonly genre: FieldRef<"Utilisateur", 'Genre'>
    readonly nationalite: FieldRef<"Utilisateur", 'String'>
    readonly groupeSanguin: FieldRef<"Utilisateur", 'GroupeSanguin'>
    readonly etablissementId: FieldRef<"Utilisateur", 'Int'>
    readonly statutCompte: FieldRef<"Utilisateur", 'String'>
    readonly roles: FieldRef<"Utilisateur", 'Role[]'>
    readonly contactId: FieldRef<"Utilisateur", 'Int'>
    readonly adresseId: FieldRef<"Utilisateur", 'Int'>
    readonly accountId: FieldRef<"Utilisateur", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Utilisateur findUnique
   */
  export type UtilisateurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }


  /**
   * Utilisateur findUniqueOrThrow
   */
  export type UtilisateurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }


  /**
   * Utilisateur findFirst
   */
  export type UtilisateurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Utilisateur findFirstOrThrow
   */
  export type UtilisateurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Utilisateur findMany
   */
  export type UtilisateurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateurs to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Utilisateur create
   */
  export type UtilisateurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * The data needed to create a Utilisateur.
     */
    data: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
  }


  /**
   * Utilisateur createMany
   */
  export type UtilisateurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Utilisateurs.
     */
    data: UtilisateurCreateManyInput | UtilisateurCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Utilisateur update
   */
  export type UtilisateurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * The data needed to update a Utilisateur.
     */
    data: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
    /**
     * Choose, which Utilisateur to update.
     */
    where: UtilisateurWhereUniqueInput
  }


  /**
   * Utilisateur updateMany
   */
  export type UtilisateurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Utilisateurs.
     */
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyInput>
    /**
     * Filter which Utilisateurs to update
     */
    where?: UtilisateurWhereInput
  }


  /**
   * Utilisateur upsert
   */
  export type UtilisateurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * The filter to search for the Utilisateur to update in case it exists.
     */
    where: UtilisateurWhereUniqueInput
    /**
     * In case the Utilisateur found by the `where` argument doesn't exist, create a new Utilisateur with this data.
     */
    create: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
    /**
     * In case the Utilisateur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
  }


  /**
   * Utilisateur delete
   */
  export type UtilisateurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter which Utilisateur to delete.
     */
    where: UtilisateurWhereUniqueInput
  }


  /**
   * Utilisateur deleteMany
   */
  export type UtilisateurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateurs to delete
     */
    where?: UtilisateurWhereInput
  }


  /**
   * Utilisateur.contact
   */
  export type Utilisateur$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }


  /**
   * Utilisateur.adresse
   */
  export type Utilisateur$adresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
  }


  /**
   * Utilisateur.etablissement
   */
  export type Utilisateur$etablissementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    where?: EtablissementWhereInput
  }


  /**
   * Utilisateur.etudiant
   */
  export type Utilisateur$etudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    where?: EtudiantWhereInput
  }


  /**
   * Utilisateur.permissions
   */
  export type Utilisateur$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }


  /**
   * Utilisateur.Professeur
   */
  export type Utilisateur$ProfesseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    where?: ProfesseurWhereInput
  }


  /**
   * Utilisateur without action
   */
  export type UtilisateurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
  }



  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    label: string | null
    slug: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    label: string | null
    slug: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    role: number
    label: number
    slug: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    label?: true
    slug?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    label?: true
    slug?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    label?: true
    slug?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    role: $Enums.Role[]
    label: string
    slug: string | null
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    label?: boolean
    slug?: boolean
    utilisateurs?: boolean | Permission$utilisateursArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    label?: boolean
    slug?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateurs?: boolean | Permission$utilisateursArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      utilisateurs: Prisma.$UtilisateurPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      role: $Enums.Role[]
      label: string
      slug: string | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }


  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
    **/
    create<T extends PermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Permissions.
     *     @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     *     @example
     *     // Create many Permissions
     *     const permission = await prisma.permission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
    **/
    delete<T extends PermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
    **/
    upsert<T extends PermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    utilisateurs<T extends Permission$utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, Permission$utilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
    readonly role: FieldRef<"Permission", 'Role[]'>
    readonly label: FieldRef<"Permission", 'String'>
    readonly slug: FieldRef<"Permission", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }


  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }


  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }


  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }


  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }


  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }


  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }


  /**
   * Permission.utilisateurs
   */
  export type Permission$utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    where?: UtilisateurWhereInput
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    cursor?: UtilisateurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude<ExtArgs> | null
  }



  /**
   * Model Adresse
   */

  export type AggregateAdresse = {
    _count: AdresseCountAggregateOutputType | null
    _avg: AdresseAvgAggregateOutputType | null
    _sum: AdresseSumAggregateOutputType | null
    _min: AdresseMinAggregateOutputType | null
    _max: AdresseMaxAggregateOutputType | null
  }

  export type AdresseAvgAggregateOutputType = {
    id: number | null
  }

  export type AdresseSumAggregateOutputType = {
    id: number | null
  }

  export type AdresseMinAggregateOutputType = {
    id: number | null
    pays: string | null
    region: string | null
    ville: string | null
    codePostal: string | null
    geolocalisation: string | null
  }

  export type AdresseMaxAggregateOutputType = {
    id: number | null
    pays: string | null
    region: string | null
    ville: string | null
    codePostal: string | null
    geolocalisation: string | null
  }

  export type AdresseCountAggregateOutputType = {
    id: number
    pays: number
    region: number
    ville: number
    codePostal: number
    geolocalisation: number
    _all: number
  }


  export type AdresseAvgAggregateInputType = {
    id?: true
  }

  export type AdresseSumAggregateInputType = {
    id?: true
  }

  export type AdresseMinAggregateInputType = {
    id?: true
    pays?: true
    region?: true
    ville?: true
    codePostal?: true
    geolocalisation?: true
  }

  export type AdresseMaxAggregateInputType = {
    id?: true
    pays?: true
    region?: true
    ville?: true
    codePostal?: true
    geolocalisation?: true
  }

  export type AdresseCountAggregateInputType = {
    id?: true
    pays?: true
    region?: true
    ville?: true
    codePostal?: true
    geolocalisation?: true
    _all?: true
  }

  export type AdresseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adresse to aggregate.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Adresses
    **/
    _count?: true | AdresseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdresseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdresseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdresseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdresseMaxAggregateInputType
  }

  export type GetAdresseAggregateType<T extends AdresseAggregateArgs> = {
        [P in keyof T & keyof AggregateAdresse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdresse[P]>
      : GetScalarType<T[P], AggregateAdresse[P]>
  }




  export type AdresseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdresseWhereInput
    orderBy?: AdresseOrderByWithAggregationInput | AdresseOrderByWithAggregationInput[]
    by: AdresseScalarFieldEnum[] | AdresseScalarFieldEnum
    having?: AdresseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdresseCountAggregateInputType | true
    _avg?: AdresseAvgAggregateInputType
    _sum?: AdresseSumAggregateInputType
    _min?: AdresseMinAggregateInputType
    _max?: AdresseMaxAggregateInputType
  }

  export type AdresseGroupByOutputType = {
    id: number
    pays: string
    region: string
    ville: string
    codePostal: string | null
    geolocalisation: string | null
    _count: AdresseCountAggregateOutputType | null
    _avg: AdresseAvgAggregateOutputType | null
    _sum: AdresseSumAggregateOutputType | null
    _min: AdresseMinAggregateOutputType | null
    _max: AdresseMaxAggregateOutputType | null
  }

  type GetAdresseGroupByPayload<T extends AdresseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdresseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdresseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdresseGroupByOutputType[P]>
            : GetScalarType<T[P], AdresseGroupByOutputType[P]>
        }
      >
    >


  export type AdresseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pays?: boolean
    region?: boolean
    ville?: boolean
    codePostal?: boolean
    geolocalisation?: boolean
    utilisateurs?: boolean | Adresse$utilisateursArgs<ExtArgs>
    etablissements?: boolean | Adresse$etablissementsArgs<ExtArgs>
    _count?: boolean | AdresseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adresse"]>

  export type AdresseSelectScalar = {
    id?: boolean
    pays?: boolean
    region?: boolean
    ville?: boolean
    codePostal?: boolean
    geolocalisation?: boolean
  }

  export type AdresseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateurs?: boolean | Adresse$utilisateursArgs<ExtArgs>
    etablissements?: boolean | Adresse$etablissementsArgs<ExtArgs>
    _count?: boolean | AdresseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AdressePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Adresse"
    objects: {
      utilisateurs: Prisma.$UtilisateurPayload<ExtArgs>[]
      etablissements: Prisma.$EtablissementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pays: string
      region: string
      ville: string
      codePostal: string | null
      geolocalisation: string | null
    }, ExtArgs["result"]["adresse"]>
    composites: {}
  }


  type AdresseGetPayload<S extends boolean | null | undefined | AdresseDefaultArgs> = $Result.GetResult<Prisma.$AdressePayload, S>

  type AdresseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdresseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdresseCountAggregateInputType | true
    }

  export interface AdresseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Adresse'], meta: { name: 'Adresse' } }
    /**
     * Find zero or one Adresse that matches the filter.
     * @param {AdresseFindUniqueArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdresseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdresseFindUniqueArgs<ExtArgs>>
    ): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Adresse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdresseFindUniqueOrThrowArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdresseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdresseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Adresse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseFindFirstArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdresseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdresseFindFirstArgs<ExtArgs>>
    ): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Adresse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseFindFirstOrThrowArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdresseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdresseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Adresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adresses
     * const adresses = await prisma.adresse.findMany()
     * 
     * // Get first 10 Adresses
     * const adresses = await prisma.adresse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adresseWithIdOnly = await prisma.adresse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdresseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdresseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Adresse.
     * @param {AdresseCreateArgs} args - Arguments to create a Adresse.
     * @example
     * // Create one Adresse
     * const Adresse = await prisma.adresse.create({
     *   data: {
     *     // ... data to create a Adresse
     *   }
     * })
     * 
    **/
    create<T extends AdresseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdresseCreateArgs<ExtArgs>>
    ): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Adresses.
     *     @param {AdresseCreateManyArgs} args - Arguments to create many Adresses.
     *     @example
     *     // Create many Adresses
     *     const adresse = await prisma.adresse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdresseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdresseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Adresse.
     * @param {AdresseDeleteArgs} args - Arguments to delete one Adresse.
     * @example
     * // Delete one Adresse
     * const Adresse = await prisma.adresse.delete({
     *   where: {
     *     // ... filter to delete one Adresse
     *   }
     * })
     * 
    **/
    delete<T extends AdresseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdresseDeleteArgs<ExtArgs>>
    ): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Adresse.
     * @param {AdresseUpdateArgs} args - Arguments to update one Adresse.
     * @example
     * // Update one Adresse
     * const adresse = await prisma.adresse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdresseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdresseUpdateArgs<ExtArgs>>
    ): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Adresses.
     * @param {AdresseDeleteManyArgs} args - Arguments to filter Adresses to delete.
     * @example
     * // Delete a few Adresses
     * const { count } = await prisma.adresse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdresseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdresseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adresses
     * const adresse = await prisma.adresse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdresseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdresseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Adresse.
     * @param {AdresseUpsertArgs} args - Arguments to update or create a Adresse.
     * @example
     * // Update or create a Adresse
     * const adresse = await prisma.adresse.upsert({
     *   create: {
     *     // ... data to create a Adresse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adresse we want to update
     *   }
     * })
    **/
    upsert<T extends AdresseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdresseUpsertArgs<ExtArgs>>
    ): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseCountArgs} args - Arguments to filter Adresses to count.
     * @example
     * // Count the number of Adresses
     * const count = await prisma.adresse.count({
     *   where: {
     *     // ... the filter for the Adresses we want to count
     *   }
     * })
    **/
    count<T extends AdresseCountArgs>(
      args?: Subset<T, AdresseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdresseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adresse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdresseAggregateArgs>(args: Subset<T, AdresseAggregateArgs>): Prisma.PrismaPromise<GetAdresseAggregateType<T>>

    /**
     * Group by Adresse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdresseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdresseGroupByArgs['orderBy'] }
        : { orderBy?: AdresseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdresseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdresseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Adresse model
   */
  readonly fields: AdresseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Adresse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdresseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    utilisateurs<T extends Adresse$utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$utilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findMany'> | Null>;

    etablissements<T extends Adresse$etablissementsArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$etablissementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Adresse model
   */ 
  interface AdresseFieldRefs {
    readonly id: FieldRef<"Adresse", 'Int'>
    readonly pays: FieldRef<"Adresse", 'String'>
    readonly region: FieldRef<"Adresse", 'String'>
    readonly ville: FieldRef<"Adresse", 'String'>
    readonly codePostal: FieldRef<"Adresse", 'String'>
    readonly geolocalisation: FieldRef<"Adresse", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Adresse findUnique
   */
  export type AdresseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where: AdresseWhereUniqueInput
  }


  /**
   * Adresse findUniqueOrThrow
   */
  export type AdresseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where: AdresseWhereUniqueInput
  }


  /**
   * Adresse findFirst
   */
  export type AdresseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adresses.
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adresses.
     */
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }


  /**
   * Adresse findFirstOrThrow
   */
  export type AdresseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adresses.
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adresses.
     */
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }


  /**
   * Adresse findMany
   */
  export type AdresseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresses to fetch.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Adresses.
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }


  /**
   * Adresse create
   */
  export type AdresseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * The data needed to create a Adresse.
     */
    data: XOR<AdresseCreateInput, AdresseUncheckedCreateInput>
  }


  /**
   * Adresse createMany
   */
  export type AdresseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Adresses.
     */
    data: AdresseCreateManyInput | AdresseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Adresse update
   */
  export type AdresseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * The data needed to update a Adresse.
     */
    data: XOR<AdresseUpdateInput, AdresseUncheckedUpdateInput>
    /**
     * Choose, which Adresse to update.
     */
    where: AdresseWhereUniqueInput
  }


  /**
   * Adresse updateMany
   */
  export type AdresseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Adresses.
     */
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyInput>
    /**
     * Filter which Adresses to update
     */
    where?: AdresseWhereInput
  }


  /**
   * Adresse upsert
   */
  export type AdresseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * The filter to search for the Adresse to update in case it exists.
     */
    where: AdresseWhereUniqueInput
    /**
     * In case the Adresse found by the `where` argument doesn't exist, create a new Adresse with this data.
     */
    create: XOR<AdresseCreateInput, AdresseUncheckedCreateInput>
    /**
     * In case the Adresse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdresseUpdateInput, AdresseUncheckedUpdateInput>
  }


  /**
   * Adresse delete
   */
  export type AdresseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter which Adresse to delete.
     */
    where: AdresseWhereUniqueInput
  }


  /**
   * Adresse deleteMany
   */
  export type AdresseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adresses to delete
     */
    where?: AdresseWhereInput
  }


  /**
   * Adresse.utilisateurs
   */
  export type Adresse$utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    where?: UtilisateurWhereInput
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    cursor?: UtilisateurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Adresse.etablissements
   */
  export type Adresse$etablissementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    where?: EtablissementWhereInput
    orderBy?: EtablissementOrderByWithRelationInput | EtablissementOrderByWithRelationInput[]
    cursor?: EtablissementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtablissementScalarFieldEnum | EtablissementScalarFieldEnum[]
  }


  /**
   * Adresse without action
   */
  export type AdresseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
  }



  /**
   * Model ReseauSocial
   */

  export type AggregateReseauSocial = {
    _count: ReseauSocialCountAggregateOutputType | null
    _avg: ReseauSocialAvgAggregateOutputType | null
    _sum: ReseauSocialSumAggregateOutputType | null
    _min: ReseauSocialMinAggregateOutputType | null
    _max: ReseauSocialMaxAggregateOutputType | null
  }

  export type ReseauSocialAvgAggregateOutputType = {
    id: number | null
    contactId: number | null
  }

  export type ReseauSocialSumAggregateOutputType = {
    id: number | null
    contactId: number | null
  }

  export type ReseauSocialMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    username: string | null
    url: string | null
    contactId: number | null
  }

  export type ReseauSocialMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    username: string | null
    url: string | null
    contactId: number | null
  }

  export type ReseauSocialCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    username: number
    url: number
    contactId: number
    _all: number
  }


  export type ReseauSocialAvgAggregateInputType = {
    id?: true
    contactId?: true
  }

  export type ReseauSocialSumAggregateInputType = {
    id?: true
    contactId?: true
  }

  export type ReseauSocialMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    username?: true
    url?: true
    contactId?: true
  }

  export type ReseauSocialMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    username?: true
    url?: true
    contactId?: true
  }

  export type ReseauSocialCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    username?: true
    url?: true
    contactId?: true
    _all?: true
  }

  export type ReseauSocialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReseauSocial to aggregate.
     */
    where?: ReseauSocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReseauSocials to fetch.
     */
    orderBy?: ReseauSocialOrderByWithRelationInput | ReseauSocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReseauSocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReseauSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReseauSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReseauSocials
    **/
    _count?: true | ReseauSocialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReseauSocialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReseauSocialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReseauSocialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReseauSocialMaxAggregateInputType
  }

  export type GetReseauSocialAggregateType<T extends ReseauSocialAggregateArgs> = {
        [P in keyof T & keyof AggregateReseauSocial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReseauSocial[P]>
      : GetScalarType<T[P], AggregateReseauSocial[P]>
  }




  export type ReseauSocialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReseauSocialWhereInput
    orderBy?: ReseauSocialOrderByWithAggregationInput | ReseauSocialOrderByWithAggregationInput[]
    by: ReseauSocialScalarFieldEnum[] | ReseauSocialScalarFieldEnum
    having?: ReseauSocialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReseauSocialCountAggregateInputType | true
    _avg?: ReseauSocialAvgAggregateInputType
    _sum?: ReseauSocialSumAggregateInputType
    _min?: ReseauSocialMinAggregateInputType
    _max?: ReseauSocialMaxAggregateInputType
  }

  export type ReseauSocialGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    username: string
    url: string
    contactId: number | null
    _count: ReseauSocialCountAggregateOutputType | null
    _avg: ReseauSocialAvgAggregateOutputType | null
    _sum: ReseauSocialSumAggregateOutputType | null
    _min: ReseauSocialMinAggregateOutputType | null
    _max: ReseauSocialMaxAggregateOutputType | null
  }

  type GetReseauSocialGroupByPayload<T extends ReseauSocialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReseauSocialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReseauSocialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReseauSocialGroupByOutputType[P]>
            : GetScalarType<T[P], ReseauSocialGroupByOutputType[P]>
        }
      >
    >


  export type ReseauSocialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    username?: boolean
    url?: boolean
    contactId?: boolean
    contact?: boolean | ReseauSocial$contactArgs<ExtArgs>
  }, ExtArgs["result"]["reseauSocial"]>

  export type ReseauSocialSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    username?: boolean
    url?: boolean
    contactId?: boolean
  }

  export type ReseauSocialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ReseauSocial$contactArgs<ExtArgs>
  }


  export type $ReseauSocialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReseauSocial"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      username: string
      url: string
      contactId: number | null
    }, ExtArgs["result"]["reseauSocial"]>
    composites: {}
  }


  type ReseauSocialGetPayload<S extends boolean | null | undefined | ReseauSocialDefaultArgs> = $Result.GetResult<Prisma.$ReseauSocialPayload, S>

  type ReseauSocialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReseauSocialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReseauSocialCountAggregateInputType | true
    }

  export interface ReseauSocialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReseauSocial'], meta: { name: 'ReseauSocial' } }
    /**
     * Find zero or one ReseauSocial that matches the filter.
     * @param {ReseauSocialFindUniqueArgs} args - Arguments to find a ReseauSocial
     * @example
     * // Get one ReseauSocial
     * const reseauSocial = await prisma.reseauSocial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReseauSocialFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReseauSocialFindUniqueArgs<ExtArgs>>
    ): Prisma__ReseauSocialClient<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ReseauSocial that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReseauSocialFindUniqueOrThrowArgs} args - Arguments to find a ReseauSocial
     * @example
     * // Get one ReseauSocial
     * const reseauSocial = await prisma.reseauSocial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReseauSocialFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReseauSocialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReseauSocialClient<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ReseauSocial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReseauSocialFindFirstArgs} args - Arguments to find a ReseauSocial
     * @example
     * // Get one ReseauSocial
     * const reseauSocial = await prisma.reseauSocial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReseauSocialFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReseauSocialFindFirstArgs<ExtArgs>>
    ): Prisma__ReseauSocialClient<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ReseauSocial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReseauSocialFindFirstOrThrowArgs} args - Arguments to find a ReseauSocial
     * @example
     * // Get one ReseauSocial
     * const reseauSocial = await prisma.reseauSocial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReseauSocialFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReseauSocialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReseauSocialClient<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ReseauSocials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReseauSocialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReseauSocials
     * const reseauSocials = await prisma.reseauSocial.findMany()
     * 
     * // Get first 10 ReseauSocials
     * const reseauSocials = await prisma.reseauSocial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reseauSocialWithIdOnly = await prisma.reseauSocial.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReseauSocialFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReseauSocialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ReseauSocial.
     * @param {ReseauSocialCreateArgs} args - Arguments to create a ReseauSocial.
     * @example
     * // Create one ReseauSocial
     * const ReseauSocial = await prisma.reseauSocial.create({
     *   data: {
     *     // ... data to create a ReseauSocial
     *   }
     * })
     * 
    **/
    create<T extends ReseauSocialCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReseauSocialCreateArgs<ExtArgs>>
    ): Prisma__ReseauSocialClient<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ReseauSocials.
     *     @param {ReseauSocialCreateManyArgs} args - Arguments to create many ReseauSocials.
     *     @example
     *     // Create many ReseauSocials
     *     const reseauSocial = await prisma.reseauSocial.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReseauSocialCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReseauSocialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReseauSocial.
     * @param {ReseauSocialDeleteArgs} args - Arguments to delete one ReseauSocial.
     * @example
     * // Delete one ReseauSocial
     * const ReseauSocial = await prisma.reseauSocial.delete({
     *   where: {
     *     // ... filter to delete one ReseauSocial
     *   }
     * })
     * 
    **/
    delete<T extends ReseauSocialDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReseauSocialDeleteArgs<ExtArgs>>
    ): Prisma__ReseauSocialClient<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ReseauSocial.
     * @param {ReseauSocialUpdateArgs} args - Arguments to update one ReseauSocial.
     * @example
     * // Update one ReseauSocial
     * const reseauSocial = await prisma.reseauSocial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReseauSocialUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReseauSocialUpdateArgs<ExtArgs>>
    ): Prisma__ReseauSocialClient<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ReseauSocials.
     * @param {ReseauSocialDeleteManyArgs} args - Arguments to filter ReseauSocials to delete.
     * @example
     * // Delete a few ReseauSocials
     * const { count } = await prisma.reseauSocial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReseauSocialDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReseauSocialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReseauSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReseauSocialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReseauSocials
     * const reseauSocial = await prisma.reseauSocial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReseauSocialUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReseauSocialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReseauSocial.
     * @param {ReseauSocialUpsertArgs} args - Arguments to update or create a ReseauSocial.
     * @example
     * // Update or create a ReseauSocial
     * const reseauSocial = await prisma.reseauSocial.upsert({
     *   create: {
     *     // ... data to create a ReseauSocial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReseauSocial we want to update
     *   }
     * })
    **/
    upsert<T extends ReseauSocialUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReseauSocialUpsertArgs<ExtArgs>>
    ): Prisma__ReseauSocialClient<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ReseauSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReseauSocialCountArgs} args - Arguments to filter ReseauSocials to count.
     * @example
     * // Count the number of ReseauSocials
     * const count = await prisma.reseauSocial.count({
     *   where: {
     *     // ... the filter for the ReseauSocials we want to count
     *   }
     * })
    **/
    count<T extends ReseauSocialCountArgs>(
      args?: Subset<T, ReseauSocialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReseauSocialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReseauSocial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReseauSocialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReseauSocialAggregateArgs>(args: Subset<T, ReseauSocialAggregateArgs>): Prisma.PrismaPromise<GetReseauSocialAggregateType<T>>

    /**
     * Group by ReseauSocial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReseauSocialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReseauSocialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReseauSocialGroupByArgs['orderBy'] }
        : { orderBy?: ReseauSocialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReseauSocialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReseauSocialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReseauSocial model
   */
  readonly fields: ReseauSocialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReseauSocial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReseauSocialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contact<T extends ReseauSocial$contactArgs<ExtArgs> = {}>(args?: Subset<T, ReseauSocial$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ReseauSocial model
   */ 
  interface ReseauSocialFieldRefs {
    readonly id: FieldRef<"ReseauSocial", 'Int'>
    readonly createdAt: FieldRef<"ReseauSocial", 'DateTime'>
    readonly updatedAt: FieldRef<"ReseauSocial", 'DateTime'>
    readonly nom: FieldRef<"ReseauSocial", 'String'>
    readonly username: FieldRef<"ReseauSocial", 'String'>
    readonly url: FieldRef<"ReseauSocial", 'String'>
    readonly contactId: FieldRef<"ReseauSocial", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ReseauSocial findUnique
   */
  export type ReseauSocialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    /**
     * Filter, which ReseauSocial to fetch.
     */
    where: ReseauSocialWhereUniqueInput
  }


  /**
   * ReseauSocial findUniqueOrThrow
   */
  export type ReseauSocialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    /**
     * Filter, which ReseauSocial to fetch.
     */
    where: ReseauSocialWhereUniqueInput
  }


  /**
   * ReseauSocial findFirst
   */
  export type ReseauSocialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    /**
     * Filter, which ReseauSocial to fetch.
     */
    where?: ReseauSocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReseauSocials to fetch.
     */
    orderBy?: ReseauSocialOrderByWithRelationInput | ReseauSocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReseauSocials.
     */
    cursor?: ReseauSocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReseauSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReseauSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReseauSocials.
     */
    distinct?: ReseauSocialScalarFieldEnum | ReseauSocialScalarFieldEnum[]
  }


  /**
   * ReseauSocial findFirstOrThrow
   */
  export type ReseauSocialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    /**
     * Filter, which ReseauSocial to fetch.
     */
    where?: ReseauSocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReseauSocials to fetch.
     */
    orderBy?: ReseauSocialOrderByWithRelationInput | ReseauSocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReseauSocials.
     */
    cursor?: ReseauSocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReseauSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReseauSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReseauSocials.
     */
    distinct?: ReseauSocialScalarFieldEnum | ReseauSocialScalarFieldEnum[]
  }


  /**
   * ReseauSocial findMany
   */
  export type ReseauSocialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    /**
     * Filter, which ReseauSocials to fetch.
     */
    where?: ReseauSocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReseauSocials to fetch.
     */
    orderBy?: ReseauSocialOrderByWithRelationInput | ReseauSocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReseauSocials.
     */
    cursor?: ReseauSocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReseauSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReseauSocials.
     */
    skip?: number
    distinct?: ReseauSocialScalarFieldEnum | ReseauSocialScalarFieldEnum[]
  }


  /**
   * ReseauSocial create
   */
  export type ReseauSocialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    /**
     * The data needed to create a ReseauSocial.
     */
    data: XOR<ReseauSocialCreateInput, ReseauSocialUncheckedCreateInput>
  }


  /**
   * ReseauSocial createMany
   */
  export type ReseauSocialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReseauSocials.
     */
    data: ReseauSocialCreateManyInput | ReseauSocialCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ReseauSocial update
   */
  export type ReseauSocialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    /**
     * The data needed to update a ReseauSocial.
     */
    data: XOR<ReseauSocialUpdateInput, ReseauSocialUncheckedUpdateInput>
    /**
     * Choose, which ReseauSocial to update.
     */
    where: ReseauSocialWhereUniqueInput
  }


  /**
   * ReseauSocial updateMany
   */
  export type ReseauSocialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReseauSocials.
     */
    data: XOR<ReseauSocialUpdateManyMutationInput, ReseauSocialUncheckedUpdateManyInput>
    /**
     * Filter which ReseauSocials to update
     */
    where?: ReseauSocialWhereInput
  }


  /**
   * ReseauSocial upsert
   */
  export type ReseauSocialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    /**
     * The filter to search for the ReseauSocial to update in case it exists.
     */
    where: ReseauSocialWhereUniqueInput
    /**
     * In case the ReseauSocial found by the `where` argument doesn't exist, create a new ReseauSocial with this data.
     */
    create: XOR<ReseauSocialCreateInput, ReseauSocialUncheckedCreateInput>
    /**
     * In case the ReseauSocial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReseauSocialUpdateInput, ReseauSocialUncheckedUpdateInput>
  }


  /**
   * ReseauSocial delete
   */
  export type ReseauSocialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    /**
     * Filter which ReseauSocial to delete.
     */
    where: ReseauSocialWhereUniqueInput
  }


  /**
   * ReseauSocial deleteMany
   */
  export type ReseauSocialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReseauSocials to delete
     */
    where?: ReseauSocialWhereInput
  }


  /**
   * ReseauSocial.contact
   */
  export type ReseauSocial$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }


  /**
   * ReseauSocial without action
   */
  export type ReseauSocialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
  }



  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    telephone: string | null
    fix: string | null
    fax: string | null
    email: string | null
    siteWeb: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    telephone: string | null
    fix: string | null
    fax: string | null
    email: string | null
    siteWeb: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    telephone: number
    fix: number
    fax: number
    email: number
    siteWeb: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    telephone?: true
    fix?: true
    fax?: true
    email?: true
    siteWeb?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    telephone?: true
    fix?: true
    fax?: true
    email?: true
    siteWeb?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    telephone?: true
    fix?: true
    fax?: true
    email?: true
    siteWeb?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    telephone: string
    fix: string | null
    fax: string | null
    email: string
    siteWeb: string | null
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telephone?: boolean
    fix?: boolean
    fax?: boolean
    email?: boolean
    siteWeb?: boolean
    reseauxSociaux?: boolean | Contact$reseauxSociauxArgs<ExtArgs>
    utilisateurs?: boolean | Contact$utilisateursArgs<ExtArgs>
    etablissements?: boolean | Contact$etablissementsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telephone?: boolean
    fix?: boolean
    fax?: boolean
    email?: boolean
    siteWeb?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reseauxSociaux?: boolean | Contact$reseauxSociauxArgs<ExtArgs>
    utilisateurs?: boolean | Contact$utilisateursArgs<ExtArgs>
    etablissements?: boolean | Contact$etablissementsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      reseauxSociaux: Prisma.$ReseauSocialPayload<ExtArgs>[]
      utilisateurs: Prisma.$UtilisateurPayload<ExtArgs>[]
      etablissements: Prisma.$EtablissementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      telephone: string
      fix: string | null
      fax: string | null
      email: string
      siteWeb: string | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }


  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContactFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
    **/
    create<T extends ContactCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactCreateArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contacts.
     *     @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     *     @example
     *     // Create many Contacts
     *     const contact = await prisma.contact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContactCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
    **/
    delete<T extends ContactDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
    **/
    upsert<T extends ContactUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    reseauxSociaux<T extends Contact$reseauxSociauxArgs<ExtArgs> = {}>(args?: Subset<T, Contact$reseauxSociauxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReseauSocialPayload<ExtArgs>, T, 'findMany'> | Null>;

    utilisateurs<T extends Contact$utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, Contact$utilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findMany'> | Null>;

    etablissements<T extends Contact$etablissementsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$etablissementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'Int'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly telephone: FieldRef<"Contact", 'String'>
    readonly fix: FieldRef<"Contact", 'String'>
    readonly fax: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly siteWeb: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }


  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }


  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }


  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }


  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }


  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }


  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }


  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }


  /**
   * Contact.reseauxSociaux
   */
  export type Contact$reseauxSociauxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReseauSocial
     */
    select?: ReseauSocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReseauSocialInclude<ExtArgs> | null
    where?: ReseauSocialWhereInput
    orderBy?: ReseauSocialOrderByWithRelationInput | ReseauSocialOrderByWithRelationInput[]
    cursor?: ReseauSocialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReseauSocialScalarFieldEnum | ReseauSocialScalarFieldEnum[]
  }


  /**
   * Contact.utilisateurs
   */
  export type Contact$utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    where?: UtilisateurWhereInput
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    cursor?: UtilisateurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Contact.etablissements
   */
  export type Contact$etablissementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    where?: EtablissementWhereInput
    orderBy?: EtablissementOrderByWithRelationInput | EtablissementOrderByWithRelationInput[]
    cursor?: EtablissementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtablissementScalarFieldEnum | EtablissementScalarFieldEnum[]
  }


  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
  }



  /**
   * Model Etudiant
   */

  export type AggregateEtudiant = {
    _count: EtudiantCountAggregateOutputType | null
    _avg: EtudiantAvgAggregateOutputType | null
    _sum: EtudiantSumAggregateOutputType | null
    _min: EtudiantMinAggregateOutputType | null
    _max: EtudiantMaxAggregateOutputType | null
  }

  export type EtudiantAvgAggregateOutputType = {
    id: number | null
    anneeBaccaleaureat: number | null
    profileId: number | null
    feuillePresencesId: number | null
  }

  export type EtudiantSumAggregateOutputType = {
    id: number | null
    anneeBaccaleaureat: number | null
    profileId: number | null
    feuillePresencesId: number | null
  }

  export type EtudiantMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
    ine: string | null
    baccaleaureat: string | null
    anneeBaccaleaureat: number | null
    profileId: number | null
    feuillePresencesId: number | null
  }

  export type EtudiantMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
    ine: string | null
    baccaleaureat: string | null
    anneeBaccaleaureat: number | null
    profileId: number | null
    feuillePresencesId: number | null
  }

  export type EtudiantCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    slug: number
    ine: number
    baccaleaureat: number
    anneeBaccaleaureat: number
    profileId: number
    feuillePresencesId: number
    _all: number
  }


  export type EtudiantAvgAggregateInputType = {
    id?: true
    anneeBaccaleaureat?: true
    profileId?: true
    feuillePresencesId?: true
  }

  export type EtudiantSumAggregateInputType = {
    id?: true
    anneeBaccaleaureat?: true
    profileId?: true
    feuillePresencesId?: true
  }

  export type EtudiantMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    ine?: true
    baccaleaureat?: true
    anneeBaccaleaureat?: true
    profileId?: true
    feuillePresencesId?: true
  }

  export type EtudiantMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    ine?: true
    baccaleaureat?: true
    anneeBaccaleaureat?: true
    profileId?: true
    feuillePresencesId?: true
  }

  export type EtudiantCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    ine?: true
    baccaleaureat?: true
    anneeBaccaleaureat?: true
    profileId?: true
    feuillePresencesId?: true
    _all?: true
  }

  export type EtudiantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etudiant to aggregate.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Etudiants
    **/
    _count?: true | EtudiantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtudiantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtudiantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtudiantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtudiantMaxAggregateInputType
  }

  export type GetEtudiantAggregateType<T extends EtudiantAggregateArgs> = {
        [P in keyof T & keyof AggregateEtudiant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtudiant[P]>
      : GetScalarType<T[P], AggregateEtudiant[P]>
  }




  export type EtudiantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtudiantWhereInput
    orderBy?: EtudiantOrderByWithAggregationInput | EtudiantOrderByWithAggregationInput[]
    by: EtudiantScalarFieldEnum[] | EtudiantScalarFieldEnum
    having?: EtudiantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtudiantCountAggregateInputType | true
    _avg?: EtudiantAvgAggregateInputType
    _sum?: EtudiantSumAggregateInputType
    _min?: EtudiantMinAggregateInputType
    _max?: EtudiantMaxAggregateInputType
  }

  export type EtudiantGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    slug: string | null
    ine: string
    baccaleaureat: string | null
    anneeBaccaleaureat: number | null
    profileId: number
    feuillePresencesId: number | null
    _count: EtudiantCountAggregateOutputType | null
    _avg: EtudiantAvgAggregateOutputType | null
    _sum: EtudiantSumAggregateOutputType | null
    _min: EtudiantMinAggregateOutputType | null
    _max: EtudiantMaxAggregateOutputType | null
  }

  type GetEtudiantGroupByPayload<T extends EtudiantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtudiantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtudiantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtudiantGroupByOutputType[P]>
            : GetScalarType<T[P], EtudiantGroupByOutputType[P]>
        }
      >
    >


  export type EtudiantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    ine?: boolean
    baccaleaureat?: boolean
    anneeBaccaleaureat?: boolean
    profileId?: boolean
    feuillePresencesId?: boolean
    profile?: boolean | UtilisateurDefaultArgs<ExtArgs>
    inscriptions?: boolean | Etudiant$inscriptionsArgs<ExtArgs>
    notes?: boolean | Etudiant$notesArgs<ExtArgs>
    feuillePresences?: boolean | Etudiant$feuillePresencesArgs<ExtArgs>
    Paiement?: boolean | Etudiant$PaiementArgs<ExtArgs>
    _count?: boolean | EtudiantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etudiant"]>

  export type EtudiantSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    ine?: boolean
    baccaleaureat?: boolean
    anneeBaccaleaureat?: boolean
    profileId?: boolean
    feuillePresencesId?: boolean
  }

  export type EtudiantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UtilisateurDefaultArgs<ExtArgs>
    inscriptions?: boolean | Etudiant$inscriptionsArgs<ExtArgs>
    notes?: boolean | Etudiant$notesArgs<ExtArgs>
    feuillePresences?: boolean | Etudiant$feuillePresencesArgs<ExtArgs>
    Paiement?: boolean | Etudiant$PaiementArgs<ExtArgs>
    _count?: boolean | EtudiantCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EtudiantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Etudiant"
    objects: {
      profile: Prisma.$UtilisateurPayload<ExtArgs>
      inscriptions: Prisma.$InscriptionPayload<ExtArgs>[]
      notes: Prisma.$NoteEtudiantPayload<ExtArgs>[]
      feuillePresences: Prisma.$FeuillePresencePayload<ExtArgs>[]
      Paiement: Prisma.$PaiementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      slug: string | null
      ine: string
      baccaleaureat: string | null
      anneeBaccaleaureat: number | null
      profileId: number
      feuillePresencesId: number | null
    }, ExtArgs["result"]["etudiant"]>
    composites: {}
  }


  type EtudiantGetPayload<S extends boolean | null | undefined | EtudiantDefaultArgs> = $Result.GetResult<Prisma.$EtudiantPayload, S>

  type EtudiantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EtudiantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EtudiantCountAggregateInputType | true
    }

  export interface EtudiantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Etudiant'], meta: { name: 'Etudiant' } }
    /**
     * Find zero or one Etudiant that matches the filter.
     * @param {EtudiantFindUniqueArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EtudiantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantFindUniqueArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Etudiant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EtudiantFindUniqueOrThrowArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EtudiantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Etudiant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantFindFirstArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EtudiantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantFindFirstArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Etudiant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantFindFirstOrThrowArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EtudiantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Etudiants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etudiants
     * const etudiants = await prisma.etudiant.findMany()
     * 
     * // Get first 10 Etudiants
     * const etudiants = await prisma.etudiant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etudiantWithIdOnly = await prisma.etudiant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EtudiantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Etudiant.
     * @param {EtudiantCreateArgs} args - Arguments to create a Etudiant.
     * @example
     * // Create one Etudiant
     * const Etudiant = await prisma.etudiant.create({
     *   data: {
     *     // ... data to create a Etudiant
     *   }
     * })
     * 
    **/
    create<T extends EtudiantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantCreateArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Etudiants.
     *     @param {EtudiantCreateManyArgs} args - Arguments to create many Etudiants.
     *     @example
     *     // Create many Etudiants
     *     const etudiant = await prisma.etudiant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EtudiantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Etudiant.
     * @param {EtudiantDeleteArgs} args - Arguments to delete one Etudiant.
     * @example
     * // Delete one Etudiant
     * const Etudiant = await prisma.etudiant.delete({
     *   where: {
     *     // ... filter to delete one Etudiant
     *   }
     * })
     * 
    **/
    delete<T extends EtudiantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantDeleteArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Etudiant.
     * @param {EtudiantUpdateArgs} args - Arguments to update one Etudiant.
     * @example
     * // Update one Etudiant
     * const etudiant = await prisma.etudiant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EtudiantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantUpdateArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Etudiants.
     * @param {EtudiantDeleteManyArgs} args - Arguments to filter Etudiants to delete.
     * @example
     * // Delete a few Etudiants
     * const { count } = await prisma.etudiant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EtudiantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etudiants
     * const etudiant = await prisma.etudiant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EtudiantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Etudiant.
     * @param {EtudiantUpsertArgs} args - Arguments to update or create a Etudiant.
     * @example
     * // Update or create a Etudiant
     * const etudiant = await prisma.etudiant.upsert({
     *   create: {
     *     // ... data to create a Etudiant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Etudiant we want to update
     *   }
     * })
    **/
    upsert<T extends EtudiantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantUpsertArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Etudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantCountArgs} args - Arguments to filter Etudiants to count.
     * @example
     * // Count the number of Etudiants
     * const count = await prisma.etudiant.count({
     *   where: {
     *     // ... the filter for the Etudiants we want to count
     *   }
     * })
    **/
    count<T extends EtudiantCountArgs>(
      args?: Subset<T, EtudiantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtudiantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtudiantAggregateArgs>(args: Subset<T, EtudiantAggregateArgs>): Prisma.PrismaPromise<GetEtudiantAggregateType<T>>

    /**
     * Group by Etudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtudiantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtudiantGroupByArgs['orderBy'] }
        : { orderBy?: EtudiantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtudiantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtudiantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Etudiant model
   */
  readonly fields: EtudiantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Etudiant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtudiantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    inscriptions<T extends Etudiant$inscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$inscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends Etudiant$notesArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'findMany'> | Null>;

    feuillePresences<T extends Etudiant$feuillePresencesArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$feuillePresencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'findMany'> | Null>;

    Paiement<T extends Etudiant$PaiementArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$PaiementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Etudiant model
   */ 
  interface EtudiantFieldRefs {
    readonly id: FieldRef<"Etudiant", 'Int'>
    readonly createdAt: FieldRef<"Etudiant", 'DateTime'>
    readonly updatedAt: FieldRef<"Etudiant", 'DateTime'>
    readonly slug: FieldRef<"Etudiant", 'String'>
    readonly ine: FieldRef<"Etudiant", 'String'>
    readonly baccaleaureat: FieldRef<"Etudiant", 'String'>
    readonly anneeBaccaleaureat: FieldRef<"Etudiant", 'Int'>
    readonly profileId: FieldRef<"Etudiant", 'Int'>
    readonly feuillePresencesId: FieldRef<"Etudiant", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Etudiant findUnique
   */
  export type EtudiantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where: EtudiantWhereUniqueInput
  }


  /**
   * Etudiant findUniqueOrThrow
   */
  export type EtudiantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where: EtudiantWhereUniqueInput
  }


  /**
   * Etudiant findFirst
   */
  export type EtudiantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etudiants.
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etudiants.
     */
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }


  /**
   * Etudiant findFirstOrThrow
   */
  export type EtudiantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etudiants.
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etudiants.
     */
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }


  /**
   * Etudiant findMany
   */
  export type EtudiantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiants to fetch.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Etudiants.
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }


  /**
   * Etudiant create
   */
  export type EtudiantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * The data needed to create a Etudiant.
     */
    data: XOR<EtudiantCreateInput, EtudiantUncheckedCreateInput>
  }


  /**
   * Etudiant createMany
   */
  export type EtudiantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Etudiants.
     */
    data: EtudiantCreateManyInput | EtudiantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Etudiant update
   */
  export type EtudiantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * The data needed to update a Etudiant.
     */
    data: XOR<EtudiantUpdateInput, EtudiantUncheckedUpdateInput>
    /**
     * Choose, which Etudiant to update.
     */
    where: EtudiantWhereUniqueInput
  }


  /**
   * Etudiant updateMany
   */
  export type EtudiantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Etudiants.
     */
    data: XOR<EtudiantUpdateManyMutationInput, EtudiantUncheckedUpdateManyInput>
    /**
     * Filter which Etudiants to update
     */
    where?: EtudiantWhereInput
  }


  /**
   * Etudiant upsert
   */
  export type EtudiantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * The filter to search for the Etudiant to update in case it exists.
     */
    where: EtudiantWhereUniqueInput
    /**
     * In case the Etudiant found by the `where` argument doesn't exist, create a new Etudiant with this data.
     */
    create: XOR<EtudiantCreateInput, EtudiantUncheckedCreateInput>
    /**
     * In case the Etudiant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtudiantUpdateInput, EtudiantUncheckedUpdateInput>
  }


  /**
   * Etudiant delete
   */
  export type EtudiantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter which Etudiant to delete.
     */
    where: EtudiantWhereUniqueInput
  }


  /**
   * Etudiant deleteMany
   */
  export type EtudiantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etudiants to delete
     */
    where?: EtudiantWhereInput
  }


  /**
   * Etudiant.inscriptions
   */
  export type Etudiant$inscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    where?: InscriptionWhereInput
    orderBy?: InscriptionOrderByWithRelationInput | InscriptionOrderByWithRelationInput[]
    cursor?: InscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }


  /**
   * Etudiant.notes
   */
  export type Etudiant$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    where?: NoteEtudiantWhereInput
    orderBy?: NoteEtudiantOrderByWithRelationInput | NoteEtudiantOrderByWithRelationInput[]
    cursor?: NoteEtudiantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteEtudiantScalarFieldEnum | NoteEtudiantScalarFieldEnum[]
  }


  /**
   * Etudiant.feuillePresences
   */
  export type Etudiant$feuillePresencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    where?: FeuillePresenceWhereInput
    orderBy?: FeuillePresenceOrderByWithRelationInput | FeuillePresenceOrderByWithRelationInput[]
    cursor?: FeuillePresenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeuillePresenceScalarFieldEnum | FeuillePresenceScalarFieldEnum[]
  }


  /**
   * Etudiant.Paiement
   */
  export type Etudiant$PaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }


  /**
   * Etudiant without action
   */
  export type EtudiantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
  }



  /**
   * Model Professeur
   */

  export type AggregateProfesseur = {
    _count: ProfesseurCountAggregateOutputType | null
    _avg: ProfesseurAvgAggregateOutputType | null
    _sum: ProfesseurSumAggregateOutputType | null
    _min: ProfesseurMinAggregateOutputType | null
    _max: ProfesseurMaxAggregateOutputType | null
  }

  export type ProfesseurAvgAggregateOutputType = {
    id: number | null
    profileId: number | null
  }

  export type ProfesseurSumAggregateOutputType = {
    id: number | null
    profileId: number | null
  }

  export type ProfesseurMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: number | null
  }

  export type ProfesseurMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: number | null
  }

  export type ProfesseurCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    profileId: number
    _all: number
  }


  export type ProfesseurAvgAggregateInputType = {
    id?: true
    profileId?: true
  }

  export type ProfesseurSumAggregateInputType = {
    id?: true
    profileId?: true
  }

  export type ProfesseurMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type ProfesseurMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type ProfesseurCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    _all?: true
  }

  export type ProfesseurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Professeur to aggregate.
     */
    where?: ProfesseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Professeurs to fetch.
     */
    orderBy?: ProfesseurOrderByWithRelationInput | ProfesseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfesseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Professeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Professeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Professeurs
    **/
    _count?: true | ProfesseurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfesseurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfesseurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfesseurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfesseurMaxAggregateInputType
  }

  export type GetProfesseurAggregateType<T extends ProfesseurAggregateArgs> = {
        [P in keyof T & keyof AggregateProfesseur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfesseur[P]>
      : GetScalarType<T[P], AggregateProfesseur[P]>
  }




  export type ProfesseurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfesseurWhereInput
    orderBy?: ProfesseurOrderByWithAggregationInput | ProfesseurOrderByWithAggregationInput[]
    by: ProfesseurScalarFieldEnum[] | ProfesseurScalarFieldEnum
    having?: ProfesseurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfesseurCountAggregateInputType | true
    _avg?: ProfesseurAvgAggregateInputType
    _sum?: ProfesseurSumAggregateInputType
    _min?: ProfesseurMinAggregateInputType
    _max?: ProfesseurMaxAggregateInputType
  }

  export type ProfesseurGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    profileId: number
    _count: ProfesseurCountAggregateOutputType | null
    _avg: ProfesseurAvgAggregateOutputType | null
    _sum: ProfesseurSumAggregateOutputType | null
    _min: ProfesseurMinAggregateOutputType | null
    _max: ProfesseurMaxAggregateOutputType | null
  }

  type GetProfesseurGroupByPayload<T extends ProfesseurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfesseurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfesseurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfesseurGroupByOutputType[P]>
            : GetScalarType<T[P], ProfesseurGroupByOutputType[P]>
        }
      >
    >


  export type ProfesseurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UtilisateurDefaultArgs<ExtArgs>
    cours?: boolean | Professeur$coursArgs<ExtArgs>
    EmploiDuTemps?: boolean | Professeur$EmploiDuTempsArgs<ExtArgs>
    _count?: boolean | ProfesseurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["professeur"]>

  export type ProfesseurSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
  }

  export type ProfesseurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UtilisateurDefaultArgs<ExtArgs>
    cours?: boolean | Professeur$coursArgs<ExtArgs>
    EmploiDuTemps?: boolean | Professeur$EmploiDuTempsArgs<ExtArgs>
    _count?: boolean | ProfesseurCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProfesseurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Professeur"
    objects: {
      profile: Prisma.$UtilisateurPayload<ExtArgs>
      cours: Prisma.$CoursPayload<ExtArgs>[]
      EmploiDuTemps: Prisma.$EmploiDuTempsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      profileId: number
    }, ExtArgs["result"]["professeur"]>
    composites: {}
  }


  type ProfesseurGetPayload<S extends boolean | null | undefined | ProfesseurDefaultArgs> = $Result.GetResult<Prisma.$ProfesseurPayload, S>

  type ProfesseurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfesseurFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfesseurCountAggregateInputType | true
    }

  export interface ProfesseurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Professeur'], meta: { name: 'Professeur' } }
    /**
     * Find zero or one Professeur that matches the filter.
     * @param {ProfesseurFindUniqueArgs} args - Arguments to find a Professeur
     * @example
     * // Get one Professeur
     * const professeur = await prisma.professeur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfesseurFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurFindUniqueArgs<ExtArgs>>
    ): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Professeur that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProfesseurFindUniqueOrThrowArgs} args - Arguments to find a Professeur
     * @example
     * // Get one Professeur
     * const professeur = await prisma.professeur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfesseurFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Professeur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurFindFirstArgs} args - Arguments to find a Professeur
     * @example
     * // Get one Professeur
     * const professeur = await prisma.professeur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfesseurFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurFindFirstArgs<ExtArgs>>
    ): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Professeur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurFindFirstOrThrowArgs} args - Arguments to find a Professeur
     * @example
     * // Get one Professeur
     * const professeur = await prisma.professeur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfesseurFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Professeurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Professeurs
     * const professeurs = await prisma.professeur.findMany()
     * 
     * // Get first 10 Professeurs
     * const professeurs = await prisma.professeur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const professeurWithIdOnly = await prisma.professeur.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfesseurFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Professeur.
     * @param {ProfesseurCreateArgs} args - Arguments to create a Professeur.
     * @example
     * // Create one Professeur
     * const Professeur = await prisma.professeur.create({
     *   data: {
     *     // ... data to create a Professeur
     *   }
     * })
     * 
    **/
    create<T extends ProfesseurCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurCreateArgs<ExtArgs>>
    ): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Professeurs.
     *     @param {ProfesseurCreateManyArgs} args - Arguments to create many Professeurs.
     *     @example
     *     // Create many Professeurs
     *     const professeur = await prisma.professeur.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfesseurCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Professeur.
     * @param {ProfesseurDeleteArgs} args - Arguments to delete one Professeur.
     * @example
     * // Delete one Professeur
     * const Professeur = await prisma.professeur.delete({
     *   where: {
     *     // ... filter to delete one Professeur
     *   }
     * })
     * 
    **/
    delete<T extends ProfesseurDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurDeleteArgs<ExtArgs>>
    ): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Professeur.
     * @param {ProfesseurUpdateArgs} args - Arguments to update one Professeur.
     * @example
     * // Update one Professeur
     * const professeur = await prisma.professeur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfesseurUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurUpdateArgs<ExtArgs>>
    ): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Professeurs.
     * @param {ProfesseurDeleteManyArgs} args - Arguments to filter Professeurs to delete.
     * @example
     * // Delete a few Professeurs
     * const { count } = await prisma.professeur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfesseurDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Professeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Professeurs
     * const professeur = await prisma.professeur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfesseurUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Professeur.
     * @param {ProfesseurUpsertArgs} args - Arguments to update or create a Professeur.
     * @example
     * // Update or create a Professeur
     * const professeur = await prisma.professeur.upsert({
     *   create: {
     *     // ... data to create a Professeur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Professeur we want to update
     *   }
     * })
    **/
    upsert<T extends ProfesseurUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurUpsertArgs<ExtArgs>>
    ): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Professeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurCountArgs} args - Arguments to filter Professeurs to count.
     * @example
     * // Count the number of Professeurs
     * const count = await prisma.professeur.count({
     *   where: {
     *     // ... the filter for the Professeurs we want to count
     *   }
     * })
    **/
    count<T extends ProfesseurCountArgs>(
      args?: Subset<T, ProfesseurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfesseurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Professeur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfesseurAggregateArgs>(args: Subset<T, ProfesseurAggregateArgs>): Prisma.PrismaPromise<GetProfesseurAggregateType<T>>

    /**
     * Group by Professeur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfesseurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfesseurGroupByArgs['orderBy'] }
        : { orderBy?: ProfesseurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfesseurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfesseurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Professeur model
   */
  readonly fields: ProfesseurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Professeur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfesseurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cours<T extends Professeur$coursArgs<ExtArgs> = {}>(args?: Subset<T, Professeur$coursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findMany'> | Null>;

    EmploiDuTemps<T extends Professeur$EmploiDuTempsArgs<ExtArgs> = {}>(args?: Subset<T, Professeur$EmploiDuTempsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Professeur model
   */ 
  interface ProfesseurFieldRefs {
    readonly id: FieldRef<"Professeur", 'Int'>
    readonly createdAt: FieldRef<"Professeur", 'DateTime'>
    readonly updatedAt: FieldRef<"Professeur", 'DateTime'>
    readonly profileId: FieldRef<"Professeur", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Professeur findUnique
   */
  export type ProfesseurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    /**
     * Filter, which Professeur to fetch.
     */
    where: ProfesseurWhereUniqueInput
  }


  /**
   * Professeur findUniqueOrThrow
   */
  export type ProfesseurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    /**
     * Filter, which Professeur to fetch.
     */
    where: ProfesseurWhereUniqueInput
  }


  /**
   * Professeur findFirst
   */
  export type ProfesseurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    /**
     * Filter, which Professeur to fetch.
     */
    where?: ProfesseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Professeurs to fetch.
     */
    orderBy?: ProfesseurOrderByWithRelationInput | ProfesseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Professeurs.
     */
    cursor?: ProfesseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Professeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Professeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Professeurs.
     */
    distinct?: ProfesseurScalarFieldEnum | ProfesseurScalarFieldEnum[]
  }


  /**
   * Professeur findFirstOrThrow
   */
  export type ProfesseurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    /**
     * Filter, which Professeur to fetch.
     */
    where?: ProfesseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Professeurs to fetch.
     */
    orderBy?: ProfesseurOrderByWithRelationInput | ProfesseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Professeurs.
     */
    cursor?: ProfesseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Professeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Professeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Professeurs.
     */
    distinct?: ProfesseurScalarFieldEnum | ProfesseurScalarFieldEnum[]
  }


  /**
   * Professeur findMany
   */
  export type ProfesseurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    /**
     * Filter, which Professeurs to fetch.
     */
    where?: ProfesseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Professeurs to fetch.
     */
    orderBy?: ProfesseurOrderByWithRelationInput | ProfesseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Professeurs.
     */
    cursor?: ProfesseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Professeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Professeurs.
     */
    skip?: number
    distinct?: ProfesseurScalarFieldEnum | ProfesseurScalarFieldEnum[]
  }


  /**
   * Professeur create
   */
  export type ProfesseurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    /**
     * The data needed to create a Professeur.
     */
    data: XOR<ProfesseurCreateInput, ProfesseurUncheckedCreateInput>
  }


  /**
   * Professeur createMany
   */
  export type ProfesseurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Professeurs.
     */
    data: ProfesseurCreateManyInput | ProfesseurCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Professeur update
   */
  export type ProfesseurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    /**
     * The data needed to update a Professeur.
     */
    data: XOR<ProfesseurUpdateInput, ProfesseurUncheckedUpdateInput>
    /**
     * Choose, which Professeur to update.
     */
    where: ProfesseurWhereUniqueInput
  }


  /**
   * Professeur updateMany
   */
  export type ProfesseurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Professeurs.
     */
    data: XOR<ProfesseurUpdateManyMutationInput, ProfesseurUncheckedUpdateManyInput>
    /**
     * Filter which Professeurs to update
     */
    where?: ProfesseurWhereInput
  }


  /**
   * Professeur upsert
   */
  export type ProfesseurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    /**
     * The filter to search for the Professeur to update in case it exists.
     */
    where: ProfesseurWhereUniqueInput
    /**
     * In case the Professeur found by the `where` argument doesn't exist, create a new Professeur with this data.
     */
    create: XOR<ProfesseurCreateInput, ProfesseurUncheckedCreateInput>
    /**
     * In case the Professeur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfesseurUpdateInput, ProfesseurUncheckedUpdateInput>
  }


  /**
   * Professeur delete
   */
  export type ProfesseurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    /**
     * Filter which Professeur to delete.
     */
    where: ProfesseurWhereUniqueInput
  }


  /**
   * Professeur deleteMany
   */
  export type ProfesseurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Professeurs to delete
     */
    where?: ProfesseurWhereInput
  }


  /**
   * Professeur.cours
   */
  export type Professeur$coursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    where?: CoursWhereInput
    orderBy?: CoursOrderByWithRelationInput | CoursOrderByWithRelationInput[]
    cursor?: CoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursScalarFieldEnum | CoursScalarFieldEnum[]
  }


  /**
   * Professeur.EmploiDuTemps
   */
  export type Professeur$EmploiDuTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    where?: EmploiDuTempsWhereInput
    orderBy?: EmploiDuTempsOrderByWithRelationInput | EmploiDuTempsOrderByWithRelationInput[]
    cursor?: EmploiDuTempsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploiDuTempsScalarFieldEnum | EmploiDuTempsScalarFieldEnum[]
  }


  /**
   * Professeur without action
   */
  export type ProfesseurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
  }



  /**
   * Model Inscription
   */

  export type AggregateInscription = {
    _count: InscriptionCountAggregateOutputType | null
    _avg: InscriptionAvgAggregateOutputType | null
    _sum: InscriptionSumAggregateOutputType | null
    _min: InscriptionMinAggregateOutputType | null
    _max: InscriptionMaxAggregateOutputType | null
  }

  export type InscriptionAvgAggregateOutputType = {
    id: number | null
    diplomeId: number | null
    etudiantId: number | null
    classeId: number | null
  }

  export type InscriptionSumAggregateOutputType = {
    id: number | null
    diplomeId: number | null
    etudiantId: number | null
    classeId: number | null
  }

  export type InscriptionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    reference: string | null
    premiereInscription: boolean | null
    dernierDiplome: string | null
    autreEtablissement: string | null
    activiteProfessionnel: string | null
    niveau: string | null
    statut: string | null
    diplomeId: number | null
    etudiantId: number | null
    classeId: number | null
  }

  export type InscriptionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    reference: string | null
    premiereInscription: boolean | null
    dernierDiplome: string | null
    autreEtablissement: string | null
    activiteProfessionnel: string | null
    niveau: string | null
    statut: string | null
    diplomeId: number | null
    etudiantId: number | null
    classeId: number | null
  }

  export type InscriptionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    reference: number
    premiereInscription: number
    dernierDiplome: number
    autreEtablissement: number
    activiteProfessionnel: number
    niveau: number
    statut: number
    diplomeId: number
    etudiantId: number
    classeId: number
    _all: number
  }


  export type InscriptionAvgAggregateInputType = {
    id?: true
    diplomeId?: true
    etudiantId?: true
    classeId?: true
  }

  export type InscriptionSumAggregateInputType = {
    id?: true
    diplomeId?: true
    etudiantId?: true
    classeId?: true
  }

  export type InscriptionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    reference?: true
    premiereInscription?: true
    dernierDiplome?: true
    autreEtablissement?: true
    activiteProfessionnel?: true
    niveau?: true
    statut?: true
    diplomeId?: true
    etudiantId?: true
    classeId?: true
  }

  export type InscriptionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    reference?: true
    premiereInscription?: true
    dernierDiplome?: true
    autreEtablissement?: true
    activiteProfessionnel?: true
    niveau?: true
    statut?: true
    diplomeId?: true
    etudiantId?: true
    classeId?: true
  }

  export type InscriptionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    reference?: true
    premiereInscription?: true
    dernierDiplome?: true
    autreEtablissement?: true
    activiteProfessionnel?: true
    niveau?: true
    statut?: true
    diplomeId?: true
    etudiantId?: true
    classeId?: true
    _all?: true
  }

  export type InscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inscription to aggregate.
     */
    where?: InscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscriptions to fetch.
     */
    orderBy?: InscriptionOrderByWithRelationInput | InscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inscriptions
    **/
    _count?: true | InscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InscriptionMaxAggregateInputType
  }

  export type GetInscriptionAggregateType<T extends InscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateInscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInscription[P]>
      : GetScalarType<T[P], AggregateInscription[P]>
  }




  export type InscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscriptionWhereInput
    orderBy?: InscriptionOrderByWithAggregationInput | InscriptionOrderByWithAggregationInput[]
    by: InscriptionScalarFieldEnum[] | InscriptionScalarFieldEnum
    having?: InscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InscriptionCountAggregateInputType | true
    _avg?: InscriptionAvgAggregateInputType
    _sum?: InscriptionSumAggregateInputType
    _min?: InscriptionMinAggregateInputType
    _max?: InscriptionMaxAggregateInputType
  }

  export type InscriptionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    reference: string
    premiereInscription: boolean
    dernierDiplome: string | null
    autreEtablissement: string | null
    activiteProfessionnel: string | null
    niveau: string | null
    statut: string | null
    diplomeId: number
    etudiantId: number
    classeId: number
    _count: InscriptionCountAggregateOutputType | null
    _avg: InscriptionAvgAggregateOutputType | null
    _sum: InscriptionSumAggregateOutputType | null
    _min: InscriptionMinAggregateOutputType | null
    _max: InscriptionMaxAggregateOutputType | null
  }

  type GetInscriptionGroupByPayload<T extends InscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], InscriptionGroupByOutputType[P]>
        }
      >
    >


  export type InscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reference?: boolean
    premiereInscription?: boolean
    dernierDiplome?: boolean
    autreEtablissement?: boolean
    activiteProfessionnel?: boolean
    niveau?: boolean
    statut?: boolean
    diplomeId?: boolean
    etudiantId?: boolean
    classeId?: boolean
    diplome?: boolean | DiplomeDefaultArgs<ExtArgs>
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscription"]>

  export type InscriptionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reference?: boolean
    premiereInscription?: boolean
    dernierDiplome?: boolean
    autreEtablissement?: boolean
    activiteProfessionnel?: boolean
    niveau?: boolean
    statut?: boolean
    diplomeId?: boolean
    etudiantId?: boolean
    classeId?: boolean
  }

  export type InscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diplome?: boolean | DiplomeDefaultArgs<ExtArgs>
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
  }


  export type $InscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inscription"
    objects: {
      diplome: Prisma.$DiplomePayload<ExtArgs>
      etudiant: Prisma.$EtudiantPayload<ExtArgs>
      classe: Prisma.$ClassePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      reference: string
      premiereInscription: boolean
      dernierDiplome: string | null
      autreEtablissement: string | null
      activiteProfessionnel: string | null
      niveau: string | null
      statut: string | null
      diplomeId: number
      etudiantId: number
      classeId: number
    }, ExtArgs["result"]["inscription"]>
    composites: {}
  }


  type InscriptionGetPayload<S extends boolean | null | undefined | InscriptionDefaultArgs> = $Result.GetResult<Prisma.$InscriptionPayload, S>

  type InscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InscriptionCountAggregateInputType | true
    }

  export interface InscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inscription'], meta: { name: 'Inscription' } }
    /**
     * Find zero or one Inscription that matches the filter.
     * @param {InscriptionFindUniqueArgs} args - Arguments to find a Inscription
     * @example
     * // Get one Inscription
     * const inscription = await prisma.inscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InscriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__InscriptionClient<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InscriptionFindUniqueOrThrowArgs} args - Arguments to find a Inscription
     * @example
     * // Get one Inscription
     * const inscription = await prisma.inscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InscriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InscriptionClient<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFindFirstArgs} args - Arguments to find a Inscription
     * @example
     * // Get one Inscription
     * const inscription = await prisma.inscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InscriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__InscriptionClient<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFindFirstOrThrowArgs} args - Arguments to find a Inscription
     * @example
     * // Get one Inscription
     * const inscription = await prisma.inscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InscriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InscriptionClient<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inscriptions
     * const inscriptions = await prisma.inscription.findMany()
     * 
     * // Get first 10 Inscriptions
     * const inscriptions = await prisma.inscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inscriptionWithIdOnly = await prisma.inscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InscriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inscription.
     * @param {InscriptionCreateArgs} args - Arguments to create a Inscription.
     * @example
     * // Create one Inscription
     * const Inscription = await prisma.inscription.create({
     *   data: {
     *     // ... data to create a Inscription
     *   }
     * })
     * 
    **/
    create<T extends InscriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InscriptionCreateArgs<ExtArgs>>
    ): Prisma__InscriptionClient<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inscriptions.
     *     @param {InscriptionCreateManyArgs} args - Arguments to create many Inscriptions.
     *     @example
     *     // Create many Inscriptions
     *     const inscription = await prisma.inscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InscriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inscription.
     * @param {InscriptionDeleteArgs} args - Arguments to delete one Inscription.
     * @example
     * // Delete one Inscription
     * const Inscription = await prisma.inscription.delete({
     *   where: {
     *     // ... filter to delete one Inscription
     *   }
     * })
     * 
    **/
    delete<T extends InscriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InscriptionDeleteArgs<ExtArgs>>
    ): Prisma__InscriptionClient<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inscription.
     * @param {InscriptionUpdateArgs} args - Arguments to update one Inscription.
     * @example
     * // Update one Inscription
     * const inscription = await prisma.inscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InscriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InscriptionUpdateArgs<ExtArgs>>
    ): Prisma__InscriptionClient<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inscriptions.
     * @param {InscriptionDeleteManyArgs} args - Arguments to filter Inscriptions to delete.
     * @example
     * // Delete a few Inscriptions
     * const { count } = await prisma.inscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InscriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inscriptions
     * const inscription = await prisma.inscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InscriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inscription.
     * @param {InscriptionUpsertArgs} args - Arguments to update or create a Inscription.
     * @example
     * // Update or create a Inscription
     * const inscription = await prisma.inscription.upsert({
     *   create: {
     *     // ... data to create a Inscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inscription we want to update
     *   }
     * })
    **/
    upsert<T extends InscriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InscriptionUpsertArgs<ExtArgs>>
    ): Prisma__InscriptionClient<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionCountArgs} args - Arguments to filter Inscriptions to count.
     * @example
     * // Count the number of Inscriptions
     * const count = await prisma.inscription.count({
     *   where: {
     *     // ... the filter for the Inscriptions we want to count
     *   }
     * })
    **/
    count<T extends InscriptionCountArgs>(
      args?: Subset<T, InscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InscriptionAggregateArgs>(args: Subset<T, InscriptionAggregateArgs>): Prisma.PrismaPromise<GetInscriptionAggregateType<T>>

    /**
     * Group by Inscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InscriptionGroupByArgs['orderBy'] }
        : { orderBy?: InscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inscription model
   */
  readonly fields: InscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    diplome<T extends DiplomeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiplomeDefaultArgs<ExtArgs>>): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    etudiant<T extends EtudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtudiantDefaultArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    classe<T extends ClasseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClasseDefaultArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Inscription model
   */ 
  interface InscriptionFieldRefs {
    readonly id: FieldRef<"Inscription", 'Int'>
    readonly createdAt: FieldRef<"Inscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Inscription", 'DateTime'>
    readonly reference: FieldRef<"Inscription", 'String'>
    readonly premiereInscription: FieldRef<"Inscription", 'Boolean'>
    readonly dernierDiplome: FieldRef<"Inscription", 'String'>
    readonly autreEtablissement: FieldRef<"Inscription", 'String'>
    readonly activiteProfessionnel: FieldRef<"Inscription", 'String'>
    readonly niveau: FieldRef<"Inscription", 'String'>
    readonly statut: FieldRef<"Inscription", 'String'>
    readonly diplomeId: FieldRef<"Inscription", 'Int'>
    readonly etudiantId: FieldRef<"Inscription", 'Int'>
    readonly classeId: FieldRef<"Inscription", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Inscription findUnique
   */
  export type InscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Inscription to fetch.
     */
    where: InscriptionWhereUniqueInput
  }


  /**
   * Inscription findUniqueOrThrow
   */
  export type InscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Inscription to fetch.
     */
    where: InscriptionWhereUniqueInput
  }


  /**
   * Inscription findFirst
   */
  export type InscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Inscription to fetch.
     */
    where?: InscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscriptions to fetch.
     */
    orderBy?: InscriptionOrderByWithRelationInput | InscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inscriptions.
     */
    cursor?: InscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inscriptions.
     */
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }


  /**
   * Inscription findFirstOrThrow
   */
  export type InscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Inscription to fetch.
     */
    where?: InscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscriptions to fetch.
     */
    orderBy?: InscriptionOrderByWithRelationInput | InscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inscriptions.
     */
    cursor?: InscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inscriptions.
     */
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }


  /**
   * Inscription findMany
   */
  export type InscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Inscriptions to fetch.
     */
    where?: InscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscriptions to fetch.
     */
    orderBy?: InscriptionOrderByWithRelationInput | InscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inscriptions.
     */
    cursor?: InscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscriptions.
     */
    skip?: number
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }


  /**
   * Inscription create
   */
  export type InscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Inscription.
     */
    data: XOR<InscriptionCreateInput, InscriptionUncheckedCreateInput>
  }


  /**
   * Inscription createMany
   */
  export type InscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inscriptions.
     */
    data: InscriptionCreateManyInput | InscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Inscription update
   */
  export type InscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Inscription.
     */
    data: XOR<InscriptionUpdateInput, InscriptionUncheckedUpdateInput>
    /**
     * Choose, which Inscription to update.
     */
    where: InscriptionWhereUniqueInput
  }


  /**
   * Inscription updateMany
   */
  export type InscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inscriptions.
     */
    data: XOR<InscriptionUpdateManyMutationInput, InscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Inscriptions to update
     */
    where?: InscriptionWhereInput
  }


  /**
   * Inscription upsert
   */
  export type InscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Inscription to update in case it exists.
     */
    where: InscriptionWhereUniqueInput
    /**
     * In case the Inscription found by the `where` argument doesn't exist, create a new Inscription with this data.
     */
    create: XOR<InscriptionCreateInput, InscriptionUncheckedCreateInput>
    /**
     * In case the Inscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InscriptionUpdateInput, InscriptionUncheckedUpdateInput>
  }


  /**
   * Inscription delete
   */
  export type InscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    /**
     * Filter which Inscription to delete.
     */
    where: InscriptionWhereUniqueInput
  }


  /**
   * Inscription deleteMany
   */
  export type InscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inscriptions to delete
     */
    where?: InscriptionWhereInput
  }


  /**
   * Inscription without action
   */
  export type InscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
  }



  /**
   * Model Domaine
   */

  export type AggregateDomaine = {
    _count: DomaineCountAggregateOutputType | null
    _avg: DomaineAvgAggregateOutputType | null
    _sum: DomaineSumAggregateOutputType | null
    _min: DomaineMinAggregateOutputType | null
    _max: DomaineMaxAggregateOutputType | null
  }

  export type DomaineAvgAggregateOutputType = {
    id: number | null
  }

  export type DomaineSumAggregateOutputType = {
    id: number | null
  }

  export type DomaineMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    slug: string | null
  }

  export type DomaineMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    slug: string | null
  }

  export type DomaineCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    slug: number
    _all: number
  }


  export type DomaineAvgAggregateInputType = {
    id?: true
  }

  export type DomaineSumAggregateInputType = {
    id?: true
  }

  export type DomaineMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    slug?: true
  }

  export type DomaineMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    slug?: true
  }

  export type DomaineCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    slug?: true
    _all?: true
  }

  export type DomaineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domaine to aggregate.
     */
    where?: DomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domaines to fetch.
     */
    orderBy?: DomaineOrderByWithRelationInput | DomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domaines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Domaines
    **/
    _count?: true | DomaineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomaineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomaineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomaineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomaineMaxAggregateInputType
  }

  export type GetDomaineAggregateType<T extends DomaineAggregateArgs> = {
        [P in keyof T & keyof AggregateDomaine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomaine[P]>
      : GetScalarType<T[P], AggregateDomaine[P]>
  }




  export type DomaineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomaineWhereInput
    orderBy?: DomaineOrderByWithAggregationInput | DomaineOrderByWithAggregationInput[]
    by: DomaineScalarFieldEnum[] | DomaineScalarFieldEnum
    having?: DomaineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomaineCountAggregateInputType | true
    _avg?: DomaineAvgAggregateInputType
    _sum?: DomaineSumAggregateInputType
    _min?: DomaineMinAggregateInputType
    _max?: DomaineMaxAggregateInputType
  }

  export type DomaineGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    slug: string | null
    _count: DomaineCountAggregateOutputType | null
    _avg: DomaineAvgAggregateOutputType | null
    _sum: DomaineSumAggregateOutputType | null
    _min: DomaineMinAggregateOutputType | null
    _max: DomaineMaxAggregateOutputType | null
  }

  type GetDomaineGroupByPayload<T extends DomaineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomaineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomaineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomaineGroupByOutputType[P]>
            : GetScalarType<T[P], DomaineGroupByOutputType[P]>
        }
      >
    >


  export type DomaineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    slug?: boolean
    etablissements?: boolean | Domaine$etablissementsArgs<ExtArgs>
    mentions?: boolean | Domaine$mentionsArgs<ExtArgs>
    _count?: boolean | DomaineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domaine"]>

  export type DomaineSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    slug?: boolean
  }

  export type DomaineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etablissements?: boolean | Domaine$etablissementsArgs<ExtArgs>
    mentions?: boolean | Domaine$mentionsArgs<ExtArgs>
    _count?: boolean | DomaineCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DomainePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Domaine"
    objects: {
      etablissements: Prisma.$EtablissementPayload<ExtArgs>[]
      mentions: Prisma.$MentionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      slug: string | null
    }, ExtArgs["result"]["domaine"]>
    composites: {}
  }


  type DomaineGetPayload<S extends boolean | null | undefined | DomaineDefaultArgs> = $Result.GetResult<Prisma.$DomainePayload, S>

  type DomaineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DomaineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DomaineCountAggregateInputType | true
    }

  export interface DomaineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Domaine'], meta: { name: 'Domaine' } }
    /**
     * Find zero or one Domaine that matches the filter.
     * @param {DomaineFindUniqueArgs} args - Arguments to find a Domaine
     * @example
     * // Get one Domaine
     * const domaine = await prisma.domaine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DomaineFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DomaineFindUniqueArgs<ExtArgs>>
    ): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Domaine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DomaineFindUniqueOrThrowArgs} args - Arguments to find a Domaine
     * @example
     * // Get one Domaine
     * const domaine = await prisma.domaine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DomaineFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DomaineFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Domaine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineFindFirstArgs} args - Arguments to find a Domaine
     * @example
     * // Get one Domaine
     * const domaine = await prisma.domaine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DomaineFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DomaineFindFirstArgs<ExtArgs>>
    ): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Domaine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineFindFirstOrThrowArgs} args - Arguments to find a Domaine
     * @example
     * // Get one Domaine
     * const domaine = await prisma.domaine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DomaineFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DomaineFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Domaines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domaines
     * const domaines = await prisma.domaine.findMany()
     * 
     * // Get first 10 Domaines
     * const domaines = await prisma.domaine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domaineWithIdOnly = await prisma.domaine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DomaineFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DomaineFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Domaine.
     * @param {DomaineCreateArgs} args - Arguments to create a Domaine.
     * @example
     * // Create one Domaine
     * const Domaine = await prisma.domaine.create({
     *   data: {
     *     // ... data to create a Domaine
     *   }
     * })
     * 
    **/
    create<T extends DomaineCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DomaineCreateArgs<ExtArgs>>
    ): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Domaines.
     *     @param {DomaineCreateManyArgs} args - Arguments to create many Domaines.
     *     @example
     *     // Create many Domaines
     *     const domaine = await prisma.domaine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DomaineCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DomaineCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Domaine.
     * @param {DomaineDeleteArgs} args - Arguments to delete one Domaine.
     * @example
     * // Delete one Domaine
     * const Domaine = await prisma.domaine.delete({
     *   where: {
     *     // ... filter to delete one Domaine
     *   }
     * })
     * 
    **/
    delete<T extends DomaineDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DomaineDeleteArgs<ExtArgs>>
    ): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Domaine.
     * @param {DomaineUpdateArgs} args - Arguments to update one Domaine.
     * @example
     * // Update one Domaine
     * const domaine = await prisma.domaine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DomaineUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DomaineUpdateArgs<ExtArgs>>
    ): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Domaines.
     * @param {DomaineDeleteManyArgs} args - Arguments to filter Domaines to delete.
     * @example
     * // Delete a few Domaines
     * const { count } = await prisma.domaine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DomaineDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DomaineDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domaines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domaines
     * const domaine = await prisma.domaine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DomaineUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DomaineUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Domaine.
     * @param {DomaineUpsertArgs} args - Arguments to update or create a Domaine.
     * @example
     * // Update or create a Domaine
     * const domaine = await prisma.domaine.upsert({
     *   create: {
     *     // ... data to create a Domaine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domaine we want to update
     *   }
     * })
    **/
    upsert<T extends DomaineUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DomaineUpsertArgs<ExtArgs>>
    ): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Domaines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineCountArgs} args - Arguments to filter Domaines to count.
     * @example
     * // Count the number of Domaines
     * const count = await prisma.domaine.count({
     *   where: {
     *     // ... the filter for the Domaines we want to count
     *   }
     * })
    **/
    count<T extends DomaineCountArgs>(
      args?: Subset<T, DomaineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomaineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domaine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomaineAggregateArgs>(args: Subset<T, DomaineAggregateArgs>): Prisma.PrismaPromise<GetDomaineAggregateType<T>>

    /**
     * Group by Domaine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomaineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomaineGroupByArgs['orderBy'] }
        : { orderBy?: DomaineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomaineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomaineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Domaine model
   */
  readonly fields: DomaineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Domaine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomaineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    etablissements<T extends Domaine$etablissementsArgs<ExtArgs> = {}>(args?: Subset<T, Domaine$etablissementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findMany'> | Null>;

    mentions<T extends Domaine$mentionsArgs<ExtArgs> = {}>(args?: Subset<T, Domaine$mentionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Domaine model
   */ 
  interface DomaineFieldRefs {
    readonly id: FieldRef<"Domaine", 'Int'>
    readonly createdAt: FieldRef<"Domaine", 'DateTime'>
    readonly updatedAt: FieldRef<"Domaine", 'DateTime'>
    readonly nom: FieldRef<"Domaine", 'String'>
    readonly slug: FieldRef<"Domaine", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Domaine findUnique
   */
  export type DomaineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaine to fetch.
     */
    where: DomaineWhereUniqueInput
  }


  /**
   * Domaine findUniqueOrThrow
   */
  export type DomaineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaine to fetch.
     */
    where: DomaineWhereUniqueInput
  }


  /**
   * Domaine findFirst
   */
  export type DomaineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaine to fetch.
     */
    where?: DomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domaines to fetch.
     */
    orderBy?: DomaineOrderByWithRelationInput | DomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domaines.
     */
    cursor?: DomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domaines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domaines.
     */
    distinct?: DomaineScalarFieldEnum | DomaineScalarFieldEnum[]
  }


  /**
   * Domaine findFirstOrThrow
   */
  export type DomaineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaine to fetch.
     */
    where?: DomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domaines to fetch.
     */
    orderBy?: DomaineOrderByWithRelationInput | DomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domaines.
     */
    cursor?: DomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domaines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domaines.
     */
    distinct?: DomaineScalarFieldEnum | DomaineScalarFieldEnum[]
  }


  /**
   * Domaine findMany
   */
  export type DomaineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaines to fetch.
     */
    where?: DomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domaines to fetch.
     */
    orderBy?: DomaineOrderByWithRelationInput | DomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Domaines.
     */
    cursor?: DomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domaines.
     */
    skip?: number
    distinct?: DomaineScalarFieldEnum | DomaineScalarFieldEnum[]
  }


  /**
   * Domaine create
   */
  export type DomaineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * The data needed to create a Domaine.
     */
    data: XOR<DomaineCreateInput, DomaineUncheckedCreateInput>
  }


  /**
   * Domaine createMany
   */
  export type DomaineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Domaines.
     */
    data: DomaineCreateManyInput | DomaineCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Domaine update
   */
  export type DomaineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * The data needed to update a Domaine.
     */
    data: XOR<DomaineUpdateInput, DomaineUncheckedUpdateInput>
    /**
     * Choose, which Domaine to update.
     */
    where: DomaineWhereUniqueInput
  }


  /**
   * Domaine updateMany
   */
  export type DomaineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Domaines.
     */
    data: XOR<DomaineUpdateManyMutationInput, DomaineUncheckedUpdateManyInput>
    /**
     * Filter which Domaines to update
     */
    where?: DomaineWhereInput
  }


  /**
   * Domaine upsert
   */
  export type DomaineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * The filter to search for the Domaine to update in case it exists.
     */
    where: DomaineWhereUniqueInput
    /**
     * In case the Domaine found by the `where` argument doesn't exist, create a new Domaine with this data.
     */
    create: XOR<DomaineCreateInput, DomaineUncheckedCreateInput>
    /**
     * In case the Domaine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomaineUpdateInput, DomaineUncheckedUpdateInput>
  }


  /**
   * Domaine delete
   */
  export type DomaineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter which Domaine to delete.
     */
    where: DomaineWhereUniqueInput
  }


  /**
   * Domaine deleteMany
   */
  export type DomaineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domaines to delete
     */
    where?: DomaineWhereInput
  }


  /**
   * Domaine.etablissements
   */
  export type Domaine$etablissementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    where?: EtablissementWhereInput
    orderBy?: EtablissementOrderByWithRelationInput | EtablissementOrderByWithRelationInput[]
    cursor?: EtablissementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtablissementScalarFieldEnum | EtablissementScalarFieldEnum[]
  }


  /**
   * Domaine.mentions
   */
  export type Domaine$mentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    where?: MentionWhereInput
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    cursor?: MentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }


  /**
   * Domaine without action
   */
  export type DomaineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
  }



  /**
   * Model Mention
   */

  export type AggregateMention = {
    _count: MentionCountAggregateOutputType | null
    _avg: MentionAvgAggregateOutputType | null
    _sum: MentionSumAggregateOutputType | null
    _min: MentionMinAggregateOutputType | null
    _max: MentionMaxAggregateOutputType | null
  }

  export type MentionAvgAggregateOutputType = {
    id: number | null
    domaineId: number | null
  }

  export type MentionSumAggregateOutputType = {
    id: number | null
    domaineId: number | null
  }

  export type MentionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    slug: string | null
    domaineId: number | null
  }

  export type MentionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    slug: string | null
    domaineId: number | null
  }

  export type MentionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    slug: number
    domaineId: number
    _all: number
  }


  export type MentionAvgAggregateInputType = {
    id?: true
    domaineId?: true
  }

  export type MentionSumAggregateInputType = {
    id?: true
    domaineId?: true
  }

  export type MentionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    slug?: true
    domaineId?: true
  }

  export type MentionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    slug?: true
    domaineId?: true
  }

  export type MentionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    slug?: true
    domaineId?: true
    _all?: true
  }

  export type MentionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mention to aggregate.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mentions
    **/
    _count?: true | MentionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentionMaxAggregateInputType
  }

  export type GetMentionAggregateType<T extends MentionAggregateArgs> = {
        [P in keyof T & keyof AggregateMention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMention[P]>
      : GetScalarType<T[P], AggregateMention[P]>
  }




  export type MentionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentionWhereInput
    orderBy?: MentionOrderByWithAggregationInput | MentionOrderByWithAggregationInput[]
    by: MentionScalarFieldEnum[] | MentionScalarFieldEnum
    having?: MentionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentionCountAggregateInputType | true
    _avg?: MentionAvgAggregateInputType
    _sum?: MentionSumAggregateInputType
    _min?: MentionMinAggregateInputType
    _max?: MentionMaxAggregateInputType
  }

  export type MentionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    slug: string | null
    domaineId: number | null
    _count: MentionCountAggregateOutputType | null
    _avg: MentionAvgAggregateOutputType | null
    _sum: MentionSumAggregateOutputType | null
    _min: MentionMinAggregateOutputType | null
    _max: MentionMaxAggregateOutputType | null
  }

  type GetMentionGroupByPayload<T extends MentionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentionGroupByOutputType[P]>
            : GetScalarType<T[P], MentionGroupByOutputType[P]>
        }
      >
    >


  export type MentionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    slug?: boolean
    domaineId?: boolean
    domaine?: boolean | Mention$domaineArgs<ExtArgs>
    specialites?: boolean | Mention$specialitesArgs<ExtArgs>
    _count?: boolean | MentionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mention"]>

  export type MentionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    slug?: boolean
    domaineId?: boolean
  }

  export type MentionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domaine?: boolean | Mention$domaineArgs<ExtArgs>
    specialites?: boolean | Mention$specialitesArgs<ExtArgs>
    _count?: boolean | MentionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MentionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mention"
    objects: {
      domaine: Prisma.$DomainePayload<ExtArgs> | null
      specialites: Prisma.$SpecialitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      slug: string | null
      domaineId: number | null
    }, ExtArgs["result"]["mention"]>
    composites: {}
  }


  type MentionGetPayload<S extends boolean | null | undefined | MentionDefaultArgs> = $Result.GetResult<Prisma.$MentionPayload, S>

  type MentionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MentionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentionCountAggregateInputType | true
    }

  export interface MentionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mention'], meta: { name: 'Mention' } }
    /**
     * Find zero or one Mention that matches the filter.
     * @param {MentionFindUniqueArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MentionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MentionFindUniqueArgs<ExtArgs>>
    ): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Mention that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MentionFindUniqueOrThrowArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MentionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MentionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Mention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionFindFirstArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MentionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MentionFindFirstArgs<ExtArgs>>
    ): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Mention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionFindFirstOrThrowArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MentionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MentionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Mentions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentions
     * const mentions = await prisma.mention.findMany()
     * 
     * // Get first 10 Mentions
     * const mentions = await prisma.mention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentionWithIdOnly = await prisma.mention.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MentionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MentionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Mention.
     * @param {MentionCreateArgs} args - Arguments to create a Mention.
     * @example
     * // Create one Mention
     * const Mention = await prisma.mention.create({
     *   data: {
     *     // ... data to create a Mention
     *   }
     * })
     * 
    **/
    create<T extends MentionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MentionCreateArgs<ExtArgs>>
    ): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Mentions.
     *     @param {MentionCreateManyArgs} args - Arguments to create many Mentions.
     *     @example
     *     // Create many Mentions
     *     const mention = await prisma.mention.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MentionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MentionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mention.
     * @param {MentionDeleteArgs} args - Arguments to delete one Mention.
     * @example
     * // Delete one Mention
     * const Mention = await prisma.mention.delete({
     *   where: {
     *     // ... filter to delete one Mention
     *   }
     * })
     * 
    **/
    delete<T extends MentionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MentionDeleteArgs<ExtArgs>>
    ): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Mention.
     * @param {MentionUpdateArgs} args - Arguments to update one Mention.
     * @example
     * // Update one Mention
     * const mention = await prisma.mention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MentionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MentionUpdateArgs<ExtArgs>>
    ): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Mentions.
     * @param {MentionDeleteManyArgs} args - Arguments to filter Mentions to delete.
     * @example
     * // Delete a few Mentions
     * const { count } = await prisma.mention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MentionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MentionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentions
     * const mention = await prisma.mention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MentionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MentionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mention.
     * @param {MentionUpsertArgs} args - Arguments to update or create a Mention.
     * @example
     * // Update or create a Mention
     * const mention = await prisma.mention.upsert({
     *   create: {
     *     // ... data to create a Mention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mention we want to update
     *   }
     * })
    **/
    upsert<T extends MentionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MentionUpsertArgs<ExtArgs>>
    ): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Mentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionCountArgs} args - Arguments to filter Mentions to count.
     * @example
     * // Count the number of Mentions
     * const count = await prisma.mention.count({
     *   where: {
     *     // ... the filter for the Mentions we want to count
     *   }
     * })
    **/
    count<T extends MentionCountArgs>(
      args?: Subset<T, MentionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentionAggregateArgs>(args: Subset<T, MentionAggregateArgs>): Prisma.PrismaPromise<GetMentionAggregateType<T>>

    /**
     * Group by Mention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentionGroupByArgs['orderBy'] }
        : { orderBy?: MentionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mention model
   */
  readonly fields: MentionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    domaine<T extends Mention$domaineArgs<ExtArgs> = {}>(args?: Subset<T, Mention$domaineArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    specialites<T extends Mention$specialitesArgs<ExtArgs> = {}>(args?: Subset<T, Mention$specialitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Mention model
   */ 
  interface MentionFieldRefs {
    readonly id: FieldRef<"Mention", 'Int'>
    readonly createdAt: FieldRef<"Mention", 'DateTime'>
    readonly updatedAt: FieldRef<"Mention", 'DateTime'>
    readonly nom: FieldRef<"Mention", 'String'>
    readonly slug: FieldRef<"Mention", 'String'>
    readonly domaineId: FieldRef<"Mention", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Mention findUnique
   */
  export type MentionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where: MentionWhereUniqueInput
  }


  /**
   * Mention findUniqueOrThrow
   */
  export type MentionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where: MentionWhereUniqueInput
  }


  /**
   * Mention findFirst
   */
  export type MentionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentions.
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentions.
     */
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }


  /**
   * Mention findFirstOrThrow
   */
  export type MentionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentions.
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentions.
     */
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }


  /**
   * Mention findMany
   */
  export type MentionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mentions to fetch.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mentions.
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }


  /**
   * Mention create
   */
  export type MentionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * The data needed to create a Mention.
     */
    data: XOR<MentionCreateInput, MentionUncheckedCreateInput>
  }


  /**
   * Mention createMany
   */
  export type MentionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mentions.
     */
    data: MentionCreateManyInput | MentionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Mention update
   */
  export type MentionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * The data needed to update a Mention.
     */
    data: XOR<MentionUpdateInput, MentionUncheckedUpdateInput>
    /**
     * Choose, which Mention to update.
     */
    where: MentionWhereUniqueInput
  }


  /**
   * Mention updateMany
   */
  export type MentionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mentions.
     */
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyInput>
    /**
     * Filter which Mentions to update
     */
    where?: MentionWhereInput
  }


  /**
   * Mention upsert
   */
  export type MentionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * The filter to search for the Mention to update in case it exists.
     */
    where: MentionWhereUniqueInput
    /**
     * In case the Mention found by the `where` argument doesn't exist, create a new Mention with this data.
     */
    create: XOR<MentionCreateInput, MentionUncheckedCreateInput>
    /**
     * In case the Mention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentionUpdateInput, MentionUncheckedUpdateInput>
  }


  /**
   * Mention delete
   */
  export type MentionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter which Mention to delete.
     */
    where: MentionWhereUniqueInput
  }


  /**
   * Mention deleteMany
   */
  export type MentionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentions to delete
     */
    where?: MentionWhereInput
  }


  /**
   * Mention.domaine
   */
  export type Mention$domaineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    where?: DomaineWhereInput
  }


  /**
   * Mention.specialites
   */
  export type Mention$specialitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    where?: SpecialiteWhereInput
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    cursor?: SpecialiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }


  /**
   * Mention without action
   */
  export type MentionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
  }



  /**
   * Model Specialite
   */

  export type AggregateSpecialite = {
    _count: SpecialiteCountAggregateOutputType | null
    _avg: SpecialiteAvgAggregateOutputType | null
    _sum: SpecialiteSumAggregateOutputType | null
    _min: SpecialiteMinAggregateOutputType | null
    _max: SpecialiteMaxAggregateOutputType | null
  }

  export type SpecialiteAvgAggregateOutputType = {
    id: number | null
    mentionId: number | null
  }

  export type SpecialiteSumAggregateOutputType = {
    id: number | null
    mentionId: number | null
  }

  export type SpecialiteMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    slug: string | null
    mentionId: number | null
  }

  export type SpecialiteMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    slug: string | null
    mentionId: number | null
  }

  export type SpecialiteCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    slug: number
    mentionId: number
    _all: number
  }


  export type SpecialiteAvgAggregateInputType = {
    id?: true
    mentionId?: true
  }

  export type SpecialiteSumAggregateInputType = {
    id?: true
    mentionId?: true
  }

  export type SpecialiteMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    slug?: true
    mentionId?: true
  }

  export type SpecialiteMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    slug?: true
    mentionId?: true
  }

  export type SpecialiteCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    slug?: true
    mentionId?: true
    _all?: true
  }

  export type SpecialiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialite to aggregate.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specialites
    **/
    _count?: true | SpecialiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecialiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecialiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialiteMaxAggregateInputType
  }

  export type GetSpecialiteAggregateType<T extends SpecialiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialite[P]>
      : GetScalarType<T[P], AggregateSpecialite[P]>
  }




  export type SpecialiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialiteWhereInput
    orderBy?: SpecialiteOrderByWithAggregationInput | SpecialiteOrderByWithAggregationInput[]
    by: SpecialiteScalarFieldEnum[] | SpecialiteScalarFieldEnum
    having?: SpecialiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialiteCountAggregateInputType | true
    _avg?: SpecialiteAvgAggregateInputType
    _sum?: SpecialiteSumAggregateInputType
    _min?: SpecialiteMinAggregateInputType
    _max?: SpecialiteMaxAggregateInputType
  }

  export type SpecialiteGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    slug: string | null
    mentionId: number | null
    _count: SpecialiteCountAggregateOutputType | null
    _avg: SpecialiteAvgAggregateOutputType | null
    _sum: SpecialiteSumAggregateOutputType | null
    _min: SpecialiteMinAggregateOutputType | null
    _max: SpecialiteMaxAggregateOutputType | null
  }

  type GetSpecialiteGroupByPayload<T extends SpecialiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialiteGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialiteGroupByOutputType[P]>
        }
      >
    >


  export type SpecialiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    slug?: boolean
    mentionId?: boolean
    mention?: boolean | Specialite$mentionArgs<ExtArgs>
    Classe?: boolean | Specialite$ClasseArgs<ExtArgs>
    Diplome?: boolean | Specialite$DiplomeArgs<ExtArgs>
    _count?: boolean | SpecialiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialite"]>

  export type SpecialiteSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    slug?: boolean
    mentionId?: boolean
  }

  export type SpecialiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mention?: boolean | Specialite$mentionArgs<ExtArgs>
    Classe?: boolean | Specialite$ClasseArgs<ExtArgs>
    Diplome?: boolean | Specialite$DiplomeArgs<ExtArgs>
    _count?: boolean | SpecialiteCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SpecialitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Specialite"
    objects: {
      mention: Prisma.$MentionPayload<ExtArgs> | null
      Classe: Prisma.$ClassePayload<ExtArgs>[]
      Diplome: Prisma.$DiplomePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      slug: string | null
      mentionId: number | null
    }, ExtArgs["result"]["specialite"]>
    composites: {}
  }


  type SpecialiteGetPayload<S extends boolean | null | undefined | SpecialiteDefaultArgs> = $Result.GetResult<Prisma.$SpecialitePayload, S>

  type SpecialiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpecialiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpecialiteCountAggregateInputType | true
    }

  export interface SpecialiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specialite'], meta: { name: 'Specialite' } }
    /**
     * Find zero or one Specialite that matches the filter.
     * @param {SpecialiteFindUniqueArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpecialiteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteFindUniqueArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Specialite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpecialiteFindUniqueOrThrowArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpecialiteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Specialite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteFindFirstArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpecialiteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteFindFirstArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Specialite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteFindFirstOrThrowArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpecialiteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Specialites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialites
     * const specialites = await prisma.specialite.findMany()
     * 
     * // Get first 10 Specialites
     * const specialites = await prisma.specialite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialiteWithIdOnly = await prisma.specialite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpecialiteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Specialite.
     * @param {SpecialiteCreateArgs} args - Arguments to create a Specialite.
     * @example
     * // Create one Specialite
     * const Specialite = await prisma.specialite.create({
     *   data: {
     *     // ... data to create a Specialite
     *   }
     * })
     * 
    **/
    create<T extends SpecialiteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteCreateArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Specialites.
     *     @param {SpecialiteCreateManyArgs} args - Arguments to create many Specialites.
     *     @example
     *     // Create many Specialites
     *     const specialite = await prisma.specialite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpecialiteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Specialite.
     * @param {SpecialiteDeleteArgs} args - Arguments to delete one Specialite.
     * @example
     * // Delete one Specialite
     * const Specialite = await prisma.specialite.delete({
     *   where: {
     *     // ... filter to delete one Specialite
     *   }
     * })
     * 
    **/
    delete<T extends SpecialiteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteDeleteArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Specialite.
     * @param {SpecialiteUpdateArgs} args - Arguments to update one Specialite.
     * @example
     * // Update one Specialite
     * const specialite = await prisma.specialite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpecialiteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteUpdateArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Specialites.
     * @param {SpecialiteDeleteManyArgs} args - Arguments to filter Specialites to delete.
     * @example
     * // Delete a few Specialites
     * const { count } = await prisma.specialite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpecialiteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialites
     * const specialite = await prisma.specialite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpecialiteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Specialite.
     * @param {SpecialiteUpsertArgs} args - Arguments to update or create a Specialite.
     * @example
     * // Update or create a Specialite
     * const specialite = await prisma.specialite.upsert({
     *   create: {
     *     // ... data to create a Specialite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialite we want to update
     *   }
     * })
    **/
    upsert<T extends SpecialiteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteUpsertArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Specialites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteCountArgs} args - Arguments to filter Specialites to count.
     * @example
     * // Count the number of Specialites
     * const count = await prisma.specialite.count({
     *   where: {
     *     // ... the filter for the Specialites we want to count
     *   }
     * })
    **/
    count<T extends SpecialiteCountArgs>(
      args?: Subset<T, SpecialiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialiteAggregateArgs>(args: Subset<T, SpecialiteAggregateArgs>): Prisma.PrismaPromise<GetSpecialiteAggregateType<T>>

    /**
     * Group by Specialite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialiteGroupByArgs['orderBy'] }
        : { orderBy?: SpecialiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Specialite model
   */
  readonly fields: SpecialiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Specialite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mention<T extends Specialite$mentionArgs<ExtArgs> = {}>(args?: Subset<T, Specialite$mentionArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Classe<T extends Specialite$ClasseArgs<ExtArgs> = {}>(args?: Subset<T, Specialite$ClasseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findMany'> | Null>;

    Diplome<T extends Specialite$DiplomeArgs<ExtArgs> = {}>(args?: Subset<T, Specialite$DiplomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Specialite model
   */ 
  interface SpecialiteFieldRefs {
    readonly id: FieldRef<"Specialite", 'Int'>
    readonly createdAt: FieldRef<"Specialite", 'DateTime'>
    readonly updatedAt: FieldRef<"Specialite", 'DateTime'>
    readonly nom: FieldRef<"Specialite", 'String'>
    readonly slug: FieldRef<"Specialite", 'String'>
    readonly mentionId: FieldRef<"Specialite", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Specialite findUnique
   */
  export type SpecialiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where: SpecialiteWhereUniqueInput
  }


  /**
   * Specialite findUniqueOrThrow
   */
  export type SpecialiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where: SpecialiteWhereUniqueInput
  }


  /**
   * Specialite findFirst
   */
  export type SpecialiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialites.
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialites.
     */
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }


  /**
   * Specialite findFirstOrThrow
   */
  export type SpecialiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialites.
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialites.
     */
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }


  /**
   * Specialite findMany
   */
  export type SpecialiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialites to fetch.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specialites.
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }


  /**
   * Specialite create
   */
  export type SpecialiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Specialite.
     */
    data: XOR<SpecialiteCreateInput, SpecialiteUncheckedCreateInput>
  }


  /**
   * Specialite createMany
   */
  export type SpecialiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specialites.
     */
    data: SpecialiteCreateManyInput | SpecialiteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Specialite update
   */
  export type SpecialiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Specialite.
     */
    data: XOR<SpecialiteUpdateInput, SpecialiteUncheckedUpdateInput>
    /**
     * Choose, which Specialite to update.
     */
    where: SpecialiteWhereUniqueInput
  }


  /**
   * Specialite updateMany
   */
  export type SpecialiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specialites.
     */
    data: XOR<SpecialiteUpdateManyMutationInput, SpecialiteUncheckedUpdateManyInput>
    /**
     * Filter which Specialites to update
     */
    where?: SpecialiteWhereInput
  }


  /**
   * Specialite upsert
   */
  export type SpecialiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Specialite to update in case it exists.
     */
    where: SpecialiteWhereUniqueInput
    /**
     * In case the Specialite found by the `where` argument doesn't exist, create a new Specialite with this data.
     */
    create: XOR<SpecialiteCreateInput, SpecialiteUncheckedCreateInput>
    /**
     * In case the Specialite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialiteUpdateInput, SpecialiteUncheckedUpdateInput>
  }


  /**
   * Specialite delete
   */
  export type SpecialiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter which Specialite to delete.
     */
    where: SpecialiteWhereUniqueInput
  }


  /**
   * Specialite deleteMany
   */
  export type SpecialiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialites to delete
     */
    where?: SpecialiteWhereInput
  }


  /**
   * Specialite.mention
   */
  export type Specialite$mentionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MentionInclude<ExtArgs> | null
    where?: MentionWhereInput
  }


  /**
   * Specialite.Classe
   */
  export type Specialite$ClasseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    where?: ClasseWhereInput
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    cursor?: ClasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }


  /**
   * Specialite.Diplome
   */
  export type Specialite$DiplomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    where?: DiplomeWhereInput
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    cursor?: DiplomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiplomeScalarFieldEnum | DiplomeScalarFieldEnum[]
  }


  /**
   * Specialite without action
   */
  export type SpecialiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
  }



  /**
   * Model Diplome
   */

  export type AggregateDiplome = {
    _count: DiplomeCountAggregateOutputType | null
    _avg: DiplomeAvgAggregateOutputType | null
    _sum: DiplomeSumAggregateOutputType | null
    _min: DiplomeMinAggregateOutputType | null
    _max: DiplomeMaxAggregateOutputType | null
  }

  export type DiplomeAvgAggregateOutputType = {
    id: number | null
    duree: number | null
    specialiteId: number | null
  }

  export type DiplomeSumAggregateOutputType = {
    id: number | null
    duree: number | null
    specialiteId: number | null
  }

  export type DiplomeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    finalite: string | null
    entite: string | null
    habilitation: string | null
    dateCreation: Date | null
    dateHabilitation: Date | null
    dateEcheance: Date | null
    duree: number | null
    specialiteId: number | null
  }

  export type DiplomeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    finalite: string | null
    entite: string | null
    habilitation: string | null
    dateCreation: Date | null
    dateHabilitation: Date | null
    dateEcheance: Date | null
    duree: number | null
    specialiteId: number | null
  }

  export type DiplomeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    finalite: number
    entite: number
    habilitation: number
    partenaires: number
    dateCreation: number
    dateHabilitation: number
    dateEcheance: number
    duree: number
    specialiteId: number
    _all: number
  }


  export type DiplomeAvgAggregateInputType = {
    id?: true
    duree?: true
    specialiteId?: true
  }

  export type DiplomeSumAggregateInputType = {
    id?: true
    duree?: true
    specialiteId?: true
  }

  export type DiplomeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    finalite?: true
    entite?: true
    habilitation?: true
    dateCreation?: true
    dateHabilitation?: true
    dateEcheance?: true
    duree?: true
    specialiteId?: true
  }

  export type DiplomeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    finalite?: true
    entite?: true
    habilitation?: true
    dateCreation?: true
    dateHabilitation?: true
    dateEcheance?: true
    duree?: true
    specialiteId?: true
  }

  export type DiplomeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    finalite?: true
    entite?: true
    habilitation?: true
    partenaires?: true
    dateCreation?: true
    dateHabilitation?: true
    dateEcheance?: true
    duree?: true
    specialiteId?: true
    _all?: true
  }

  export type DiplomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diplome to aggregate.
     */
    where?: DiplomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomes to fetch.
     */
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiplomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diplomes
    **/
    _count?: true | DiplomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiplomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiplomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiplomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiplomeMaxAggregateInputType
  }

  export type GetDiplomeAggregateType<T extends DiplomeAggregateArgs> = {
        [P in keyof T & keyof AggregateDiplome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiplome[P]>
      : GetScalarType<T[P], AggregateDiplome[P]>
  }




  export type DiplomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiplomeWhereInput
    orderBy?: DiplomeOrderByWithAggregationInput | DiplomeOrderByWithAggregationInput[]
    by: DiplomeScalarFieldEnum[] | DiplomeScalarFieldEnum
    having?: DiplomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiplomeCountAggregateInputType | true
    _avg?: DiplomeAvgAggregateInputType
    _sum?: DiplomeSumAggregateInputType
    _min?: DiplomeMinAggregateInputType
    _max?: DiplomeMaxAggregateInputType
  }

  export type DiplomeGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    finalite: string
    entite: string
    habilitation: string
    partenaires: string[]
    dateCreation: Date
    dateHabilitation: Date
    dateEcheance: Date
    duree: number
    specialiteId: number | null
    _count: DiplomeCountAggregateOutputType | null
    _avg: DiplomeAvgAggregateOutputType | null
    _sum: DiplomeSumAggregateOutputType | null
    _min: DiplomeMinAggregateOutputType | null
    _max: DiplomeMaxAggregateOutputType | null
  }

  type GetDiplomeGroupByPayload<T extends DiplomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiplomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiplomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiplomeGroupByOutputType[P]>
            : GetScalarType<T[P], DiplomeGroupByOutputType[P]>
        }
      >
    >


  export type DiplomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    finalite?: boolean
    entite?: boolean
    habilitation?: boolean
    partenaires?: boolean
    dateCreation?: boolean
    dateHabilitation?: boolean
    dateEcheance?: boolean
    duree?: boolean
    specialiteId?: boolean
    inscriptions?: boolean | Diplome$inscriptionsArgs<ExtArgs>
    specialite?: boolean | Diplome$specialiteArgs<ExtArgs>
    _count?: boolean | DiplomeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diplome"]>

  export type DiplomeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    finalite?: boolean
    entite?: boolean
    habilitation?: boolean
    partenaires?: boolean
    dateCreation?: boolean
    dateHabilitation?: boolean
    dateEcheance?: boolean
    duree?: boolean
    specialiteId?: boolean
  }

  export type DiplomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscriptions?: boolean | Diplome$inscriptionsArgs<ExtArgs>
    specialite?: boolean | Diplome$specialiteArgs<ExtArgs>
    _count?: boolean | DiplomeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DiplomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diplome"
    objects: {
      inscriptions: Prisma.$InscriptionPayload<ExtArgs>[]
      specialite: Prisma.$SpecialitePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      finalite: string
      entite: string
      habilitation: string
      partenaires: string[]
      dateCreation: Date
      dateHabilitation: Date
      dateEcheance: Date
      duree: number
      specialiteId: number | null
    }, ExtArgs["result"]["diplome"]>
    composites: {}
  }


  type DiplomeGetPayload<S extends boolean | null | undefined | DiplomeDefaultArgs> = $Result.GetResult<Prisma.$DiplomePayload, S>

  type DiplomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiplomeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiplomeCountAggregateInputType | true
    }

  export interface DiplomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diplome'], meta: { name: 'Diplome' } }
    /**
     * Find zero or one Diplome that matches the filter.
     * @param {DiplomeFindUniqueArgs} args - Arguments to find a Diplome
     * @example
     * // Get one Diplome
     * const diplome = await prisma.diplome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiplomeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DiplomeFindUniqueArgs<ExtArgs>>
    ): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Diplome that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DiplomeFindUniqueOrThrowArgs} args - Arguments to find a Diplome
     * @example
     * // Get one Diplome
     * const diplome = await prisma.diplome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiplomeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiplomeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Diplome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeFindFirstArgs} args - Arguments to find a Diplome
     * @example
     * // Get one Diplome
     * const diplome = await prisma.diplome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiplomeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DiplomeFindFirstArgs<ExtArgs>>
    ): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Diplome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeFindFirstOrThrowArgs} args - Arguments to find a Diplome
     * @example
     * // Get one Diplome
     * const diplome = await prisma.diplome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiplomeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiplomeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Diplomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diplomes
     * const diplomes = await prisma.diplome.findMany()
     * 
     * // Get first 10 Diplomes
     * const diplomes = await prisma.diplome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diplomeWithIdOnly = await prisma.diplome.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiplomeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiplomeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Diplome.
     * @param {DiplomeCreateArgs} args - Arguments to create a Diplome.
     * @example
     * // Create one Diplome
     * const Diplome = await prisma.diplome.create({
     *   data: {
     *     // ... data to create a Diplome
     *   }
     * })
     * 
    **/
    create<T extends DiplomeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DiplomeCreateArgs<ExtArgs>>
    ): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Diplomes.
     *     @param {DiplomeCreateManyArgs} args - Arguments to create many Diplomes.
     *     @example
     *     // Create many Diplomes
     *     const diplome = await prisma.diplome.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiplomeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiplomeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diplome.
     * @param {DiplomeDeleteArgs} args - Arguments to delete one Diplome.
     * @example
     * // Delete one Diplome
     * const Diplome = await prisma.diplome.delete({
     *   where: {
     *     // ... filter to delete one Diplome
     *   }
     * })
     * 
    **/
    delete<T extends DiplomeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DiplomeDeleteArgs<ExtArgs>>
    ): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Diplome.
     * @param {DiplomeUpdateArgs} args - Arguments to update one Diplome.
     * @example
     * // Update one Diplome
     * const diplome = await prisma.diplome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiplomeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DiplomeUpdateArgs<ExtArgs>>
    ): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Diplomes.
     * @param {DiplomeDeleteManyArgs} args - Arguments to filter Diplomes to delete.
     * @example
     * // Delete a few Diplomes
     * const { count } = await prisma.diplome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiplomeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiplomeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diplomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diplomes
     * const diplome = await prisma.diplome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiplomeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DiplomeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diplome.
     * @param {DiplomeUpsertArgs} args - Arguments to update or create a Diplome.
     * @example
     * // Update or create a Diplome
     * const diplome = await prisma.diplome.upsert({
     *   create: {
     *     // ... data to create a Diplome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diplome we want to update
     *   }
     * })
    **/
    upsert<T extends DiplomeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DiplomeUpsertArgs<ExtArgs>>
    ): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Diplomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeCountArgs} args - Arguments to filter Diplomes to count.
     * @example
     * // Count the number of Diplomes
     * const count = await prisma.diplome.count({
     *   where: {
     *     // ... the filter for the Diplomes we want to count
     *   }
     * })
    **/
    count<T extends DiplomeCountArgs>(
      args?: Subset<T, DiplomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiplomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diplome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiplomeAggregateArgs>(args: Subset<T, DiplomeAggregateArgs>): Prisma.PrismaPromise<GetDiplomeAggregateType<T>>

    /**
     * Group by Diplome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiplomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiplomeGroupByArgs['orderBy'] }
        : { orderBy?: DiplomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiplomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiplomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diplome model
   */
  readonly fields: DiplomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diplome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiplomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    inscriptions<T extends Diplome$inscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Diplome$inscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    specialite<T extends Diplome$specialiteArgs<ExtArgs> = {}>(args?: Subset<T, Diplome$specialiteArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Diplome model
   */ 
  interface DiplomeFieldRefs {
    readonly id: FieldRef<"Diplome", 'Int'>
    readonly createdAt: FieldRef<"Diplome", 'DateTime'>
    readonly updatedAt: FieldRef<"Diplome", 'DateTime'>
    readonly nom: FieldRef<"Diplome", 'String'>
    readonly finalite: FieldRef<"Diplome", 'String'>
    readonly entite: FieldRef<"Diplome", 'String'>
    readonly habilitation: FieldRef<"Diplome", 'String'>
    readonly partenaires: FieldRef<"Diplome", 'String[]'>
    readonly dateCreation: FieldRef<"Diplome", 'DateTime'>
    readonly dateHabilitation: FieldRef<"Diplome", 'DateTime'>
    readonly dateEcheance: FieldRef<"Diplome", 'DateTime'>
    readonly duree: FieldRef<"Diplome", 'Int'>
    readonly specialiteId: FieldRef<"Diplome", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Diplome findUnique
   */
  export type DiplomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplome to fetch.
     */
    where: DiplomeWhereUniqueInput
  }


  /**
   * Diplome findUniqueOrThrow
   */
  export type DiplomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplome to fetch.
     */
    where: DiplomeWhereUniqueInput
  }


  /**
   * Diplome findFirst
   */
  export type DiplomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplome to fetch.
     */
    where?: DiplomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomes to fetch.
     */
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diplomes.
     */
    cursor?: DiplomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diplomes.
     */
    distinct?: DiplomeScalarFieldEnum | DiplomeScalarFieldEnum[]
  }


  /**
   * Diplome findFirstOrThrow
   */
  export type DiplomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplome to fetch.
     */
    where?: DiplomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomes to fetch.
     */
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diplomes.
     */
    cursor?: DiplomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diplomes.
     */
    distinct?: DiplomeScalarFieldEnum | DiplomeScalarFieldEnum[]
  }


  /**
   * Diplome findMany
   */
  export type DiplomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplomes to fetch.
     */
    where?: DiplomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomes to fetch.
     */
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diplomes.
     */
    cursor?: DiplomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomes.
     */
    skip?: number
    distinct?: DiplomeScalarFieldEnum | DiplomeScalarFieldEnum[]
  }


  /**
   * Diplome create
   */
  export type DiplomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * The data needed to create a Diplome.
     */
    data: XOR<DiplomeCreateInput, DiplomeUncheckedCreateInput>
  }


  /**
   * Diplome createMany
   */
  export type DiplomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diplomes.
     */
    data: DiplomeCreateManyInput | DiplomeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Diplome update
   */
  export type DiplomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * The data needed to update a Diplome.
     */
    data: XOR<DiplomeUpdateInput, DiplomeUncheckedUpdateInput>
    /**
     * Choose, which Diplome to update.
     */
    where: DiplomeWhereUniqueInput
  }


  /**
   * Diplome updateMany
   */
  export type DiplomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diplomes.
     */
    data: XOR<DiplomeUpdateManyMutationInput, DiplomeUncheckedUpdateManyInput>
    /**
     * Filter which Diplomes to update
     */
    where?: DiplomeWhereInput
  }


  /**
   * Diplome upsert
   */
  export type DiplomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * The filter to search for the Diplome to update in case it exists.
     */
    where: DiplomeWhereUniqueInput
    /**
     * In case the Diplome found by the `where` argument doesn't exist, create a new Diplome with this data.
     */
    create: XOR<DiplomeCreateInput, DiplomeUncheckedCreateInput>
    /**
     * In case the Diplome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiplomeUpdateInput, DiplomeUncheckedUpdateInput>
  }


  /**
   * Diplome delete
   */
  export type DiplomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter which Diplome to delete.
     */
    where: DiplomeWhereUniqueInput
  }


  /**
   * Diplome deleteMany
   */
  export type DiplomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diplomes to delete
     */
    where?: DiplomeWhereInput
  }


  /**
   * Diplome.inscriptions
   */
  export type Diplome$inscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    where?: InscriptionWhereInput
    orderBy?: InscriptionOrderByWithRelationInput | InscriptionOrderByWithRelationInput[]
    cursor?: InscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }


  /**
   * Diplome.specialite
   */
  export type Diplome$specialiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    where?: SpecialiteWhereInput
  }


  /**
   * Diplome without action
   */
  export type DiplomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomeInclude<ExtArgs> | null
  }



  /**
   * Model Semestre
   */

  export type AggregateSemestre = {
    _count: SemestreCountAggregateOutputType | null
    _avg: SemestreAvgAggregateOutputType | null
    _sum: SemestreSumAggregateOutputType | null
    _min: SemestreMinAggregateOutputType | null
    _max: SemestreMaxAggregateOutputType | null
  }

  export type SemestreAvgAggregateOutputType = {
    id: number | null
    numero: number | null
    nombreSemaine: number | null
    classeId: number | null
  }

  export type SemestreSumAggregateOutputType = {
    id: number | null
    numero: number | null
    nombreSemaine: number | null
    classeId: number | null
  }

  export type SemestreMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    numero: number | null
    grade: $Enums.TypeDiplome | null
    dateDebut: Date | null
    dateFin: Date | null
    nombreSemaine: number | null
    classeId: number | null
  }

  export type SemestreMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    numero: number | null
    grade: $Enums.TypeDiplome | null
    dateDebut: Date | null
    dateFin: Date | null
    nombreSemaine: number | null
    classeId: number | null
  }

  export type SemestreCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    numero: number
    grade: number
    dateDebut: number
    dateFin: number
    nombreSemaine: number
    classeId: number
    _all: number
  }


  export type SemestreAvgAggregateInputType = {
    id?: true
    numero?: true
    nombreSemaine?: true
    classeId?: true
  }

  export type SemestreSumAggregateInputType = {
    id?: true
    numero?: true
    nombreSemaine?: true
    classeId?: true
  }

  export type SemestreMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    numero?: true
    grade?: true
    dateDebut?: true
    dateFin?: true
    nombreSemaine?: true
    classeId?: true
  }

  export type SemestreMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    numero?: true
    grade?: true
    dateDebut?: true
    dateFin?: true
    nombreSemaine?: true
    classeId?: true
  }

  export type SemestreCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    numero?: true
    grade?: true
    dateDebut?: true
    dateFin?: true
    nombreSemaine?: true
    classeId?: true
    _all?: true
  }

  export type SemestreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Semestre to aggregate.
     */
    where?: SemestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semestres to fetch.
     */
    orderBy?: SemestreOrderByWithRelationInput | SemestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Semestres
    **/
    _count?: true | SemestreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemestreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemestreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemestreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemestreMaxAggregateInputType
  }

  export type GetSemestreAggregateType<T extends SemestreAggregateArgs> = {
        [P in keyof T & keyof AggregateSemestre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemestre[P]>
      : GetScalarType<T[P], AggregateSemestre[P]>
  }




  export type SemestreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemestreWhereInput
    orderBy?: SemestreOrderByWithAggregationInput | SemestreOrderByWithAggregationInput[]
    by: SemestreScalarFieldEnum[] | SemestreScalarFieldEnum
    having?: SemestreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemestreCountAggregateInputType | true
    _avg?: SemestreAvgAggregateInputType
    _sum?: SemestreSumAggregateInputType
    _min?: SemestreMinAggregateInputType
    _max?: SemestreMaxAggregateInputType
  }

  export type SemestreGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    numero: number
    grade: $Enums.TypeDiplome
    dateDebut: Date
    dateFin: Date
    nombreSemaine: number
    classeId: number | null
    _count: SemestreCountAggregateOutputType | null
    _avg: SemestreAvgAggregateOutputType | null
    _sum: SemestreSumAggregateOutputType | null
    _min: SemestreMinAggregateOutputType | null
    _max: SemestreMaxAggregateOutputType | null
  }

  type GetSemestreGroupByPayload<T extends SemestreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemestreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemestreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemestreGroupByOutputType[P]>
            : GetScalarType<T[P], SemestreGroupByOutputType[P]>
        }
      >
    >


  export type SemestreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numero?: boolean
    grade?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    nombreSemaine?: boolean
    classeId?: boolean
    uniteEnseignement?: boolean | Semestre$uniteEnseignementArgs<ExtArgs>
    Classe?: boolean | Semestre$ClasseArgs<ExtArgs>
    _count?: boolean | SemestreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semestre"]>

  export type SemestreSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numero?: boolean
    grade?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    nombreSemaine?: boolean
    classeId?: boolean
  }

  export type SemestreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uniteEnseignement?: boolean | Semestre$uniteEnseignementArgs<ExtArgs>
    Classe?: boolean | Semestre$ClasseArgs<ExtArgs>
    _count?: boolean | SemestreCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SemestrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Semestre"
    objects: {
      uniteEnseignement: Prisma.$UniteEnseignementPayload<ExtArgs>[]
      Classe: Prisma.$ClassePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      numero: number
      grade: $Enums.TypeDiplome
      dateDebut: Date
      dateFin: Date
      nombreSemaine: number
      classeId: number | null
    }, ExtArgs["result"]["semestre"]>
    composites: {}
  }


  type SemestreGetPayload<S extends boolean | null | undefined | SemestreDefaultArgs> = $Result.GetResult<Prisma.$SemestrePayload, S>

  type SemestreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SemestreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SemestreCountAggregateInputType | true
    }

  export interface SemestreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Semestre'], meta: { name: 'Semestre' } }
    /**
     * Find zero or one Semestre that matches the filter.
     * @param {SemestreFindUniqueArgs} args - Arguments to find a Semestre
     * @example
     * // Get one Semestre
     * const semestre = await prisma.semestre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SemestreFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreFindUniqueArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Semestre that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SemestreFindUniqueOrThrowArgs} args - Arguments to find a Semestre
     * @example
     * // Get one Semestre
     * const semestre = await prisma.semestre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SemestreFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Semestre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreFindFirstArgs} args - Arguments to find a Semestre
     * @example
     * // Get one Semestre
     * const semestre = await prisma.semestre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SemestreFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreFindFirstArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Semestre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreFindFirstOrThrowArgs} args - Arguments to find a Semestre
     * @example
     * // Get one Semestre
     * const semestre = await prisma.semestre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SemestreFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Semestres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Semestres
     * const semestres = await prisma.semestre.findMany()
     * 
     * // Get first 10 Semestres
     * const semestres = await prisma.semestre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semestreWithIdOnly = await prisma.semestre.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SemestreFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Semestre.
     * @param {SemestreCreateArgs} args - Arguments to create a Semestre.
     * @example
     * // Create one Semestre
     * const Semestre = await prisma.semestre.create({
     *   data: {
     *     // ... data to create a Semestre
     *   }
     * })
     * 
    **/
    create<T extends SemestreCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreCreateArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Semestres.
     *     @param {SemestreCreateManyArgs} args - Arguments to create many Semestres.
     *     @example
     *     // Create many Semestres
     *     const semestre = await prisma.semestre.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SemestreCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Semestre.
     * @param {SemestreDeleteArgs} args - Arguments to delete one Semestre.
     * @example
     * // Delete one Semestre
     * const Semestre = await prisma.semestre.delete({
     *   where: {
     *     // ... filter to delete one Semestre
     *   }
     * })
     * 
    **/
    delete<T extends SemestreDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreDeleteArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Semestre.
     * @param {SemestreUpdateArgs} args - Arguments to update one Semestre.
     * @example
     * // Update one Semestre
     * const semestre = await prisma.semestre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SemestreUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreUpdateArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Semestres.
     * @param {SemestreDeleteManyArgs} args - Arguments to filter Semestres to delete.
     * @example
     * // Delete a few Semestres
     * const { count } = await prisma.semestre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SemestreDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semestres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Semestres
     * const semestre = await prisma.semestre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SemestreUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Semestre.
     * @param {SemestreUpsertArgs} args - Arguments to update or create a Semestre.
     * @example
     * // Update or create a Semestre
     * const semestre = await prisma.semestre.upsert({
     *   create: {
     *     // ... data to create a Semestre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Semestre we want to update
     *   }
     * })
    **/
    upsert<T extends SemestreUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreUpsertArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Semestres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreCountArgs} args - Arguments to filter Semestres to count.
     * @example
     * // Count the number of Semestres
     * const count = await prisma.semestre.count({
     *   where: {
     *     // ... the filter for the Semestres we want to count
     *   }
     * })
    **/
    count<T extends SemestreCountArgs>(
      args?: Subset<T, SemestreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemestreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Semestre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemestreAggregateArgs>(args: Subset<T, SemestreAggregateArgs>): Prisma.PrismaPromise<GetSemestreAggregateType<T>>

    /**
     * Group by Semestre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemestreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemestreGroupByArgs['orderBy'] }
        : { orderBy?: SemestreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemestreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemestreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Semestre model
   */
  readonly fields: SemestreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Semestre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SemestreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    uniteEnseignement<T extends Semestre$uniteEnseignementArgs<ExtArgs> = {}>(args?: Subset<T, Semestre$uniteEnseignementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'findMany'> | Null>;

    Classe<T extends Semestre$ClasseArgs<ExtArgs> = {}>(args?: Subset<T, Semestre$ClasseArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Semestre model
   */ 
  interface SemestreFieldRefs {
    readonly id: FieldRef<"Semestre", 'Int'>
    readonly createdAt: FieldRef<"Semestre", 'DateTime'>
    readonly updatedAt: FieldRef<"Semestre", 'DateTime'>
    readonly numero: FieldRef<"Semestre", 'Int'>
    readonly grade: FieldRef<"Semestre", 'TypeDiplome'>
    readonly dateDebut: FieldRef<"Semestre", 'DateTime'>
    readonly dateFin: FieldRef<"Semestre", 'DateTime'>
    readonly nombreSemaine: FieldRef<"Semestre", 'Int'>
    readonly classeId: FieldRef<"Semestre", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Semestre findUnique
   */
  export type SemestreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestre to fetch.
     */
    where: SemestreWhereUniqueInput
  }


  /**
   * Semestre findUniqueOrThrow
   */
  export type SemestreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestre to fetch.
     */
    where: SemestreWhereUniqueInput
  }


  /**
   * Semestre findFirst
   */
  export type SemestreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestre to fetch.
     */
    where?: SemestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semestres to fetch.
     */
    orderBy?: SemestreOrderByWithRelationInput | SemestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Semestres.
     */
    cursor?: SemestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Semestres.
     */
    distinct?: SemestreScalarFieldEnum | SemestreScalarFieldEnum[]
  }


  /**
   * Semestre findFirstOrThrow
   */
  export type SemestreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestre to fetch.
     */
    where?: SemestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semestres to fetch.
     */
    orderBy?: SemestreOrderByWithRelationInput | SemestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Semestres.
     */
    cursor?: SemestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Semestres.
     */
    distinct?: SemestreScalarFieldEnum | SemestreScalarFieldEnum[]
  }


  /**
   * Semestre findMany
   */
  export type SemestreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestres to fetch.
     */
    where?: SemestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semestres to fetch.
     */
    orderBy?: SemestreOrderByWithRelationInput | SemestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Semestres.
     */
    cursor?: SemestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semestres.
     */
    skip?: number
    distinct?: SemestreScalarFieldEnum | SemestreScalarFieldEnum[]
  }


  /**
   * Semestre create
   */
  export type SemestreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * The data needed to create a Semestre.
     */
    data: XOR<SemestreCreateInput, SemestreUncheckedCreateInput>
  }


  /**
   * Semestre createMany
   */
  export type SemestreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Semestres.
     */
    data: SemestreCreateManyInput | SemestreCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Semestre update
   */
  export type SemestreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * The data needed to update a Semestre.
     */
    data: XOR<SemestreUpdateInput, SemestreUncheckedUpdateInput>
    /**
     * Choose, which Semestre to update.
     */
    where: SemestreWhereUniqueInput
  }


  /**
   * Semestre updateMany
   */
  export type SemestreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Semestres.
     */
    data: XOR<SemestreUpdateManyMutationInput, SemestreUncheckedUpdateManyInput>
    /**
     * Filter which Semestres to update
     */
    where?: SemestreWhereInput
  }


  /**
   * Semestre upsert
   */
  export type SemestreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * The filter to search for the Semestre to update in case it exists.
     */
    where: SemestreWhereUniqueInput
    /**
     * In case the Semestre found by the `where` argument doesn't exist, create a new Semestre with this data.
     */
    create: XOR<SemestreCreateInput, SemestreUncheckedCreateInput>
    /**
     * In case the Semestre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemestreUpdateInput, SemestreUncheckedUpdateInput>
  }


  /**
   * Semestre delete
   */
  export type SemestreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter which Semestre to delete.
     */
    where: SemestreWhereUniqueInput
  }


  /**
   * Semestre deleteMany
   */
  export type SemestreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Semestres to delete
     */
    where?: SemestreWhereInput
  }


  /**
   * Semestre.uniteEnseignement
   */
  export type Semestre$uniteEnseignementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    where?: UniteEnseignementWhereInput
    orderBy?: UniteEnseignementOrderByWithRelationInput | UniteEnseignementOrderByWithRelationInput[]
    cursor?: UniteEnseignementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UniteEnseignementScalarFieldEnum | UniteEnseignementScalarFieldEnum[]
  }


  /**
   * Semestre.Classe
   */
  export type Semestre$ClasseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    where?: ClasseWhereInput
  }


  /**
   * Semestre without action
   */
  export type SemestreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
  }



  /**
   * Model UniteEnseignement
   */

  export type AggregateUniteEnseignement = {
    _count: UniteEnseignementCountAggregateOutputType | null
    _avg: UniteEnseignementAvgAggregateOutputType | null
    _sum: UniteEnseignementSumAggregateOutputType | null
    _min: UniteEnseignementMinAggregateOutputType | null
    _max: UniteEnseignementMaxAggregateOutputType | null
  }

  export type UniteEnseignementAvgAggregateOutputType = {
    id: number | null
    numero: number | null
    credit: number | null
    semestreId: number | null
  }

  export type UniteEnseignementSumAggregateOutputType = {
    id: number | null
    numero: number | null
    credit: number | null
    semestreId: number | null
  }

  export type UniteEnseignementMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    nom: string | null
    numero: number | null
    credit: number | null
    semestreId: number | null
  }

  export type UniteEnseignementMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    nom: string | null
    numero: number | null
    credit: number | null
    semestreId: number | null
  }

  export type UniteEnseignementCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    code: number
    nom: number
    numero: number
    credit: number
    semestreId: number
    _all: number
  }


  export type UniteEnseignementAvgAggregateInputType = {
    id?: true
    numero?: true
    credit?: true
    semestreId?: true
  }

  export type UniteEnseignementSumAggregateInputType = {
    id?: true
    numero?: true
    credit?: true
    semestreId?: true
  }

  export type UniteEnseignementMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    nom?: true
    numero?: true
    credit?: true
    semestreId?: true
  }

  export type UniteEnseignementMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    nom?: true
    numero?: true
    credit?: true
    semestreId?: true
  }

  export type UniteEnseignementCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    nom?: true
    numero?: true
    credit?: true
    semestreId?: true
    _all?: true
  }

  export type UniteEnseignementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniteEnseignement to aggregate.
     */
    where?: UniteEnseignementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniteEnseignements to fetch.
     */
    orderBy?: UniteEnseignementOrderByWithRelationInput | UniteEnseignementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UniteEnseignementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniteEnseignements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniteEnseignements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UniteEnseignements
    **/
    _count?: true | UniteEnseignementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UniteEnseignementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UniteEnseignementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniteEnseignementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniteEnseignementMaxAggregateInputType
  }

  export type GetUniteEnseignementAggregateType<T extends UniteEnseignementAggregateArgs> = {
        [P in keyof T & keyof AggregateUniteEnseignement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniteEnseignement[P]>
      : GetScalarType<T[P], AggregateUniteEnseignement[P]>
  }




  export type UniteEnseignementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniteEnseignementWhereInput
    orderBy?: UniteEnseignementOrderByWithAggregationInput | UniteEnseignementOrderByWithAggregationInput[]
    by: UniteEnseignementScalarFieldEnum[] | UniteEnseignementScalarFieldEnum
    having?: UniteEnseignementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniteEnseignementCountAggregateInputType | true
    _avg?: UniteEnseignementAvgAggregateInputType
    _sum?: UniteEnseignementSumAggregateInputType
    _min?: UniteEnseignementMinAggregateInputType
    _max?: UniteEnseignementMaxAggregateInputType
  }

  export type UniteEnseignementGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    code: string
    nom: string
    numero: number
    credit: number
    semestreId: number | null
    _count: UniteEnseignementCountAggregateOutputType | null
    _avg: UniteEnseignementAvgAggregateOutputType | null
    _sum: UniteEnseignementSumAggregateOutputType | null
    _min: UniteEnseignementMinAggregateOutputType | null
    _max: UniteEnseignementMaxAggregateOutputType | null
  }

  type GetUniteEnseignementGroupByPayload<T extends UniteEnseignementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UniteEnseignementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniteEnseignementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniteEnseignementGroupByOutputType[P]>
            : GetScalarType<T[P], UniteEnseignementGroupByOutputType[P]>
        }
      >
    >


  export type UniteEnseignementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    nom?: boolean
    numero?: boolean
    credit?: boolean
    semestreId?: boolean
    semestre?: boolean | UniteEnseignement$semestreArgs<ExtArgs>
    matieres?: boolean | UniteEnseignement$matieresArgs<ExtArgs>
    _count?: boolean | UniteEnseignementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uniteEnseignement"]>

  export type UniteEnseignementSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    nom?: boolean
    numero?: boolean
    credit?: boolean
    semestreId?: boolean
  }

  export type UniteEnseignementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semestre?: boolean | UniteEnseignement$semestreArgs<ExtArgs>
    matieres?: boolean | UniteEnseignement$matieresArgs<ExtArgs>
    _count?: boolean | UniteEnseignementCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UniteEnseignementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UniteEnseignement"
    objects: {
      semestre: Prisma.$SemestrePayload<ExtArgs> | null
      matieres: Prisma.$MatierePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      code: string
      nom: string
      numero: number
      credit: number
      semestreId: number | null
    }, ExtArgs["result"]["uniteEnseignement"]>
    composites: {}
  }


  type UniteEnseignementGetPayload<S extends boolean | null | undefined | UniteEnseignementDefaultArgs> = $Result.GetResult<Prisma.$UniteEnseignementPayload, S>

  type UniteEnseignementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UniteEnseignementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UniteEnseignementCountAggregateInputType | true
    }

  export interface UniteEnseignementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UniteEnseignement'], meta: { name: 'UniteEnseignement' } }
    /**
     * Find zero or one UniteEnseignement that matches the filter.
     * @param {UniteEnseignementFindUniqueArgs} args - Arguments to find a UniteEnseignement
     * @example
     * // Get one UniteEnseignement
     * const uniteEnseignement = await prisma.uniteEnseignement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UniteEnseignementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UniteEnseignementFindUniqueArgs<ExtArgs>>
    ): Prisma__UniteEnseignementClient<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UniteEnseignement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UniteEnseignementFindUniqueOrThrowArgs} args - Arguments to find a UniteEnseignement
     * @example
     * // Get one UniteEnseignement
     * const uniteEnseignement = await prisma.uniteEnseignement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UniteEnseignementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UniteEnseignementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UniteEnseignementClient<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UniteEnseignement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniteEnseignementFindFirstArgs} args - Arguments to find a UniteEnseignement
     * @example
     * // Get one UniteEnseignement
     * const uniteEnseignement = await prisma.uniteEnseignement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UniteEnseignementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UniteEnseignementFindFirstArgs<ExtArgs>>
    ): Prisma__UniteEnseignementClient<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UniteEnseignement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniteEnseignementFindFirstOrThrowArgs} args - Arguments to find a UniteEnseignement
     * @example
     * // Get one UniteEnseignement
     * const uniteEnseignement = await prisma.uniteEnseignement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UniteEnseignementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UniteEnseignementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UniteEnseignementClient<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UniteEnseignements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniteEnseignementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UniteEnseignements
     * const uniteEnseignements = await prisma.uniteEnseignement.findMany()
     * 
     * // Get first 10 UniteEnseignements
     * const uniteEnseignements = await prisma.uniteEnseignement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uniteEnseignementWithIdOnly = await prisma.uniteEnseignement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UniteEnseignementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UniteEnseignementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UniteEnseignement.
     * @param {UniteEnseignementCreateArgs} args - Arguments to create a UniteEnseignement.
     * @example
     * // Create one UniteEnseignement
     * const UniteEnseignement = await prisma.uniteEnseignement.create({
     *   data: {
     *     // ... data to create a UniteEnseignement
     *   }
     * })
     * 
    **/
    create<T extends UniteEnseignementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UniteEnseignementCreateArgs<ExtArgs>>
    ): Prisma__UniteEnseignementClient<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UniteEnseignements.
     *     @param {UniteEnseignementCreateManyArgs} args - Arguments to create many UniteEnseignements.
     *     @example
     *     // Create many UniteEnseignements
     *     const uniteEnseignement = await prisma.uniteEnseignement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UniteEnseignementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UniteEnseignementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UniteEnseignement.
     * @param {UniteEnseignementDeleteArgs} args - Arguments to delete one UniteEnseignement.
     * @example
     * // Delete one UniteEnseignement
     * const UniteEnseignement = await prisma.uniteEnseignement.delete({
     *   where: {
     *     // ... filter to delete one UniteEnseignement
     *   }
     * })
     * 
    **/
    delete<T extends UniteEnseignementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UniteEnseignementDeleteArgs<ExtArgs>>
    ): Prisma__UniteEnseignementClient<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UniteEnseignement.
     * @param {UniteEnseignementUpdateArgs} args - Arguments to update one UniteEnseignement.
     * @example
     * // Update one UniteEnseignement
     * const uniteEnseignement = await prisma.uniteEnseignement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UniteEnseignementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UniteEnseignementUpdateArgs<ExtArgs>>
    ): Prisma__UniteEnseignementClient<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UniteEnseignements.
     * @param {UniteEnseignementDeleteManyArgs} args - Arguments to filter UniteEnseignements to delete.
     * @example
     * // Delete a few UniteEnseignements
     * const { count } = await prisma.uniteEnseignement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UniteEnseignementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UniteEnseignementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UniteEnseignements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniteEnseignementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UniteEnseignements
     * const uniteEnseignement = await prisma.uniteEnseignement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UniteEnseignementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UniteEnseignementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UniteEnseignement.
     * @param {UniteEnseignementUpsertArgs} args - Arguments to update or create a UniteEnseignement.
     * @example
     * // Update or create a UniteEnseignement
     * const uniteEnseignement = await prisma.uniteEnseignement.upsert({
     *   create: {
     *     // ... data to create a UniteEnseignement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UniteEnseignement we want to update
     *   }
     * })
    **/
    upsert<T extends UniteEnseignementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UniteEnseignementUpsertArgs<ExtArgs>>
    ): Prisma__UniteEnseignementClient<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UniteEnseignements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniteEnseignementCountArgs} args - Arguments to filter UniteEnseignements to count.
     * @example
     * // Count the number of UniteEnseignements
     * const count = await prisma.uniteEnseignement.count({
     *   where: {
     *     // ... the filter for the UniteEnseignements we want to count
     *   }
     * })
    **/
    count<T extends UniteEnseignementCountArgs>(
      args?: Subset<T, UniteEnseignementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniteEnseignementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UniteEnseignement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniteEnseignementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniteEnseignementAggregateArgs>(args: Subset<T, UniteEnseignementAggregateArgs>): Prisma.PrismaPromise<GetUniteEnseignementAggregateType<T>>

    /**
     * Group by UniteEnseignement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniteEnseignementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UniteEnseignementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UniteEnseignementGroupByArgs['orderBy'] }
        : { orderBy?: UniteEnseignementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UniteEnseignementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniteEnseignementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UniteEnseignement model
   */
  readonly fields: UniteEnseignementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UniteEnseignement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UniteEnseignementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    semestre<T extends UniteEnseignement$semestreArgs<ExtArgs> = {}>(args?: Subset<T, UniteEnseignement$semestreArgs<ExtArgs>>): Prisma__SemestreClient<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    matieres<T extends UniteEnseignement$matieresArgs<ExtArgs> = {}>(args?: Subset<T, UniteEnseignement$matieresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UniteEnseignement model
   */ 
  interface UniteEnseignementFieldRefs {
    readonly id: FieldRef<"UniteEnseignement", 'Int'>
    readonly createdAt: FieldRef<"UniteEnseignement", 'DateTime'>
    readonly updatedAt: FieldRef<"UniteEnseignement", 'DateTime'>
    readonly code: FieldRef<"UniteEnseignement", 'String'>
    readonly nom: FieldRef<"UniteEnseignement", 'String'>
    readonly numero: FieldRef<"UniteEnseignement", 'Int'>
    readonly credit: FieldRef<"UniteEnseignement", 'Int'>
    readonly semestreId: FieldRef<"UniteEnseignement", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UniteEnseignement findUnique
   */
  export type UniteEnseignementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which UniteEnseignement to fetch.
     */
    where: UniteEnseignementWhereUniqueInput
  }


  /**
   * UniteEnseignement findUniqueOrThrow
   */
  export type UniteEnseignementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which UniteEnseignement to fetch.
     */
    where: UniteEnseignementWhereUniqueInput
  }


  /**
   * UniteEnseignement findFirst
   */
  export type UniteEnseignementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which UniteEnseignement to fetch.
     */
    where?: UniteEnseignementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniteEnseignements to fetch.
     */
    orderBy?: UniteEnseignementOrderByWithRelationInput | UniteEnseignementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniteEnseignements.
     */
    cursor?: UniteEnseignementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniteEnseignements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniteEnseignements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniteEnseignements.
     */
    distinct?: UniteEnseignementScalarFieldEnum | UniteEnseignementScalarFieldEnum[]
  }


  /**
   * UniteEnseignement findFirstOrThrow
   */
  export type UniteEnseignementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which UniteEnseignement to fetch.
     */
    where?: UniteEnseignementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniteEnseignements to fetch.
     */
    orderBy?: UniteEnseignementOrderByWithRelationInput | UniteEnseignementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniteEnseignements.
     */
    cursor?: UniteEnseignementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniteEnseignements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniteEnseignements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniteEnseignements.
     */
    distinct?: UniteEnseignementScalarFieldEnum | UniteEnseignementScalarFieldEnum[]
  }


  /**
   * UniteEnseignement findMany
   */
  export type UniteEnseignementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which UniteEnseignements to fetch.
     */
    where?: UniteEnseignementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniteEnseignements to fetch.
     */
    orderBy?: UniteEnseignementOrderByWithRelationInput | UniteEnseignementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UniteEnseignements.
     */
    cursor?: UniteEnseignementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniteEnseignements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniteEnseignements.
     */
    skip?: number
    distinct?: UniteEnseignementScalarFieldEnum | UniteEnseignementScalarFieldEnum[]
  }


  /**
   * UniteEnseignement create
   */
  export type UniteEnseignementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    /**
     * The data needed to create a UniteEnseignement.
     */
    data: XOR<UniteEnseignementCreateInput, UniteEnseignementUncheckedCreateInput>
  }


  /**
   * UniteEnseignement createMany
   */
  export type UniteEnseignementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UniteEnseignements.
     */
    data: UniteEnseignementCreateManyInput | UniteEnseignementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UniteEnseignement update
   */
  export type UniteEnseignementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    /**
     * The data needed to update a UniteEnseignement.
     */
    data: XOR<UniteEnseignementUpdateInput, UniteEnseignementUncheckedUpdateInput>
    /**
     * Choose, which UniteEnseignement to update.
     */
    where: UniteEnseignementWhereUniqueInput
  }


  /**
   * UniteEnseignement updateMany
   */
  export type UniteEnseignementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UniteEnseignements.
     */
    data: XOR<UniteEnseignementUpdateManyMutationInput, UniteEnseignementUncheckedUpdateManyInput>
    /**
     * Filter which UniteEnseignements to update
     */
    where?: UniteEnseignementWhereInput
  }


  /**
   * UniteEnseignement upsert
   */
  export type UniteEnseignementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    /**
     * The filter to search for the UniteEnseignement to update in case it exists.
     */
    where: UniteEnseignementWhereUniqueInput
    /**
     * In case the UniteEnseignement found by the `where` argument doesn't exist, create a new UniteEnseignement with this data.
     */
    create: XOR<UniteEnseignementCreateInput, UniteEnseignementUncheckedCreateInput>
    /**
     * In case the UniteEnseignement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UniteEnseignementUpdateInput, UniteEnseignementUncheckedUpdateInput>
  }


  /**
   * UniteEnseignement delete
   */
  export type UniteEnseignementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
    /**
     * Filter which UniteEnseignement to delete.
     */
    where: UniteEnseignementWhereUniqueInput
  }


  /**
   * UniteEnseignement deleteMany
   */
  export type UniteEnseignementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniteEnseignements to delete
     */
    where?: UniteEnseignementWhereInput
  }


  /**
   * UniteEnseignement.semestre
   */
  export type UniteEnseignement$semestreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    where?: SemestreWhereInput
  }


  /**
   * UniteEnseignement.matieres
   */
  export type UniteEnseignement$matieresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    where?: MatiereWhereInput
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    cursor?: MatiereWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatiereScalarFieldEnum | MatiereScalarFieldEnum[]
  }


  /**
   * UniteEnseignement without action
   */
  export type UniteEnseignementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniteEnseignement
     */
    select?: UniteEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniteEnseignementInclude<ExtArgs> | null
  }



  /**
   * Model Matiere
   */

  export type AggregateMatiere = {
    _count: MatiereCountAggregateOutputType | null
    _avg: MatiereAvgAggregateOutputType | null
    _sum: MatiereSumAggregateOutputType | null
    _min: MatiereMinAggregateOutputType | null
    _max: MatiereMaxAggregateOutputType | null
  }

  export type MatiereAvgAggregateOutputType = {
    id: number | null
    credit: number | null
    coefficient: number | null
    nbHeure: number | null
    uniteEnseignementId: number | null
  }

  export type MatiereSumAggregateOutputType = {
    id: number | null
    credit: number | null
    coefficient: number | null
    nbHeure: number | null
    uniteEnseignementId: number | null
  }

  export type MatiereMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    nom: string | null
    credit: number | null
    coefficient: number | null
    nbHeure: number | null
    uniteEnseignementId: number | null
  }

  export type MatiereMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    nom: string | null
    credit: number | null
    coefficient: number | null
    nbHeure: number | null
    uniteEnseignementId: number | null
  }

  export type MatiereCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    code: number
    nom: number
    credit: number
    coefficient: number
    nbHeure: number
    uniteEnseignementId: number
    _all: number
  }


  export type MatiereAvgAggregateInputType = {
    id?: true
    credit?: true
    coefficient?: true
    nbHeure?: true
    uniteEnseignementId?: true
  }

  export type MatiereSumAggregateInputType = {
    id?: true
    credit?: true
    coefficient?: true
    nbHeure?: true
    uniteEnseignementId?: true
  }

  export type MatiereMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    nom?: true
    credit?: true
    coefficient?: true
    nbHeure?: true
    uniteEnseignementId?: true
  }

  export type MatiereMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    nom?: true
    credit?: true
    coefficient?: true
    nbHeure?: true
    uniteEnseignementId?: true
  }

  export type MatiereCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    nom?: true
    credit?: true
    coefficient?: true
    nbHeure?: true
    uniteEnseignementId?: true
    _all?: true
  }

  export type MatiereAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matiere to aggregate.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matieres
    **/
    _count?: true | MatiereCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatiereAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatiereSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatiereMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatiereMaxAggregateInputType
  }

  export type GetMatiereAggregateType<T extends MatiereAggregateArgs> = {
        [P in keyof T & keyof AggregateMatiere]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatiere[P]>
      : GetScalarType<T[P], AggregateMatiere[P]>
  }




  export type MatiereGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatiereWhereInput
    orderBy?: MatiereOrderByWithAggregationInput | MatiereOrderByWithAggregationInput[]
    by: MatiereScalarFieldEnum[] | MatiereScalarFieldEnum
    having?: MatiereScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatiereCountAggregateInputType | true
    _avg?: MatiereAvgAggregateInputType
    _sum?: MatiereSumAggregateInputType
    _min?: MatiereMinAggregateInputType
    _max?: MatiereMaxAggregateInputType
  }

  export type MatiereGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    code: string
    nom: string
    credit: number
    coefficient: number
    nbHeure: number | null
    uniteEnseignementId: number
    _count: MatiereCountAggregateOutputType | null
    _avg: MatiereAvgAggregateOutputType | null
    _sum: MatiereSumAggregateOutputType | null
    _min: MatiereMinAggregateOutputType | null
    _max: MatiereMaxAggregateOutputType | null
  }

  type GetMatiereGroupByPayload<T extends MatiereGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatiereGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatiereGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatiereGroupByOutputType[P]>
            : GetScalarType<T[P], MatiereGroupByOutputType[P]>
        }
      >
    >


  export type MatiereSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    nom?: boolean
    credit?: boolean
    coefficient?: boolean
    nbHeure?: boolean
    uniteEnseignementId?: boolean
    cours?: boolean | Matiere$coursArgs<ExtArgs>
    uniteEnseignement?: boolean | UniteEnseignementDefaultArgs<ExtArgs>
    _count?: boolean | MatiereCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matiere"]>

  export type MatiereSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    nom?: boolean
    credit?: boolean
    coefficient?: boolean
    nbHeure?: boolean
    uniteEnseignementId?: boolean
  }

  export type MatiereInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cours?: boolean | Matiere$coursArgs<ExtArgs>
    uniteEnseignement?: boolean | UniteEnseignementDefaultArgs<ExtArgs>
    _count?: boolean | MatiereCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MatierePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Matiere"
    objects: {
      cours: Prisma.$CoursPayload<ExtArgs>[]
      uniteEnseignement: Prisma.$UniteEnseignementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      code: string
      nom: string
      credit: number
      coefficient: number
      nbHeure: number | null
      uniteEnseignementId: number
    }, ExtArgs["result"]["matiere"]>
    composites: {}
  }


  type MatiereGetPayload<S extends boolean | null | undefined | MatiereDefaultArgs> = $Result.GetResult<Prisma.$MatierePayload, S>

  type MatiereCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatiereFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatiereCountAggregateInputType | true
    }

  export interface MatiereDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Matiere'], meta: { name: 'Matiere' } }
    /**
     * Find zero or one Matiere that matches the filter.
     * @param {MatiereFindUniqueArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MatiereFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereFindUniqueArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Matiere that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MatiereFindUniqueOrThrowArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MatiereFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Matiere that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereFindFirstArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MatiereFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereFindFirstArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Matiere that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereFindFirstOrThrowArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MatiereFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Matieres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matieres
     * const matieres = await prisma.matiere.findMany()
     * 
     * // Get first 10 Matieres
     * const matieres = await prisma.matiere.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matiereWithIdOnly = await prisma.matiere.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MatiereFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Matiere.
     * @param {MatiereCreateArgs} args - Arguments to create a Matiere.
     * @example
     * // Create one Matiere
     * const Matiere = await prisma.matiere.create({
     *   data: {
     *     // ... data to create a Matiere
     *   }
     * })
     * 
    **/
    create<T extends MatiereCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereCreateArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Matieres.
     *     @param {MatiereCreateManyArgs} args - Arguments to create many Matieres.
     *     @example
     *     // Create many Matieres
     *     const matiere = await prisma.matiere.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MatiereCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Matiere.
     * @param {MatiereDeleteArgs} args - Arguments to delete one Matiere.
     * @example
     * // Delete one Matiere
     * const Matiere = await prisma.matiere.delete({
     *   where: {
     *     // ... filter to delete one Matiere
     *   }
     * })
     * 
    **/
    delete<T extends MatiereDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereDeleteArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Matiere.
     * @param {MatiereUpdateArgs} args - Arguments to update one Matiere.
     * @example
     * // Update one Matiere
     * const matiere = await prisma.matiere.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MatiereUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereUpdateArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Matieres.
     * @param {MatiereDeleteManyArgs} args - Arguments to filter Matieres to delete.
     * @example
     * // Delete a few Matieres
     * const { count } = await prisma.matiere.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MatiereDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matieres
     * const matiere = await prisma.matiere.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MatiereUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Matiere.
     * @param {MatiereUpsertArgs} args - Arguments to update or create a Matiere.
     * @example
     * // Update or create a Matiere
     * const matiere = await prisma.matiere.upsert({
     *   create: {
     *     // ... data to create a Matiere
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matiere we want to update
     *   }
     * })
    **/
    upsert<T extends MatiereUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereUpsertArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Matieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereCountArgs} args - Arguments to filter Matieres to count.
     * @example
     * // Count the number of Matieres
     * const count = await prisma.matiere.count({
     *   where: {
     *     // ... the filter for the Matieres we want to count
     *   }
     * })
    **/
    count<T extends MatiereCountArgs>(
      args?: Subset<T, MatiereCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatiereCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Matiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatiereAggregateArgs>(args: Subset<T, MatiereAggregateArgs>): Prisma.PrismaPromise<GetMatiereAggregateType<T>>

    /**
     * Group by Matiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatiereGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatiereGroupByArgs['orderBy'] }
        : { orderBy?: MatiereGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatiereGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatiereGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Matiere model
   */
  readonly fields: MatiereFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Matiere.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatiereClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cours<T extends Matiere$coursArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$coursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findMany'> | Null>;

    uniteEnseignement<T extends UniteEnseignementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniteEnseignementDefaultArgs<ExtArgs>>): Prisma__UniteEnseignementClient<$Result.GetResult<Prisma.$UniteEnseignementPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Matiere model
   */ 
  interface MatiereFieldRefs {
    readonly id: FieldRef<"Matiere", 'Int'>
    readonly createdAt: FieldRef<"Matiere", 'DateTime'>
    readonly updatedAt: FieldRef<"Matiere", 'DateTime'>
    readonly code: FieldRef<"Matiere", 'String'>
    readonly nom: FieldRef<"Matiere", 'String'>
    readonly credit: FieldRef<"Matiere", 'Int'>
    readonly coefficient: FieldRef<"Matiere", 'Int'>
    readonly nbHeure: FieldRef<"Matiere", 'Int'>
    readonly uniteEnseignementId: FieldRef<"Matiere", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Matiere findUnique
   */
  export type MatiereFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where: MatiereWhereUniqueInput
  }


  /**
   * Matiere findUniqueOrThrow
   */
  export type MatiereFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where: MatiereWhereUniqueInput
  }


  /**
   * Matiere findFirst
   */
  export type MatiereFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matieres.
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matieres.
     */
    distinct?: MatiereScalarFieldEnum | MatiereScalarFieldEnum[]
  }


  /**
   * Matiere findFirstOrThrow
   */
  export type MatiereFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matieres.
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matieres.
     */
    distinct?: MatiereScalarFieldEnum | MatiereScalarFieldEnum[]
  }


  /**
   * Matiere findMany
   */
  export type MatiereFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matieres to fetch.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matieres.
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    distinct?: MatiereScalarFieldEnum | MatiereScalarFieldEnum[]
  }


  /**
   * Matiere create
   */
  export type MatiereCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * The data needed to create a Matiere.
     */
    data: XOR<MatiereCreateInput, MatiereUncheckedCreateInput>
  }


  /**
   * Matiere createMany
   */
  export type MatiereCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matieres.
     */
    data: MatiereCreateManyInput | MatiereCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Matiere update
   */
  export type MatiereUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * The data needed to update a Matiere.
     */
    data: XOR<MatiereUpdateInput, MatiereUncheckedUpdateInput>
    /**
     * Choose, which Matiere to update.
     */
    where: MatiereWhereUniqueInput
  }


  /**
   * Matiere updateMany
   */
  export type MatiereUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matieres.
     */
    data: XOR<MatiereUpdateManyMutationInput, MatiereUncheckedUpdateManyInput>
    /**
     * Filter which Matieres to update
     */
    where?: MatiereWhereInput
  }


  /**
   * Matiere upsert
   */
  export type MatiereUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * The filter to search for the Matiere to update in case it exists.
     */
    where: MatiereWhereUniqueInput
    /**
     * In case the Matiere found by the `where` argument doesn't exist, create a new Matiere with this data.
     */
    create: XOR<MatiereCreateInput, MatiereUncheckedCreateInput>
    /**
     * In case the Matiere was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatiereUpdateInput, MatiereUncheckedUpdateInput>
  }


  /**
   * Matiere delete
   */
  export type MatiereDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter which Matiere to delete.
     */
    where: MatiereWhereUniqueInput
  }


  /**
   * Matiere deleteMany
   */
  export type MatiereDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matieres to delete
     */
    where?: MatiereWhereInput
  }


  /**
   * Matiere.cours
   */
  export type Matiere$coursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    where?: CoursWhereInput
    orderBy?: CoursOrderByWithRelationInput | CoursOrderByWithRelationInput[]
    cursor?: CoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursScalarFieldEnum | CoursScalarFieldEnum[]
  }


  /**
   * Matiere without action
   */
  export type MatiereDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
  }



  /**
   * Model Etablissement
   */

  export type AggregateEtablissement = {
    _count: EtablissementCountAggregateOutputType | null
    _avg: EtablissementAvgAggregateOutputType | null
    _sum: EtablissementSumAggregateOutputType | null
    _min: EtablissementMinAggregateOutputType | null
    _max: EtablissementMaxAggregateOutputType | null
  }

  export type EtablissementAvgAggregateOutputType = {
    id: number | null
    adresseId: number | null
    contactId: number | null
  }

  export type EtablissementSumAggregateOutputType = {
    id: number | null
    adresseId: number | null
    contactId: number | null
  }

  export type EtablissementMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    matricule: string | null
    sigle: string | null
    dateCreation: Date | null
    logo: string | null
    anneeEnCours: string | null
    adresseId: number | null
    contactId: number | null
  }

  export type EtablissementMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    matricule: string | null
    sigle: string | null
    dateCreation: Date | null
    logo: string | null
    anneeEnCours: string | null
    adresseId: number | null
    contactId: number | null
  }

  export type EtablissementCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    matricule: number
    sigle: number
    dateCreation: number
    logo: number
    anneeEnCours: number
    adresseId: number
    contactId: number
    _all: number
  }


  export type EtablissementAvgAggregateInputType = {
    id?: true
    adresseId?: true
    contactId?: true
  }

  export type EtablissementSumAggregateInputType = {
    id?: true
    adresseId?: true
    contactId?: true
  }

  export type EtablissementMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    matricule?: true
    sigle?: true
    dateCreation?: true
    logo?: true
    anneeEnCours?: true
    adresseId?: true
    contactId?: true
  }

  export type EtablissementMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    matricule?: true
    sigle?: true
    dateCreation?: true
    logo?: true
    anneeEnCours?: true
    adresseId?: true
    contactId?: true
  }

  export type EtablissementCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    matricule?: true
    sigle?: true
    dateCreation?: true
    logo?: true
    anneeEnCours?: true
    adresseId?: true
    contactId?: true
    _all?: true
  }

  export type EtablissementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etablissement to aggregate.
     */
    where?: EtablissementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etablissements to fetch.
     */
    orderBy?: EtablissementOrderByWithRelationInput | EtablissementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtablissementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etablissements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etablissements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Etablissements
    **/
    _count?: true | EtablissementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtablissementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtablissementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtablissementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtablissementMaxAggregateInputType
  }

  export type GetEtablissementAggregateType<T extends EtablissementAggregateArgs> = {
        [P in keyof T & keyof AggregateEtablissement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtablissement[P]>
      : GetScalarType<T[P], AggregateEtablissement[P]>
  }




  export type EtablissementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtablissementWhereInput
    orderBy?: EtablissementOrderByWithAggregationInput | EtablissementOrderByWithAggregationInput[]
    by: EtablissementScalarFieldEnum[] | EtablissementScalarFieldEnum
    having?: EtablissementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtablissementCountAggregateInputType | true
    _avg?: EtablissementAvgAggregateInputType
    _sum?: EtablissementSumAggregateInputType
    _min?: EtablissementMinAggregateInputType
    _max?: EtablissementMaxAggregateInputType
  }

  export type EtablissementGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    matricule: string | null
    sigle: string | null
    dateCreation: Date | null
    logo: string | null
    anneeEnCours: string | null
    adresseId: number | null
    contactId: number | null
    _count: EtablissementCountAggregateOutputType | null
    _avg: EtablissementAvgAggregateOutputType | null
    _sum: EtablissementSumAggregateOutputType | null
    _min: EtablissementMinAggregateOutputType | null
    _max: EtablissementMaxAggregateOutputType | null
  }

  type GetEtablissementGroupByPayload<T extends EtablissementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtablissementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtablissementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtablissementGroupByOutputType[P]>
            : GetScalarType<T[P], EtablissementGroupByOutputType[P]>
        }
      >
    >


  export type EtablissementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    matricule?: boolean
    sigle?: boolean
    dateCreation?: boolean
    logo?: boolean
    anneeEnCours?: boolean
    adresseId?: boolean
    contactId?: boolean
    adresse?: boolean | Etablissement$adresseArgs<ExtArgs>
    contact?: boolean | Etablissement$contactArgs<ExtArgs>
    utilisateurs?: boolean | Etablissement$utilisateursArgs<ExtArgs>
    domaines?: boolean | Etablissement$domainesArgs<ExtArgs>
    classes?: boolean | Etablissement$classesArgs<ExtArgs>
    salle?: boolean | Etablissement$salleArgs<ExtArgs>
    _count?: boolean | EtablissementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etablissement"]>

  export type EtablissementSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    matricule?: boolean
    sigle?: boolean
    dateCreation?: boolean
    logo?: boolean
    anneeEnCours?: boolean
    adresseId?: boolean
    contactId?: boolean
  }

  export type EtablissementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adresse?: boolean | Etablissement$adresseArgs<ExtArgs>
    contact?: boolean | Etablissement$contactArgs<ExtArgs>
    utilisateurs?: boolean | Etablissement$utilisateursArgs<ExtArgs>
    domaines?: boolean | Etablissement$domainesArgs<ExtArgs>
    classes?: boolean | Etablissement$classesArgs<ExtArgs>
    salle?: boolean | Etablissement$salleArgs<ExtArgs>
    _count?: boolean | EtablissementCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EtablissementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Etablissement"
    objects: {
      adresse: Prisma.$AdressePayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
      utilisateurs: Prisma.$UtilisateurPayload<ExtArgs>[]
      domaines: Prisma.$DomainePayload<ExtArgs>[]
      classes: Prisma.$ClassePayload<ExtArgs>[]
      salle: Prisma.$SallePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      matricule: string | null
      sigle: string | null
      dateCreation: Date | null
      logo: string | null
      anneeEnCours: string | null
      adresseId: number | null
      contactId: number | null
    }, ExtArgs["result"]["etablissement"]>
    composites: {}
  }


  type EtablissementGetPayload<S extends boolean | null | undefined | EtablissementDefaultArgs> = $Result.GetResult<Prisma.$EtablissementPayload, S>

  type EtablissementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EtablissementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EtablissementCountAggregateInputType | true
    }

  export interface EtablissementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Etablissement'], meta: { name: 'Etablissement' } }
    /**
     * Find zero or one Etablissement that matches the filter.
     * @param {EtablissementFindUniqueArgs} args - Arguments to find a Etablissement
     * @example
     * // Get one Etablissement
     * const etablissement = await prisma.etablissement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EtablissementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EtablissementFindUniqueArgs<ExtArgs>>
    ): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Etablissement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EtablissementFindUniqueOrThrowArgs} args - Arguments to find a Etablissement
     * @example
     * // Get one Etablissement
     * const etablissement = await prisma.etablissement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EtablissementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EtablissementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Etablissement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtablissementFindFirstArgs} args - Arguments to find a Etablissement
     * @example
     * // Get one Etablissement
     * const etablissement = await prisma.etablissement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EtablissementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EtablissementFindFirstArgs<ExtArgs>>
    ): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Etablissement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtablissementFindFirstOrThrowArgs} args - Arguments to find a Etablissement
     * @example
     * // Get one Etablissement
     * const etablissement = await prisma.etablissement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EtablissementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EtablissementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Etablissements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtablissementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etablissements
     * const etablissements = await prisma.etablissement.findMany()
     * 
     * // Get first 10 Etablissements
     * const etablissements = await prisma.etablissement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etablissementWithIdOnly = await prisma.etablissement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EtablissementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EtablissementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Etablissement.
     * @param {EtablissementCreateArgs} args - Arguments to create a Etablissement.
     * @example
     * // Create one Etablissement
     * const Etablissement = await prisma.etablissement.create({
     *   data: {
     *     // ... data to create a Etablissement
     *   }
     * })
     * 
    **/
    create<T extends EtablissementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EtablissementCreateArgs<ExtArgs>>
    ): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Etablissements.
     *     @param {EtablissementCreateManyArgs} args - Arguments to create many Etablissements.
     *     @example
     *     // Create many Etablissements
     *     const etablissement = await prisma.etablissement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EtablissementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EtablissementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Etablissement.
     * @param {EtablissementDeleteArgs} args - Arguments to delete one Etablissement.
     * @example
     * // Delete one Etablissement
     * const Etablissement = await prisma.etablissement.delete({
     *   where: {
     *     // ... filter to delete one Etablissement
     *   }
     * })
     * 
    **/
    delete<T extends EtablissementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EtablissementDeleteArgs<ExtArgs>>
    ): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Etablissement.
     * @param {EtablissementUpdateArgs} args - Arguments to update one Etablissement.
     * @example
     * // Update one Etablissement
     * const etablissement = await prisma.etablissement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EtablissementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EtablissementUpdateArgs<ExtArgs>>
    ): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Etablissements.
     * @param {EtablissementDeleteManyArgs} args - Arguments to filter Etablissements to delete.
     * @example
     * // Delete a few Etablissements
     * const { count } = await prisma.etablissement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EtablissementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EtablissementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etablissements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtablissementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etablissements
     * const etablissement = await prisma.etablissement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EtablissementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EtablissementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Etablissement.
     * @param {EtablissementUpsertArgs} args - Arguments to update or create a Etablissement.
     * @example
     * // Update or create a Etablissement
     * const etablissement = await prisma.etablissement.upsert({
     *   create: {
     *     // ... data to create a Etablissement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Etablissement we want to update
     *   }
     * })
    **/
    upsert<T extends EtablissementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EtablissementUpsertArgs<ExtArgs>>
    ): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Etablissements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtablissementCountArgs} args - Arguments to filter Etablissements to count.
     * @example
     * // Count the number of Etablissements
     * const count = await prisma.etablissement.count({
     *   where: {
     *     // ... the filter for the Etablissements we want to count
     *   }
     * })
    **/
    count<T extends EtablissementCountArgs>(
      args?: Subset<T, EtablissementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtablissementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etablissement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtablissementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtablissementAggregateArgs>(args: Subset<T, EtablissementAggregateArgs>): Prisma.PrismaPromise<GetEtablissementAggregateType<T>>

    /**
     * Group by Etablissement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtablissementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtablissementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtablissementGroupByArgs['orderBy'] }
        : { orderBy?: EtablissementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtablissementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtablissementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Etablissement model
   */
  readonly fields: EtablissementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Etablissement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtablissementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    adresse<T extends Etablissement$adresseArgs<ExtArgs> = {}>(args?: Subset<T, Etablissement$adresseArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    contact<T extends Etablissement$contactArgs<ExtArgs> = {}>(args?: Subset<T, Etablissement$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    utilisateurs<T extends Etablissement$utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, Etablissement$utilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findMany'> | Null>;

    domaines<T extends Etablissement$domainesArgs<ExtArgs> = {}>(args?: Subset<T, Etablissement$domainesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, 'findMany'> | Null>;

    classes<T extends Etablissement$classesArgs<ExtArgs> = {}>(args?: Subset<T, Etablissement$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findMany'> | Null>;

    salle<T extends Etablissement$salleArgs<ExtArgs> = {}>(args?: Subset<T, Etablissement$salleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Etablissement model
   */ 
  interface EtablissementFieldRefs {
    readonly id: FieldRef<"Etablissement", 'Int'>
    readonly createdAt: FieldRef<"Etablissement", 'DateTime'>
    readonly updatedAt: FieldRef<"Etablissement", 'DateTime'>
    readonly nom: FieldRef<"Etablissement", 'String'>
    readonly matricule: FieldRef<"Etablissement", 'String'>
    readonly sigle: FieldRef<"Etablissement", 'String'>
    readonly dateCreation: FieldRef<"Etablissement", 'DateTime'>
    readonly logo: FieldRef<"Etablissement", 'String'>
    readonly anneeEnCours: FieldRef<"Etablissement", 'String'>
    readonly adresseId: FieldRef<"Etablissement", 'Int'>
    readonly contactId: FieldRef<"Etablissement", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Etablissement findUnique
   */
  export type EtablissementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    /**
     * Filter, which Etablissement to fetch.
     */
    where: EtablissementWhereUniqueInput
  }


  /**
   * Etablissement findUniqueOrThrow
   */
  export type EtablissementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    /**
     * Filter, which Etablissement to fetch.
     */
    where: EtablissementWhereUniqueInput
  }


  /**
   * Etablissement findFirst
   */
  export type EtablissementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    /**
     * Filter, which Etablissement to fetch.
     */
    where?: EtablissementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etablissements to fetch.
     */
    orderBy?: EtablissementOrderByWithRelationInput | EtablissementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etablissements.
     */
    cursor?: EtablissementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etablissements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etablissements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etablissements.
     */
    distinct?: EtablissementScalarFieldEnum | EtablissementScalarFieldEnum[]
  }


  /**
   * Etablissement findFirstOrThrow
   */
  export type EtablissementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    /**
     * Filter, which Etablissement to fetch.
     */
    where?: EtablissementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etablissements to fetch.
     */
    orderBy?: EtablissementOrderByWithRelationInput | EtablissementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etablissements.
     */
    cursor?: EtablissementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etablissements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etablissements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etablissements.
     */
    distinct?: EtablissementScalarFieldEnum | EtablissementScalarFieldEnum[]
  }


  /**
   * Etablissement findMany
   */
  export type EtablissementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    /**
     * Filter, which Etablissements to fetch.
     */
    where?: EtablissementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etablissements to fetch.
     */
    orderBy?: EtablissementOrderByWithRelationInput | EtablissementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Etablissements.
     */
    cursor?: EtablissementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etablissements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etablissements.
     */
    skip?: number
    distinct?: EtablissementScalarFieldEnum | EtablissementScalarFieldEnum[]
  }


  /**
   * Etablissement create
   */
  export type EtablissementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    /**
     * The data needed to create a Etablissement.
     */
    data: XOR<EtablissementCreateInput, EtablissementUncheckedCreateInput>
  }


  /**
   * Etablissement createMany
   */
  export type EtablissementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Etablissements.
     */
    data: EtablissementCreateManyInput | EtablissementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Etablissement update
   */
  export type EtablissementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    /**
     * The data needed to update a Etablissement.
     */
    data: XOR<EtablissementUpdateInput, EtablissementUncheckedUpdateInput>
    /**
     * Choose, which Etablissement to update.
     */
    where: EtablissementWhereUniqueInput
  }


  /**
   * Etablissement updateMany
   */
  export type EtablissementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Etablissements.
     */
    data: XOR<EtablissementUpdateManyMutationInput, EtablissementUncheckedUpdateManyInput>
    /**
     * Filter which Etablissements to update
     */
    where?: EtablissementWhereInput
  }


  /**
   * Etablissement upsert
   */
  export type EtablissementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    /**
     * The filter to search for the Etablissement to update in case it exists.
     */
    where: EtablissementWhereUniqueInput
    /**
     * In case the Etablissement found by the `where` argument doesn't exist, create a new Etablissement with this data.
     */
    create: XOR<EtablissementCreateInput, EtablissementUncheckedCreateInput>
    /**
     * In case the Etablissement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtablissementUpdateInput, EtablissementUncheckedUpdateInput>
  }


  /**
   * Etablissement delete
   */
  export type EtablissementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
    /**
     * Filter which Etablissement to delete.
     */
    where: EtablissementWhereUniqueInput
  }


  /**
   * Etablissement deleteMany
   */
  export type EtablissementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etablissements to delete
     */
    where?: EtablissementWhereInput
  }


  /**
   * Etablissement.adresse
   */
  export type Etablissement$adresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
  }


  /**
   * Etablissement.contact
   */
  export type Etablissement$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }


  /**
   * Etablissement.utilisateurs
   */
  export type Etablissement$utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UtilisateurInclude<ExtArgs> | null
    where?: UtilisateurWhereInput
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    cursor?: UtilisateurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Etablissement.domaines
   */
  export type Etablissement$domainesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomaineInclude<ExtArgs> | null
    where?: DomaineWhereInput
    orderBy?: DomaineOrderByWithRelationInput | DomaineOrderByWithRelationInput[]
    cursor?: DomaineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomaineScalarFieldEnum | DomaineScalarFieldEnum[]
  }


  /**
   * Etablissement.classes
   */
  export type Etablissement$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    where?: ClasseWhereInput
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    cursor?: ClasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }


  /**
   * Etablissement.salle
   */
  export type Etablissement$salleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    where?: SalleWhereInput
    orderBy?: SalleOrderByWithRelationInput | SalleOrderByWithRelationInput[]
    cursor?: SalleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalleScalarFieldEnum | SalleScalarFieldEnum[]
  }


  /**
   * Etablissement without action
   */
  export type EtablissementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etablissement
     */
    select?: EtablissementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtablissementInclude<ExtArgs> | null
  }



  /**
   * Model Classe
   */

  export type AggregateClasse = {
    _count: ClasseCountAggregateOutputType | null
    _avg: ClasseAvgAggregateOutputType | null
    _sum: ClasseSumAggregateOutputType | null
    _min: ClasseMinAggregateOutputType | null
    _max: ClasseMaxAggregateOutputType | null
  }

  export type ClasseAvgAggregateOutputType = {
    id: number | null
    etablissementId: number | null
    specialiteId: number | null
    anneeScolaireId: number | null
  }

  export type ClasseSumAggregateOutputType = {
    id: number | null
    etablissementId: number | null
    specialiteId: number | null
    anneeScolaireId: number | null
  }

  export type ClasseMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    code: string | null
    niveau: string | null
    etablissementId: number | null
    specialiteId: number | null
    anneeScolaireId: number | null
  }

  export type ClasseMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    code: string | null
    niveau: string | null
    etablissementId: number | null
    specialiteId: number | null
    anneeScolaireId: number | null
  }

  export type ClasseCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    code: number
    niveau: number
    etablissementId: number
    specialiteId: number
    anneeScolaireId: number
    _all: number
  }


  export type ClasseAvgAggregateInputType = {
    id?: true
    etablissementId?: true
    specialiteId?: true
    anneeScolaireId?: true
  }

  export type ClasseSumAggregateInputType = {
    id?: true
    etablissementId?: true
    specialiteId?: true
    anneeScolaireId?: true
  }

  export type ClasseMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    code?: true
    niveau?: true
    etablissementId?: true
    specialiteId?: true
    anneeScolaireId?: true
  }

  export type ClasseMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    code?: true
    niveau?: true
    etablissementId?: true
    specialiteId?: true
    anneeScolaireId?: true
  }

  export type ClasseCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    code?: true
    niveau?: true
    etablissementId?: true
    specialiteId?: true
    anneeScolaireId?: true
    _all?: true
  }

  export type ClasseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classe to aggregate.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClasseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClasseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClasseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClasseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClasseMaxAggregateInputType
  }

  export type GetClasseAggregateType<T extends ClasseAggregateArgs> = {
        [P in keyof T & keyof AggregateClasse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasse[P]>
      : GetScalarType<T[P], AggregateClasse[P]>
  }




  export type ClasseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClasseWhereInput
    orderBy?: ClasseOrderByWithAggregationInput | ClasseOrderByWithAggregationInput[]
    by: ClasseScalarFieldEnum[] | ClasseScalarFieldEnum
    having?: ClasseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClasseCountAggregateInputType | true
    _avg?: ClasseAvgAggregateInputType
    _sum?: ClasseSumAggregateInputType
    _min?: ClasseMinAggregateInputType
    _max?: ClasseMaxAggregateInputType
  }

  export type ClasseGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    code: string
    niveau: string
    etablissementId: number
    specialiteId: number
    anneeScolaireId: number | null
    _count: ClasseCountAggregateOutputType | null
    _avg: ClasseAvgAggregateOutputType | null
    _sum: ClasseSumAggregateOutputType | null
    _min: ClasseMinAggregateOutputType | null
    _max: ClasseMaxAggregateOutputType | null
  }

  type GetClasseGroupByPayload<T extends ClasseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClasseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClasseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClasseGroupByOutputType[P]>
            : GetScalarType<T[P], ClasseGroupByOutputType[P]>
        }
      >
    >


  export type ClasseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    code?: boolean
    niveau?: boolean
    etablissementId?: boolean
    specialiteId?: boolean
    anneeScolaireId?: boolean
    etablissement?: boolean | EtablissementDefaultArgs<ExtArgs>
    semestres?: boolean | Classe$semestresArgs<ExtArgs>
    inscriptions?: boolean | Classe$inscriptionsArgs<ExtArgs>
    specialite?: boolean | SpecialiteDefaultArgs<ExtArgs>
    Cours?: boolean | Classe$CoursArgs<ExtArgs>
    EmploiDuTemps?: boolean | Classe$EmploiDuTempsArgs<ExtArgs>
    AnneeScolaire?: boolean | Classe$AnneeScolaireArgs<ExtArgs>
    _count?: boolean | ClasseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classe"]>

  export type ClasseSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    code?: boolean
    niveau?: boolean
    etablissementId?: boolean
    specialiteId?: boolean
    anneeScolaireId?: boolean
  }

  export type ClasseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etablissement?: boolean | EtablissementDefaultArgs<ExtArgs>
    semestres?: boolean | Classe$semestresArgs<ExtArgs>
    inscriptions?: boolean | Classe$inscriptionsArgs<ExtArgs>
    specialite?: boolean | SpecialiteDefaultArgs<ExtArgs>
    Cours?: boolean | Classe$CoursArgs<ExtArgs>
    EmploiDuTemps?: boolean | Classe$EmploiDuTempsArgs<ExtArgs>
    AnneeScolaire?: boolean | Classe$AnneeScolaireArgs<ExtArgs>
    _count?: boolean | ClasseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClassePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classe"
    objects: {
      etablissement: Prisma.$EtablissementPayload<ExtArgs>
      semestres: Prisma.$SemestrePayload<ExtArgs>[]
      inscriptions: Prisma.$InscriptionPayload<ExtArgs>[]
      specialite: Prisma.$SpecialitePayload<ExtArgs>
      Cours: Prisma.$CoursPayload<ExtArgs>[]
      EmploiDuTemps: Prisma.$EmploiDuTempsPayload<ExtArgs>[]
      AnneeScolaire: Prisma.$AnneeScolairePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      code: string
      niveau: string
      etablissementId: number
      specialiteId: number
      anneeScolaireId: number | null
    }, ExtArgs["result"]["classe"]>
    composites: {}
  }


  type ClasseGetPayload<S extends boolean | null | undefined | ClasseDefaultArgs> = $Result.GetResult<Prisma.$ClassePayload, S>

  type ClasseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClasseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClasseCountAggregateInputType | true
    }

  export interface ClasseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classe'], meta: { name: 'Classe' } }
    /**
     * Find zero or one Classe that matches the filter.
     * @param {ClasseFindUniqueArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClasseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClasseFindUniqueArgs<ExtArgs>>
    ): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Classe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClasseFindUniqueOrThrowArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClasseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClasseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Classe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseFindFirstArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClasseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClasseFindFirstArgs<ExtArgs>>
    ): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Classe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseFindFirstOrThrowArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClasseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClasseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.classe.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.classe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classeWithIdOnly = await prisma.classe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClasseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClasseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Classe.
     * @param {ClasseCreateArgs} args - Arguments to create a Classe.
     * @example
     * // Create one Classe
     * const Classe = await prisma.classe.create({
     *   data: {
     *     // ... data to create a Classe
     *   }
     * })
     * 
    **/
    create<T extends ClasseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClasseCreateArgs<ExtArgs>>
    ): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Classes.
     *     @param {ClasseCreateManyArgs} args - Arguments to create many Classes.
     *     @example
     *     // Create many Classes
     *     const classe = await prisma.classe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClasseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClasseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Classe.
     * @param {ClasseDeleteArgs} args - Arguments to delete one Classe.
     * @example
     * // Delete one Classe
     * const Classe = await prisma.classe.delete({
     *   where: {
     *     // ... filter to delete one Classe
     *   }
     * })
     * 
    **/
    delete<T extends ClasseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClasseDeleteArgs<ExtArgs>>
    ): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Classe.
     * @param {ClasseUpdateArgs} args - Arguments to update one Classe.
     * @example
     * // Update one Classe
     * const classe = await prisma.classe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClasseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClasseUpdateArgs<ExtArgs>>
    ): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Classes.
     * @param {ClasseDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.classe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClasseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClasseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const classe = await prisma.classe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClasseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClasseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Classe.
     * @param {ClasseUpsertArgs} args - Arguments to update or create a Classe.
     * @example
     * // Update or create a Classe
     * const classe = await prisma.classe.upsert({
     *   create: {
     *     // ... data to create a Classe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classe we want to update
     *   }
     * })
    **/
    upsert<T extends ClasseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClasseUpsertArgs<ExtArgs>>
    ): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.classe.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClasseCountArgs>(
      args?: Subset<T, ClasseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClasseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClasseAggregateArgs>(args: Subset<T, ClasseAggregateArgs>): Prisma.PrismaPromise<GetClasseAggregateType<T>>

    /**
     * Group by Classe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClasseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClasseGroupByArgs['orderBy'] }
        : { orderBy?: ClasseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClasseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClasseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classe model
   */
  readonly fields: ClasseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClasseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    etablissement<T extends EtablissementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtablissementDefaultArgs<ExtArgs>>): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    semestres<T extends Classe$semestresArgs<ExtArgs> = {}>(args?: Subset<T, Classe$semestresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemestrePayload<ExtArgs>, T, 'findMany'> | Null>;

    inscriptions<T extends Classe$inscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Classe$inscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    specialite<T extends SpecialiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecialiteDefaultArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Cours<T extends Classe$CoursArgs<ExtArgs> = {}>(args?: Subset<T, Classe$CoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findMany'> | Null>;

    EmploiDuTemps<T extends Classe$EmploiDuTempsArgs<ExtArgs> = {}>(args?: Subset<T, Classe$EmploiDuTempsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'findMany'> | Null>;

    AnneeScolaire<T extends Classe$AnneeScolaireArgs<ExtArgs> = {}>(args?: Subset<T, Classe$AnneeScolaireArgs<ExtArgs>>): Prisma__AnneeScolaireClient<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Classe model
   */ 
  interface ClasseFieldRefs {
    readonly id: FieldRef<"Classe", 'Int'>
    readonly createdAt: FieldRef<"Classe", 'DateTime'>
    readonly updatedAt: FieldRef<"Classe", 'DateTime'>
    readonly nom: FieldRef<"Classe", 'String'>
    readonly code: FieldRef<"Classe", 'String'>
    readonly niveau: FieldRef<"Classe", 'String'>
    readonly etablissementId: FieldRef<"Classe", 'Int'>
    readonly specialiteId: FieldRef<"Classe", 'Int'>
    readonly anneeScolaireId: FieldRef<"Classe", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Classe findUnique
   */
  export type ClasseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where: ClasseWhereUniqueInput
  }


  /**
   * Classe findUniqueOrThrow
   */
  export type ClasseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where: ClasseWhereUniqueInput
  }


  /**
   * Classe findFirst
   */
  export type ClasseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }


  /**
   * Classe findFirstOrThrow
   */
  export type ClasseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }


  /**
   * Classe findMany
   */
  export type ClasseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }


  /**
   * Classe create
   */
  export type ClasseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * The data needed to create a Classe.
     */
    data: XOR<ClasseCreateInput, ClasseUncheckedCreateInput>
  }


  /**
   * Classe createMany
   */
  export type ClasseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClasseCreateManyInput | ClasseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Classe update
   */
  export type ClasseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * The data needed to update a Classe.
     */
    data: XOR<ClasseUpdateInput, ClasseUncheckedUpdateInput>
    /**
     * Choose, which Classe to update.
     */
    where: ClasseWhereUniqueInput
  }


  /**
   * Classe updateMany
   */
  export type ClasseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClasseUpdateManyMutationInput, ClasseUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClasseWhereInput
  }


  /**
   * Classe upsert
   */
  export type ClasseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * The filter to search for the Classe to update in case it exists.
     */
    where: ClasseWhereUniqueInput
    /**
     * In case the Classe found by the `where` argument doesn't exist, create a new Classe with this data.
     */
    create: XOR<ClasseCreateInput, ClasseUncheckedCreateInput>
    /**
     * In case the Classe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClasseUpdateInput, ClasseUncheckedUpdateInput>
  }


  /**
   * Classe delete
   */
  export type ClasseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter which Classe to delete.
     */
    where: ClasseWhereUniqueInput
  }


  /**
   * Classe deleteMany
   */
  export type ClasseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClasseWhereInput
  }


  /**
   * Classe.semestres
   */
  export type Classe$semestresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    where?: SemestreWhereInput
    orderBy?: SemestreOrderByWithRelationInput | SemestreOrderByWithRelationInput[]
    cursor?: SemestreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemestreScalarFieldEnum | SemestreScalarFieldEnum[]
  }


  /**
   * Classe.inscriptions
   */
  export type Classe$inscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscription
     */
    select?: InscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InscriptionInclude<ExtArgs> | null
    where?: InscriptionWhereInput
    orderBy?: InscriptionOrderByWithRelationInput | InscriptionOrderByWithRelationInput[]
    cursor?: InscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }


  /**
   * Classe.Cours
   */
  export type Classe$CoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    where?: CoursWhereInput
    orderBy?: CoursOrderByWithRelationInput | CoursOrderByWithRelationInput[]
    cursor?: CoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursScalarFieldEnum | CoursScalarFieldEnum[]
  }


  /**
   * Classe.EmploiDuTemps
   */
  export type Classe$EmploiDuTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    where?: EmploiDuTempsWhereInput
    orderBy?: EmploiDuTempsOrderByWithRelationInput | EmploiDuTempsOrderByWithRelationInput[]
    cursor?: EmploiDuTempsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploiDuTempsScalarFieldEnum | EmploiDuTempsScalarFieldEnum[]
  }


  /**
   * Classe.AnneeScolaire
   */
  export type Classe$AnneeScolaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    where?: AnneeScolaireWhereInput
  }


  /**
   * Classe without action
   */
  export type ClasseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
  }



  /**
   * Model AnneeScolaire
   */

  export type AggregateAnneeScolaire = {
    _count: AnneeScolaireCountAggregateOutputType | null
    _avg: AnneeScolaireAvgAggregateOutputType | null
    _sum: AnneeScolaireSumAggregateOutputType | null
    _min: AnneeScolaireMinAggregateOutputType | null
    _max: AnneeScolaireMaxAggregateOutputType | null
  }

  export type AnneeScolaireAvgAggregateOutputType = {
    id: number | null
    dateDebut: number | null
    dateFin: number | null
  }

  export type AnneeScolaireSumAggregateOutputType = {
    id: number | null
    dateDebut: number | null
    dateFin: number | null
  }

  export type AnneeScolaireMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    dateDebut: number | null
    dateFin: number | null
    nom: string | null
  }

  export type AnneeScolaireMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    dateDebut: number | null
    dateFin: number | null
    nom: string | null
  }

  export type AnneeScolaireCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    dateDebut: number
    dateFin: number
    nom: number
    _all: number
  }


  export type AnneeScolaireAvgAggregateInputType = {
    id?: true
    dateDebut?: true
    dateFin?: true
  }

  export type AnneeScolaireSumAggregateInputType = {
    id?: true
    dateDebut?: true
    dateFin?: true
  }

  export type AnneeScolaireMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    dateDebut?: true
    dateFin?: true
    nom?: true
  }

  export type AnneeScolaireMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    dateDebut?: true
    dateFin?: true
    nom?: true
  }

  export type AnneeScolaireCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    dateDebut?: true
    dateFin?: true
    nom?: true
    _all?: true
  }

  export type AnneeScolaireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnneeScolaire to aggregate.
     */
    where?: AnneeScolaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnneeScolaires to fetch.
     */
    orderBy?: AnneeScolaireOrderByWithRelationInput | AnneeScolaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnneeScolaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnneeScolaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnneeScolaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnneeScolaires
    **/
    _count?: true | AnneeScolaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnneeScolaireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnneeScolaireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnneeScolaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnneeScolaireMaxAggregateInputType
  }

  export type GetAnneeScolaireAggregateType<T extends AnneeScolaireAggregateArgs> = {
        [P in keyof T & keyof AggregateAnneeScolaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnneeScolaire[P]>
      : GetScalarType<T[P], AggregateAnneeScolaire[P]>
  }




  export type AnneeScolaireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnneeScolaireWhereInput
    orderBy?: AnneeScolaireOrderByWithAggregationInput | AnneeScolaireOrderByWithAggregationInput[]
    by: AnneeScolaireScalarFieldEnum[] | AnneeScolaireScalarFieldEnum
    having?: AnneeScolaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnneeScolaireCountAggregateInputType | true
    _avg?: AnneeScolaireAvgAggregateInputType
    _sum?: AnneeScolaireSumAggregateInputType
    _min?: AnneeScolaireMinAggregateInputType
    _max?: AnneeScolaireMaxAggregateInputType
  }

  export type AnneeScolaireGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    dateDebut: number
    dateFin: number
    nom: string
    _count: AnneeScolaireCountAggregateOutputType | null
    _avg: AnneeScolaireAvgAggregateOutputType | null
    _sum: AnneeScolaireSumAggregateOutputType | null
    _min: AnneeScolaireMinAggregateOutputType | null
    _max: AnneeScolaireMaxAggregateOutputType | null
  }

  type GetAnneeScolaireGroupByPayload<T extends AnneeScolaireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnneeScolaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnneeScolaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnneeScolaireGroupByOutputType[P]>
            : GetScalarType<T[P], AnneeScolaireGroupByOutputType[P]>
        }
      >
    >


  export type AnneeScolaireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    nom?: boolean
    classes?: boolean | AnneeScolaire$classesArgs<ExtArgs>
    _count?: boolean | AnneeScolaireCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anneeScolaire"]>

  export type AnneeScolaireSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    nom?: boolean
  }

  export type AnneeScolaireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | AnneeScolaire$classesArgs<ExtArgs>
    _count?: boolean | AnneeScolaireCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AnneeScolairePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnneeScolaire"
    objects: {
      classes: Prisma.$ClassePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      dateDebut: number
      dateFin: number
      nom: string
    }, ExtArgs["result"]["anneeScolaire"]>
    composites: {}
  }


  type AnneeScolaireGetPayload<S extends boolean | null | undefined | AnneeScolaireDefaultArgs> = $Result.GetResult<Prisma.$AnneeScolairePayload, S>

  type AnneeScolaireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnneeScolaireFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnneeScolaireCountAggregateInputType | true
    }

  export interface AnneeScolaireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnneeScolaire'], meta: { name: 'AnneeScolaire' } }
    /**
     * Find zero or one AnneeScolaire that matches the filter.
     * @param {AnneeScolaireFindUniqueArgs} args - Arguments to find a AnneeScolaire
     * @example
     * // Get one AnneeScolaire
     * const anneeScolaire = await prisma.anneeScolaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnneeScolaireFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AnneeScolaireFindUniqueArgs<ExtArgs>>
    ): Prisma__AnneeScolaireClient<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AnneeScolaire that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnneeScolaireFindUniqueOrThrowArgs} args - Arguments to find a AnneeScolaire
     * @example
     * // Get one AnneeScolaire
     * const anneeScolaire = await prisma.anneeScolaire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnneeScolaireFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnneeScolaireFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnneeScolaireClient<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AnneeScolaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnneeScolaireFindFirstArgs} args - Arguments to find a AnneeScolaire
     * @example
     * // Get one AnneeScolaire
     * const anneeScolaire = await prisma.anneeScolaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnneeScolaireFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AnneeScolaireFindFirstArgs<ExtArgs>>
    ): Prisma__AnneeScolaireClient<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AnneeScolaire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnneeScolaireFindFirstOrThrowArgs} args - Arguments to find a AnneeScolaire
     * @example
     * // Get one AnneeScolaire
     * const anneeScolaire = await prisma.anneeScolaire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnneeScolaireFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnneeScolaireFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnneeScolaireClient<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AnneeScolaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnneeScolaireFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnneeScolaires
     * const anneeScolaires = await prisma.anneeScolaire.findMany()
     * 
     * // Get first 10 AnneeScolaires
     * const anneeScolaires = await prisma.anneeScolaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anneeScolaireWithIdOnly = await prisma.anneeScolaire.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnneeScolaireFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnneeScolaireFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AnneeScolaire.
     * @param {AnneeScolaireCreateArgs} args - Arguments to create a AnneeScolaire.
     * @example
     * // Create one AnneeScolaire
     * const AnneeScolaire = await prisma.anneeScolaire.create({
     *   data: {
     *     // ... data to create a AnneeScolaire
     *   }
     * })
     * 
    **/
    create<T extends AnneeScolaireCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnneeScolaireCreateArgs<ExtArgs>>
    ): Prisma__AnneeScolaireClient<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AnneeScolaires.
     *     @param {AnneeScolaireCreateManyArgs} args - Arguments to create many AnneeScolaires.
     *     @example
     *     // Create many AnneeScolaires
     *     const anneeScolaire = await prisma.anneeScolaire.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnneeScolaireCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnneeScolaireCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AnneeScolaire.
     * @param {AnneeScolaireDeleteArgs} args - Arguments to delete one AnneeScolaire.
     * @example
     * // Delete one AnneeScolaire
     * const AnneeScolaire = await prisma.anneeScolaire.delete({
     *   where: {
     *     // ... filter to delete one AnneeScolaire
     *   }
     * })
     * 
    **/
    delete<T extends AnneeScolaireDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnneeScolaireDeleteArgs<ExtArgs>>
    ): Prisma__AnneeScolaireClient<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AnneeScolaire.
     * @param {AnneeScolaireUpdateArgs} args - Arguments to update one AnneeScolaire.
     * @example
     * // Update one AnneeScolaire
     * const anneeScolaire = await prisma.anneeScolaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnneeScolaireUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnneeScolaireUpdateArgs<ExtArgs>>
    ): Prisma__AnneeScolaireClient<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AnneeScolaires.
     * @param {AnneeScolaireDeleteManyArgs} args - Arguments to filter AnneeScolaires to delete.
     * @example
     * // Delete a few AnneeScolaires
     * const { count } = await prisma.anneeScolaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnneeScolaireDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnneeScolaireDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnneeScolaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnneeScolaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnneeScolaires
     * const anneeScolaire = await prisma.anneeScolaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnneeScolaireUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnneeScolaireUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnneeScolaire.
     * @param {AnneeScolaireUpsertArgs} args - Arguments to update or create a AnneeScolaire.
     * @example
     * // Update or create a AnneeScolaire
     * const anneeScolaire = await prisma.anneeScolaire.upsert({
     *   create: {
     *     // ... data to create a AnneeScolaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnneeScolaire we want to update
     *   }
     * })
    **/
    upsert<T extends AnneeScolaireUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnneeScolaireUpsertArgs<ExtArgs>>
    ): Prisma__AnneeScolaireClient<$Result.GetResult<Prisma.$AnneeScolairePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AnneeScolaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnneeScolaireCountArgs} args - Arguments to filter AnneeScolaires to count.
     * @example
     * // Count the number of AnneeScolaires
     * const count = await prisma.anneeScolaire.count({
     *   where: {
     *     // ... the filter for the AnneeScolaires we want to count
     *   }
     * })
    **/
    count<T extends AnneeScolaireCountArgs>(
      args?: Subset<T, AnneeScolaireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnneeScolaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnneeScolaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnneeScolaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnneeScolaireAggregateArgs>(args: Subset<T, AnneeScolaireAggregateArgs>): Prisma.PrismaPromise<GetAnneeScolaireAggregateType<T>>

    /**
     * Group by AnneeScolaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnneeScolaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnneeScolaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnneeScolaireGroupByArgs['orderBy'] }
        : { orderBy?: AnneeScolaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnneeScolaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnneeScolaireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnneeScolaire model
   */
  readonly fields: AnneeScolaireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnneeScolaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnneeScolaireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    classes<T extends AnneeScolaire$classesArgs<ExtArgs> = {}>(args?: Subset<T, AnneeScolaire$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AnneeScolaire model
   */ 
  interface AnneeScolaireFieldRefs {
    readonly id: FieldRef<"AnneeScolaire", 'Int'>
    readonly createdAt: FieldRef<"AnneeScolaire", 'DateTime'>
    readonly updatedAt: FieldRef<"AnneeScolaire", 'DateTime'>
    readonly dateDebut: FieldRef<"AnneeScolaire", 'Int'>
    readonly dateFin: FieldRef<"AnneeScolaire", 'Int'>
    readonly nom: FieldRef<"AnneeScolaire", 'String'>
  }
    

  // Custom InputTypes

  /**
   * AnneeScolaire findUnique
   */
  export type AnneeScolaireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    /**
     * Filter, which AnneeScolaire to fetch.
     */
    where: AnneeScolaireWhereUniqueInput
  }


  /**
   * AnneeScolaire findUniqueOrThrow
   */
  export type AnneeScolaireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    /**
     * Filter, which AnneeScolaire to fetch.
     */
    where: AnneeScolaireWhereUniqueInput
  }


  /**
   * AnneeScolaire findFirst
   */
  export type AnneeScolaireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    /**
     * Filter, which AnneeScolaire to fetch.
     */
    where?: AnneeScolaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnneeScolaires to fetch.
     */
    orderBy?: AnneeScolaireOrderByWithRelationInput | AnneeScolaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnneeScolaires.
     */
    cursor?: AnneeScolaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnneeScolaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnneeScolaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnneeScolaires.
     */
    distinct?: AnneeScolaireScalarFieldEnum | AnneeScolaireScalarFieldEnum[]
  }


  /**
   * AnneeScolaire findFirstOrThrow
   */
  export type AnneeScolaireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    /**
     * Filter, which AnneeScolaire to fetch.
     */
    where?: AnneeScolaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnneeScolaires to fetch.
     */
    orderBy?: AnneeScolaireOrderByWithRelationInput | AnneeScolaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnneeScolaires.
     */
    cursor?: AnneeScolaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnneeScolaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnneeScolaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnneeScolaires.
     */
    distinct?: AnneeScolaireScalarFieldEnum | AnneeScolaireScalarFieldEnum[]
  }


  /**
   * AnneeScolaire findMany
   */
  export type AnneeScolaireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    /**
     * Filter, which AnneeScolaires to fetch.
     */
    where?: AnneeScolaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnneeScolaires to fetch.
     */
    orderBy?: AnneeScolaireOrderByWithRelationInput | AnneeScolaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnneeScolaires.
     */
    cursor?: AnneeScolaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnneeScolaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnneeScolaires.
     */
    skip?: number
    distinct?: AnneeScolaireScalarFieldEnum | AnneeScolaireScalarFieldEnum[]
  }


  /**
   * AnneeScolaire create
   */
  export type AnneeScolaireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    /**
     * The data needed to create a AnneeScolaire.
     */
    data: XOR<AnneeScolaireCreateInput, AnneeScolaireUncheckedCreateInput>
  }


  /**
   * AnneeScolaire createMany
   */
  export type AnneeScolaireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnneeScolaires.
     */
    data: AnneeScolaireCreateManyInput | AnneeScolaireCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AnneeScolaire update
   */
  export type AnneeScolaireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    /**
     * The data needed to update a AnneeScolaire.
     */
    data: XOR<AnneeScolaireUpdateInput, AnneeScolaireUncheckedUpdateInput>
    /**
     * Choose, which AnneeScolaire to update.
     */
    where: AnneeScolaireWhereUniqueInput
  }


  /**
   * AnneeScolaire updateMany
   */
  export type AnneeScolaireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnneeScolaires.
     */
    data: XOR<AnneeScolaireUpdateManyMutationInput, AnneeScolaireUncheckedUpdateManyInput>
    /**
     * Filter which AnneeScolaires to update
     */
    where?: AnneeScolaireWhereInput
  }


  /**
   * AnneeScolaire upsert
   */
  export type AnneeScolaireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    /**
     * The filter to search for the AnneeScolaire to update in case it exists.
     */
    where: AnneeScolaireWhereUniqueInput
    /**
     * In case the AnneeScolaire found by the `where` argument doesn't exist, create a new AnneeScolaire with this data.
     */
    create: XOR<AnneeScolaireCreateInput, AnneeScolaireUncheckedCreateInput>
    /**
     * In case the AnneeScolaire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnneeScolaireUpdateInput, AnneeScolaireUncheckedUpdateInput>
  }


  /**
   * AnneeScolaire delete
   */
  export type AnneeScolaireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
    /**
     * Filter which AnneeScolaire to delete.
     */
    where: AnneeScolaireWhereUniqueInput
  }


  /**
   * AnneeScolaire deleteMany
   */
  export type AnneeScolaireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnneeScolaires to delete
     */
    where?: AnneeScolaireWhereInput
  }


  /**
   * AnneeScolaire.classes
   */
  export type AnneeScolaire$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    where?: ClasseWhereInput
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    cursor?: ClasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }


  /**
   * AnneeScolaire without action
   */
  export type AnneeScolaireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnneeScolaire
     */
    select?: AnneeScolaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnneeScolaireInclude<ExtArgs> | null
  }



  /**
   * Model EvaluationEtudiants
   */

  export type AggregateEvaluationEtudiants = {
    _count: EvaluationEtudiantsCountAggregateOutputType | null
    _avg: EvaluationEtudiantsAvgAggregateOutputType | null
    _sum: EvaluationEtudiantsSumAggregateOutputType | null
    _min: EvaluationEtudiantsMinAggregateOutputType | null
    _max: EvaluationEtudiantsMaxAggregateOutputType | null
  }

  export type EvaluationEtudiantsAvgAggregateOutputType = {
    id: number | null
    duree: number | null
    coursId: number | null
  }

  export type EvaluationEtudiantsSumAggregateOutputType = {
    id: number | null
    duree: number | null
    coursId: number | null
  }

  export type EvaluationEtudiantsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    typeEvaluation: $Enums.TypeEvaluation | null
    dateEvaluation: Date | null
    duree: number | null
    document: string | null
    description: string | null
    coursId: number | null
  }

  export type EvaluationEtudiantsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    typeEvaluation: $Enums.TypeEvaluation | null
    dateEvaluation: Date | null
    duree: number | null
    document: string | null
    description: string | null
    coursId: number | null
  }

  export type EvaluationEtudiantsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    typeEvaluation: number
    dateEvaluation: number
    duree: number
    document: number
    description: number
    coursId: number
    _all: number
  }


  export type EvaluationEtudiantsAvgAggregateInputType = {
    id?: true
    duree?: true
    coursId?: true
  }

  export type EvaluationEtudiantsSumAggregateInputType = {
    id?: true
    duree?: true
    coursId?: true
  }

  export type EvaluationEtudiantsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    typeEvaluation?: true
    dateEvaluation?: true
    duree?: true
    document?: true
    description?: true
    coursId?: true
  }

  export type EvaluationEtudiantsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    typeEvaluation?: true
    dateEvaluation?: true
    duree?: true
    document?: true
    description?: true
    coursId?: true
  }

  export type EvaluationEtudiantsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    typeEvaluation?: true
    dateEvaluation?: true
    duree?: true
    document?: true
    description?: true
    coursId?: true
    _all?: true
  }

  export type EvaluationEtudiantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationEtudiants to aggregate.
     */
    where?: EvaluationEtudiantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationEtudiants to fetch.
     */
    orderBy?: EvaluationEtudiantsOrderByWithRelationInput | EvaluationEtudiantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationEtudiantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationEtudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationEtudiants
    **/
    _count?: true | EvaluationEtudiantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationEtudiantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationEtudiantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationEtudiantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationEtudiantsMaxAggregateInputType
  }

  export type GetEvaluationEtudiantsAggregateType<T extends EvaluationEtudiantsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationEtudiants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationEtudiants[P]>
      : GetScalarType<T[P], AggregateEvaluationEtudiants[P]>
  }




  export type EvaluationEtudiantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationEtudiantsWhereInput
    orderBy?: EvaluationEtudiantsOrderByWithAggregationInput | EvaluationEtudiantsOrderByWithAggregationInput[]
    by: EvaluationEtudiantsScalarFieldEnum[] | EvaluationEtudiantsScalarFieldEnum
    having?: EvaluationEtudiantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationEtudiantsCountAggregateInputType | true
    _avg?: EvaluationEtudiantsAvgAggregateInputType
    _sum?: EvaluationEtudiantsSumAggregateInputType
    _min?: EvaluationEtudiantsMinAggregateInputType
    _max?: EvaluationEtudiantsMaxAggregateInputType
  }

  export type EvaluationEtudiantsGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    typeEvaluation: $Enums.TypeEvaluation
    dateEvaluation: Date
    duree: number
    document: string
    description: string | null
    coursId: number
    _count: EvaluationEtudiantsCountAggregateOutputType | null
    _avg: EvaluationEtudiantsAvgAggregateOutputType | null
    _sum: EvaluationEtudiantsSumAggregateOutputType | null
    _min: EvaluationEtudiantsMinAggregateOutputType | null
    _max: EvaluationEtudiantsMaxAggregateOutputType | null
  }

  type GetEvaluationEtudiantsGroupByPayload<T extends EvaluationEtudiantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationEtudiantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationEtudiantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationEtudiantsGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationEtudiantsGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationEtudiantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    typeEvaluation?: boolean
    dateEvaluation?: boolean
    duree?: boolean
    document?: boolean
    description?: boolean
    coursId?: boolean
    cours?: boolean | CoursDefaultArgs<ExtArgs>
    NoteEtudiant?: boolean | EvaluationEtudiants$NoteEtudiantArgs<ExtArgs>
    _count?: boolean | EvaluationEtudiantsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationEtudiants"]>

  export type EvaluationEtudiantsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    typeEvaluation?: boolean
    dateEvaluation?: boolean
    duree?: boolean
    document?: boolean
    description?: boolean
    coursId?: boolean
  }

  export type EvaluationEtudiantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cours?: boolean | CoursDefaultArgs<ExtArgs>
    NoteEtudiant?: boolean | EvaluationEtudiants$NoteEtudiantArgs<ExtArgs>
    _count?: boolean | EvaluationEtudiantsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EvaluationEtudiantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationEtudiants"
    objects: {
      cours: Prisma.$CoursPayload<ExtArgs>
      NoteEtudiant: Prisma.$NoteEtudiantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      typeEvaluation: $Enums.TypeEvaluation
      dateEvaluation: Date
      duree: number
      document: string
      description: string | null
      coursId: number
    }, ExtArgs["result"]["evaluationEtudiants"]>
    composites: {}
  }


  type EvaluationEtudiantsGetPayload<S extends boolean | null | undefined | EvaluationEtudiantsDefaultArgs> = $Result.GetResult<Prisma.$EvaluationEtudiantsPayload, S>

  type EvaluationEtudiantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationEtudiantsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationEtudiantsCountAggregateInputType | true
    }

  export interface EvaluationEtudiantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationEtudiants'], meta: { name: 'EvaluationEtudiants' } }
    /**
     * Find zero or one EvaluationEtudiants that matches the filter.
     * @param {EvaluationEtudiantsFindUniqueArgs} args - Arguments to find a EvaluationEtudiants
     * @example
     * // Get one EvaluationEtudiants
     * const evaluationEtudiants = await prisma.evaluationEtudiants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EvaluationEtudiantsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationEtudiantsFindUniqueArgs<ExtArgs>>
    ): Prisma__EvaluationEtudiantsClient<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EvaluationEtudiants that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EvaluationEtudiantsFindUniqueOrThrowArgs} args - Arguments to find a EvaluationEtudiants
     * @example
     * // Get one EvaluationEtudiants
     * const evaluationEtudiants = await prisma.evaluationEtudiants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EvaluationEtudiantsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationEtudiantsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationEtudiantsClient<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EvaluationEtudiants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEtudiantsFindFirstArgs} args - Arguments to find a EvaluationEtudiants
     * @example
     * // Get one EvaluationEtudiants
     * const evaluationEtudiants = await prisma.evaluationEtudiants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EvaluationEtudiantsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationEtudiantsFindFirstArgs<ExtArgs>>
    ): Prisma__EvaluationEtudiantsClient<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EvaluationEtudiants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEtudiantsFindFirstOrThrowArgs} args - Arguments to find a EvaluationEtudiants
     * @example
     * // Get one EvaluationEtudiants
     * const evaluationEtudiants = await prisma.evaluationEtudiants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EvaluationEtudiantsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationEtudiantsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationEtudiantsClient<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EvaluationEtudiants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEtudiantsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationEtudiants
     * const evaluationEtudiants = await prisma.evaluationEtudiants.findMany()
     * 
     * // Get first 10 EvaluationEtudiants
     * const evaluationEtudiants = await prisma.evaluationEtudiants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationEtudiantsWithIdOnly = await prisma.evaluationEtudiants.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EvaluationEtudiantsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationEtudiantsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EvaluationEtudiants.
     * @param {EvaluationEtudiantsCreateArgs} args - Arguments to create a EvaluationEtudiants.
     * @example
     * // Create one EvaluationEtudiants
     * const EvaluationEtudiants = await prisma.evaluationEtudiants.create({
     *   data: {
     *     // ... data to create a EvaluationEtudiants
     *   }
     * })
     * 
    **/
    create<T extends EvaluationEtudiantsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationEtudiantsCreateArgs<ExtArgs>>
    ): Prisma__EvaluationEtudiantsClient<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EvaluationEtudiants.
     *     @param {EvaluationEtudiantsCreateManyArgs} args - Arguments to create many EvaluationEtudiants.
     *     @example
     *     // Create many EvaluationEtudiants
     *     const evaluationEtudiants = await prisma.evaluationEtudiants.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EvaluationEtudiantsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationEtudiantsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EvaluationEtudiants.
     * @param {EvaluationEtudiantsDeleteArgs} args - Arguments to delete one EvaluationEtudiants.
     * @example
     * // Delete one EvaluationEtudiants
     * const EvaluationEtudiants = await prisma.evaluationEtudiants.delete({
     *   where: {
     *     // ... filter to delete one EvaluationEtudiants
     *   }
     * })
     * 
    **/
    delete<T extends EvaluationEtudiantsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationEtudiantsDeleteArgs<ExtArgs>>
    ): Prisma__EvaluationEtudiantsClient<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EvaluationEtudiants.
     * @param {EvaluationEtudiantsUpdateArgs} args - Arguments to update one EvaluationEtudiants.
     * @example
     * // Update one EvaluationEtudiants
     * const evaluationEtudiants = await prisma.evaluationEtudiants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EvaluationEtudiantsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationEtudiantsUpdateArgs<ExtArgs>>
    ): Prisma__EvaluationEtudiantsClient<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EvaluationEtudiants.
     * @param {EvaluationEtudiantsDeleteManyArgs} args - Arguments to filter EvaluationEtudiants to delete.
     * @example
     * // Delete a few EvaluationEtudiants
     * const { count } = await prisma.evaluationEtudiants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EvaluationEtudiantsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationEtudiantsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationEtudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEtudiantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationEtudiants
     * const evaluationEtudiants = await prisma.evaluationEtudiants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EvaluationEtudiantsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationEtudiantsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluationEtudiants.
     * @param {EvaluationEtudiantsUpsertArgs} args - Arguments to update or create a EvaluationEtudiants.
     * @example
     * // Update or create a EvaluationEtudiants
     * const evaluationEtudiants = await prisma.evaluationEtudiants.upsert({
     *   create: {
     *     // ... data to create a EvaluationEtudiants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationEtudiants we want to update
     *   }
     * })
    **/
    upsert<T extends EvaluationEtudiantsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationEtudiantsUpsertArgs<ExtArgs>>
    ): Prisma__EvaluationEtudiantsClient<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EvaluationEtudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEtudiantsCountArgs} args - Arguments to filter EvaluationEtudiants to count.
     * @example
     * // Count the number of EvaluationEtudiants
     * const count = await prisma.evaluationEtudiants.count({
     *   where: {
     *     // ... the filter for the EvaluationEtudiants we want to count
     *   }
     * })
    **/
    count<T extends EvaluationEtudiantsCountArgs>(
      args?: Subset<T, EvaluationEtudiantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationEtudiantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationEtudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEtudiantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationEtudiantsAggregateArgs>(args: Subset<T, EvaluationEtudiantsAggregateArgs>): Prisma.PrismaPromise<GetEvaluationEtudiantsAggregateType<T>>

    /**
     * Group by EvaluationEtudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEtudiantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationEtudiantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationEtudiantsGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationEtudiantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationEtudiantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationEtudiantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationEtudiants model
   */
  readonly fields: EvaluationEtudiantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationEtudiants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationEtudiantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cours<T extends CoursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursDefaultArgs<ExtArgs>>): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    NoteEtudiant<T extends EvaluationEtudiants$NoteEtudiantArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationEtudiants$NoteEtudiantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EvaluationEtudiants model
   */ 
  interface EvaluationEtudiantsFieldRefs {
    readonly id: FieldRef<"EvaluationEtudiants", 'Int'>
    readonly createdAt: FieldRef<"EvaluationEtudiants", 'DateTime'>
    readonly updatedAt: FieldRef<"EvaluationEtudiants", 'DateTime'>
    readonly typeEvaluation: FieldRef<"EvaluationEtudiants", 'TypeEvaluation'>
    readonly dateEvaluation: FieldRef<"EvaluationEtudiants", 'DateTime'>
    readonly duree: FieldRef<"EvaluationEtudiants", 'Int'>
    readonly document: FieldRef<"EvaluationEtudiants", 'String'>
    readonly description: FieldRef<"EvaluationEtudiants", 'String'>
    readonly coursId: FieldRef<"EvaluationEtudiants", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EvaluationEtudiants findUnique
   */
  export type EvaluationEtudiantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEtudiants to fetch.
     */
    where: EvaluationEtudiantsWhereUniqueInput
  }


  /**
   * EvaluationEtudiants findUniqueOrThrow
   */
  export type EvaluationEtudiantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEtudiants to fetch.
     */
    where: EvaluationEtudiantsWhereUniqueInput
  }


  /**
   * EvaluationEtudiants findFirst
   */
  export type EvaluationEtudiantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEtudiants to fetch.
     */
    where?: EvaluationEtudiantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationEtudiants to fetch.
     */
    orderBy?: EvaluationEtudiantsOrderByWithRelationInput | EvaluationEtudiantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationEtudiants.
     */
    cursor?: EvaluationEtudiantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationEtudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationEtudiants.
     */
    distinct?: EvaluationEtudiantsScalarFieldEnum | EvaluationEtudiantsScalarFieldEnum[]
  }


  /**
   * EvaluationEtudiants findFirstOrThrow
   */
  export type EvaluationEtudiantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEtudiants to fetch.
     */
    where?: EvaluationEtudiantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationEtudiants to fetch.
     */
    orderBy?: EvaluationEtudiantsOrderByWithRelationInput | EvaluationEtudiantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationEtudiants.
     */
    cursor?: EvaluationEtudiantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationEtudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationEtudiants.
     */
    distinct?: EvaluationEtudiantsScalarFieldEnum | EvaluationEtudiantsScalarFieldEnum[]
  }


  /**
   * EvaluationEtudiants findMany
   */
  export type EvaluationEtudiantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEtudiants to fetch.
     */
    where?: EvaluationEtudiantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationEtudiants to fetch.
     */
    orderBy?: EvaluationEtudiantsOrderByWithRelationInput | EvaluationEtudiantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationEtudiants.
     */
    cursor?: EvaluationEtudiantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationEtudiants.
     */
    skip?: number
    distinct?: EvaluationEtudiantsScalarFieldEnum | EvaluationEtudiantsScalarFieldEnum[]
  }


  /**
   * EvaluationEtudiants create
   */
  export type EvaluationEtudiantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationEtudiants.
     */
    data: XOR<EvaluationEtudiantsCreateInput, EvaluationEtudiantsUncheckedCreateInput>
  }


  /**
   * EvaluationEtudiants createMany
   */
  export type EvaluationEtudiantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationEtudiants.
     */
    data: EvaluationEtudiantsCreateManyInput | EvaluationEtudiantsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EvaluationEtudiants update
   */
  export type EvaluationEtudiantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationEtudiants.
     */
    data: XOR<EvaluationEtudiantsUpdateInput, EvaluationEtudiantsUncheckedUpdateInput>
    /**
     * Choose, which EvaluationEtudiants to update.
     */
    where: EvaluationEtudiantsWhereUniqueInput
  }


  /**
   * EvaluationEtudiants updateMany
   */
  export type EvaluationEtudiantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationEtudiants.
     */
    data: XOR<EvaluationEtudiantsUpdateManyMutationInput, EvaluationEtudiantsUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationEtudiants to update
     */
    where?: EvaluationEtudiantsWhereInput
  }


  /**
   * EvaluationEtudiants upsert
   */
  export type EvaluationEtudiantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationEtudiants to update in case it exists.
     */
    where: EvaluationEtudiantsWhereUniqueInput
    /**
     * In case the EvaluationEtudiants found by the `where` argument doesn't exist, create a new EvaluationEtudiants with this data.
     */
    create: XOR<EvaluationEtudiantsCreateInput, EvaluationEtudiantsUncheckedCreateInput>
    /**
     * In case the EvaluationEtudiants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationEtudiantsUpdateInput, EvaluationEtudiantsUncheckedUpdateInput>
  }


  /**
   * EvaluationEtudiants delete
   */
  export type EvaluationEtudiantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    /**
     * Filter which EvaluationEtudiants to delete.
     */
    where: EvaluationEtudiantsWhereUniqueInput
  }


  /**
   * EvaluationEtudiants deleteMany
   */
  export type EvaluationEtudiantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationEtudiants to delete
     */
    where?: EvaluationEtudiantsWhereInput
  }


  /**
   * EvaluationEtudiants.NoteEtudiant
   */
  export type EvaluationEtudiants$NoteEtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    where?: NoteEtudiantWhereInput
    orderBy?: NoteEtudiantOrderByWithRelationInput | NoteEtudiantOrderByWithRelationInput[]
    cursor?: NoteEtudiantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteEtudiantScalarFieldEnum | NoteEtudiantScalarFieldEnum[]
  }


  /**
   * EvaluationEtudiants without action
   */
  export type EvaluationEtudiantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
  }



  /**
   * Model NoteEtudiant
   */

  export type AggregateNoteEtudiant = {
    _count: NoteEtudiantCountAggregateOutputType | null
    _avg: NoteEtudiantAvgAggregateOutputType | null
    _sum: NoteEtudiantSumAggregateOutputType | null
    _min: NoteEtudiantMinAggregateOutputType | null
    _max: NoteEtudiantMaxAggregateOutputType | null
  }

  export type NoteEtudiantAvgAggregateOutputType = {
    id: number | null
    note: number | null
    evaluationEtudiantId: number | null
    etudiantId: number | null
  }

  export type NoteEtudiantSumAggregateOutputType = {
    id: number | null
    note: number | null
    evaluationEtudiantId: number | null
    etudiantId: number | null
  }

  export type NoteEtudiantMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    note: number | null
    evaluationEtudiantId: number | null
    etudiantId: number | null
  }

  export type NoteEtudiantMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    note: number | null
    evaluationEtudiantId: number | null
    etudiantId: number | null
  }

  export type NoteEtudiantCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    note: number
    evaluationEtudiantId: number
    etudiantId: number
    _all: number
  }


  export type NoteEtudiantAvgAggregateInputType = {
    id?: true
    note?: true
    evaluationEtudiantId?: true
    etudiantId?: true
  }

  export type NoteEtudiantSumAggregateInputType = {
    id?: true
    note?: true
    evaluationEtudiantId?: true
    etudiantId?: true
  }

  export type NoteEtudiantMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    note?: true
    evaluationEtudiantId?: true
    etudiantId?: true
  }

  export type NoteEtudiantMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    note?: true
    evaluationEtudiantId?: true
    etudiantId?: true
  }

  export type NoteEtudiantCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    note?: true
    evaluationEtudiantId?: true
    etudiantId?: true
    _all?: true
  }

  export type NoteEtudiantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteEtudiant to aggregate.
     */
    where?: NoteEtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteEtudiants to fetch.
     */
    orderBy?: NoteEtudiantOrderByWithRelationInput | NoteEtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteEtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteEtudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoteEtudiants
    **/
    _count?: true | NoteEtudiantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteEtudiantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteEtudiantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteEtudiantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteEtudiantMaxAggregateInputType
  }

  export type GetNoteEtudiantAggregateType<T extends NoteEtudiantAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteEtudiant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteEtudiant[P]>
      : GetScalarType<T[P], AggregateNoteEtudiant[P]>
  }




  export type NoteEtudiantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteEtudiantWhereInput
    orderBy?: NoteEtudiantOrderByWithAggregationInput | NoteEtudiantOrderByWithAggregationInput[]
    by: NoteEtudiantScalarFieldEnum[] | NoteEtudiantScalarFieldEnum
    having?: NoteEtudiantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteEtudiantCountAggregateInputType | true
    _avg?: NoteEtudiantAvgAggregateInputType
    _sum?: NoteEtudiantSumAggregateInputType
    _min?: NoteEtudiantMinAggregateInputType
    _max?: NoteEtudiantMaxAggregateInputType
  }

  export type NoteEtudiantGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    note: number
    evaluationEtudiantId: number | null
    etudiantId: number
    _count: NoteEtudiantCountAggregateOutputType | null
    _avg: NoteEtudiantAvgAggregateOutputType | null
    _sum: NoteEtudiantSumAggregateOutputType | null
    _min: NoteEtudiantMinAggregateOutputType | null
    _max: NoteEtudiantMaxAggregateOutputType | null
  }

  type GetNoteEtudiantGroupByPayload<T extends NoteEtudiantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteEtudiantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteEtudiantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteEtudiantGroupByOutputType[P]>
            : GetScalarType<T[P], NoteEtudiantGroupByOutputType[P]>
        }
      >
    >


  export type NoteEtudiantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note?: boolean
    evaluationEtudiantId?: boolean
    etudiantId?: boolean
    evaluationEtudiant?: boolean | NoteEtudiant$evaluationEtudiantArgs<ExtArgs>
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteEtudiant"]>

  export type NoteEtudiantSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note?: boolean
    evaluationEtudiantId?: boolean
    etudiantId?: boolean
  }

  export type NoteEtudiantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationEtudiant?: boolean | NoteEtudiant$evaluationEtudiantArgs<ExtArgs>
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
  }


  export type $NoteEtudiantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoteEtudiant"
    objects: {
      evaluationEtudiant: Prisma.$EvaluationEtudiantsPayload<ExtArgs> | null
      etudiant: Prisma.$EtudiantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      note: number
      evaluationEtudiantId: number | null
      etudiantId: number
    }, ExtArgs["result"]["noteEtudiant"]>
    composites: {}
  }


  type NoteEtudiantGetPayload<S extends boolean | null | undefined | NoteEtudiantDefaultArgs> = $Result.GetResult<Prisma.$NoteEtudiantPayload, S>

  type NoteEtudiantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteEtudiantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteEtudiantCountAggregateInputType | true
    }

  export interface NoteEtudiantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoteEtudiant'], meta: { name: 'NoteEtudiant' } }
    /**
     * Find zero or one NoteEtudiant that matches the filter.
     * @param {NoteEtudiantFindUniqueArgs} args - Arguments to find a NoteEtudiant
     * @example
     * // Get one NoteEtudiant
     * const noteEtudiant = await prisma.noteEtudiant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NoteEtudiantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NoteEtudiantFindUniqueArgs<ExtArgs>>
    ): Prisma__NoteEtudiantClient<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NoteEtudiant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NoteEtudiantFindUniqueOrThrowArgs} args - Arguments to find a NoteEtudiant
     * @example
     * // Get one NoteEtudiant
     * const noteEtudiant = await prisma.noteEtudiant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NoteEtudiantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteEtudiantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NoteEtudiantClient<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NoteEtudiant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteEtudiantFindFirstArgs} args - Arguments to find a NoteEtudiant
     * @example
     * // Get one NoteEtudiant
     * const noteEtudiant = await prisma.noteEtudiant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NoteEtudiantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteEtudiantFindFirstArgs<ExtArgs>>
    ): Prisma__NoteEtudiantClient<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NoteEtudiant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteEtudiantFindFirstOrThrowArgs} args - Arguments to find a NoteEtudiant
     * @example
     * // Get one NoteEtudiant
     * const noteEtudiant = await prisma.noteEtudiant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NoteEtudiantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteEtudiantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NoteEtudiantClient<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NoteEtudiants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteEtudiantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteEtudiants
     * const noteEtudiants = await prisma.noteEtudiant.findMany()
     * 
     * // Get first 10 NoteEtudiants
     * const noteEtudiants = await prisma.noteEtudiant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteEtudiantWithIdOnly = await prisma.noteEtudiant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NoteEtudiantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteEtudiantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NoteEtudiant.
     * @param {NoteEtudiantCreateArgs} args - Arguments to create a NoteEtudiant.
     * @example
     * // Create one NoteEtudiant
     * const NoteEtudiant = await prisma.noteEtudiant.create({
     *   data: {
     *     // ... data to create a NoteEtudiant
     *   }
     * })
     * 
    **/
    create<T extends NoteEtudiantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NoteEtudiantCreateArgs<ExtArgs>>
    ): Prisma__NoteEtudiantClient<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NoteEtudiants.
     *     @param {NoteEtudiantCreateManyArgs} args - Arguments to create many NoteEtudiants.
     *     @example
     *     // Create many NoteEtudiants
     *     const noteEtudiant = await prisma.noteEtudiant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NoteEtudiantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteEtudiantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NoteEtudiant.
     * @param {NoteEtudiantDeleteArgs} args - Arguments to delete one NoteEtudiant.
     * @example
     * // Delete one NoteEtudiant
     * const NoteEtudiant = await prisma.noteEtudiant.delete({
     *   where: {
     *     // ... filter to delete one NoteEtudiant
     *   }
     * })
     * 
    **/
    delete<T extends NoteEtudiantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NoteEtudiantDeleteArgs<ExtArgs>>
    ): Prisma__NoteEtudiantClient<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NoteEtudiant.
     * @param {NoteEtudiantUpdateArgs} args - Arguments to update one NoteEtudiant.
     * @example
     * // Update one NoteEtudiant
     * const noteEtudiant = await prisma.noteEtudiant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NoteEtudiantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NoteEtudiantUpdateArgs<ExtArgs>>
    ): Prisma__NoteEtudiantClient<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NoteEtudiants.
     * @param {NoteEtudiantDeleteManyArgs} args - Arguments to filter NoteEtudiants to delete.
     * @example
     * // Delete a few NoteEtudiants
     * const { count } = await prisma.noteEtudiant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NoteEtudiantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteEtudiantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteEtudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteEtudiantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteEtudiants
     * const noteEtudiant = await prisma.noteEtudiant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NoteEtudiantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NoteEtudiantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NoteEtudiant.
     * @param {NoteEtudiantUpsertArgs} args - Arguments to update or create a NoteEtudiant.
     * @example
     * // Update or create a NoteEtudiant
     * const noteEtudiant = await prisma.noteEtudiant.upsert({
     *   create: {
     *     // ... data to create a NoteEtudiant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteEtudiant we want to update
     *   }
     * })
    **/
    upsert<T extends NoteEtudiantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NoteEtudiantUpsertArgs<ExtArgs>>
    ): Prisma__NoteEtudiantClient<$Result.GetResult<Prisma.$NoteEtudiantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NoteEtudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteEtudiantCountArgs} args - Arguments to filter NoteEtudiants to count.
     * @example
     * // Count the number of NoteEtudiants
     * const count = await prisma.noteEtudiant.count({
     *   where: {
     *     // ... the filter for the NoteEtudiants we want to count
     *   }
     * })
    **/
    count<T extends NoteEtudiantCountArgs>(
      args?: Subset<T, NoteEtudiantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteEtudiantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteEtudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteEtudiantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteEtudiantAggregateArgs>(args: Subset<T, NoteEtudiantAggregateArgs>): Prisma.PrismaPromise<GetNoteEtudiantAggregateType<T>>

    /**
     * Group by NoteEtudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteEtudiantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteEtudiantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteEtudiantGroupByArgs['orderBy'] }
        : { orderBy?: NoteEtudiantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteEtudiantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteEtudiantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoteEtudiant model
   */
  readonly fields: NoteEtudiantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoteEtudiant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteEtudiantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluationEtudiant<T extends NoteEtudiant$evaluationEtudiantArgs<ExtArgs> = {}>(args?: Subset<T, NoteEtudiant$evaluationEtudiantArgs<ExtArgs>>): Prisma__EvaluationEtudiantsClient<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    etudiant<T extends EtudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtudiantDefaultArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NoteEtudiant model
   */ 
  interface NoteEtudiantFieldRefs {
    readonly id: FieldRef<"NoteEtudiant", 'Int'>
    readonly createdAt: FieldRef<"NoteEtudiant", 'DateTime'>
    readonly updatedAt: FieldRef<"NoteEtudiant", 'DateTime'>
    readonly note: FieldRef<"NoteEtudiant", 'Float'>
    readonly evaluationEtudiantId: FieldRef<"NoteEtudiant", 'Int'>
    readonly etudiantId: FieldRef<"NoteEtudiant", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * NoteEtudiant findUnique
   */
  export type NoteEtudiantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which NoteEtudiant to fetch.
     */
    where: NoteEtudiantWhereUniqueInput
  }


  /**
   * NoteEtudiant findUniqueOrThrow
   */
  export type NoteEtudiantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which NoteEtudiant to fetch.
     */
    where: NoteEtudiantWhereUniqueInput
  }


  /**
   * NoteEtudiant findFirst
   */
  export type NoteEtudiantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which NoteEtudiant to fetch.
     */
    where?: NoteEtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteEtudiants to fetch.
     */
    orderBy?: NoteEtudiantOrderByWithRelationInput | NoteEtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteEtudiants.
     */
    cursor?: NoteEtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteEtudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteEtudiants.
     */
    distinct?: NoteEtudiantScalarFieldEnum | NoteEtudiantScalarFieldEnum[]
  }


  /**
   * NoteEtudiant findFirstOrThrow
   */
  export type NoteEtudiantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which NoteEtudiant to fetch.
     */
    where?: NoteEtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteEtudiants to fetch.
     */
    orderBy?: NoteEtudiantOrderByWithRelationInput | NoteEtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteEtudiants.
     */
    cursor?: NoteEtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteEtudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteEtudiants.
     */
    distinct?: NoteEtudiantScalarFieldEnum | NoteEtudiantScalarFieldEnum[]
  }


  /**
   * NoteEtudiant findMany
   */
  export type NoteEtudiantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which NoteEtudiants to fetch.
     */
    where?: NoteEtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteEtudiants to fetch.
     */
    orderBy?: NoteEtudiantOrderByWithRelationInput | NoteEtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoteEtudiants.
     */
    cursor?: NoteEtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteEtudiants.
     */
    skip?: number
    distinct?: NoteEtudiantScalarFieldEnum | NoteEtudiantScalarFieldEnum[]
  }


  /**
   * NoteEtudiant create
   */
  export type NoteEtudiantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    /**
     * The data needed to create a NoteEtudiant.
     */
    data: XOR<NoteEtudiantCreateInput, NoteEtudiantUncheckedCreateInput>
  }


  /**
   * NoteEtudiant createMany
   */
  export type NoteEtudiantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoteEtudiants.
     */
    data: NoteEtudiantCreateManyInput | NoteEtudiantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * NoteEtudiant update
   */
  export type NoteEtudiantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    /**
     * The data needed to update a NoteEtudiant.
     */
    data: XOR<NoteEtudiantUpdateInput, NoteEtudiantUncheckedUpdateInput>
    /**
     * Choose, which NoteEtudiant to update.
     */
    where: NoteEtudiantWhereUniqueInput
  }


  /**
   * NoteEtudiant updateMany
   */
  export type NoteEtudiantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoteEtudiants.
     */
    data: XOR<NoteEtudiantUpdateManyMutationInput, NoteEtudiantUncheckedUpdateManyInput>
    /**
     * Filter which NoteEtudiants to update
     */
    where?: NoteEtudiantWhereInput
  }


  /**
   * NoteEtudiant upsert
   */
  export type NoteEtudiantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    /**
     * The filter to search for the NoteEtudiant to update in case it exists.
     */
    where: NoteEtudiantWhereUniqueInput
    /**
     * In case the NoteEtudiant found by the `where` argument doesn't exist, create a new NoteEtudiant with this data.
     */
    create: XOR<NoteEtudiantCreateInput, NoteEtudiantUncheckedCreateInput>
    /**
     * In case the NoteEtudiant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteEtudiantUpdateInput, NoteEtudiantUncheckedUpdateInput>
  }


  /**
   * NoteEtudiant delete
   */
  export type NoteEtudiantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
    /**
     * Filter which NoteEtudiant to delete.
     */
    where: NoteEtudiantWhereUniqueInput
  }


  /**
   * NoteEtudiant deleteMany
   */
  export type NoteEtudiantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteEtudiants to delete
     */
    where?: NoteEtudiantWhereInput
  }


  /**
   * NoteEtudiant.evaluationEtudiant
   */
  export type NoteEtudiant$evaluationEtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    where?: EvaluationEtudiantsWhereInput
  }


  /**
   * NoteEtudiant without action
   */
  export type NoteEtudiantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteEtudiant
     */
    select?: NoteEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteEtudiantInclude<ExtArgs> | null
  }



  /**
   * Model Cours
   */

  export type AggregateCours = {
    _count: CoursCountAggregateOutputType | null
    _avg: CoursAvgAggregateOutputType | null
    _sum: CoursSumAggregateOutputType | null
    _min: CoursMinAggregateOutputType | null
    _max: CoursMaxAggregateOutputType | null
  }

  export type CoursAvgAggregateOutputType = {
    id: number | null
    matiereId: number | null
    salleId: number | null
    classeId: number | null
    professeurId: number | null
  }

  export type CoursSumAggregateOutputType = {
    id: number | null
    matiereId: number | null
    salleId: number | null
    classeId: number | null
    professeurId: number | null
  }

  export type CoursMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    description: string | null
    dateDebut: Date | null
    dateFin: Date | null
    heureDebut: Date | null
    heureFin: Date | null
    matiereId: number | null
    salleId: number | null
    classeId: number | null
    professeurId: number | null
  }

  export type CoursMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    description: string | null
    dateDebut: Date | null
    dateFin: Date | null
    heureDebut: Date | null
    heureFin: Date | null
    matiereId: number | null
    salleId: number | null
    classeId: number | null
    professeurId: number | null
  }

  export type CoursCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    description: number
    dateDebut: number
    dateFin: number
    heureDebut: number
    heureFin: number
    matiereId: number
    salleId: number
    classeId: number
    professeurId: number
    _all: number
  }


  export type CoursAvgAggregateInputType = {
    id?: true
    matiereId?: true
    salleId?: true
    classeId?: true
    professeurId?: true
  }

  export type CoursSumAggregateInputType = {
    id?: true
    matiereId?: true
    salleId?: true
    classeId?: true
    professeurId?: true
  }

  export type CoursMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    description?: true
    dateDebut?: true
    dateFin?: true
    heureDebut?: true
    heureFin?: true
    matiereId?: true
    salleId?: true
    classeId?: true
    professeurId?: true
  }

  export type CoursMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    description?: true
    dateDebut?: true
    dateFin?: true
    heureDebut?: true
    heureFin?: true
    matiereId?: true
    salleId?: true
    classeId?: true
    professeurId?: true
  }

  export type CoursCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    description?: true
    dateDebut?: true
    dateFin?: true
    heureDebut?: true
    heureFin?: true
    matiereId?: true
    salleId?: true
    classeId?: true
    professeurId?: true
    _all?: true
  }

  export type CoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cours to aggregate.
     */
    where?: CoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cours to fetch.
     */
    orderBy?: CoursOrderByWithRelationInput | CoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cours
    **/
    _count?: true | CoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursMaxAggregateInputType
  }

  export type GetCoursAggregateType<T extends CoursAggregateArgs> = {
        [P in keyof T & keyof AggregateCours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCours[P]>
      : GetScalarType<T[P], AggregateCours[P]>
  }




  export type CoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursWhereInput
    orderBy?: CoursOrderByWithAggregationInput | CoursOrderByWithAggregationInput[]
    by: CoursScalarFieldEnum[] | CoursScalarFieldEnum
    having?: CoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursCountAggregateInputType | true
    _avg?: CoursAvgAggregateInputType
    _sum?: CoursSumAggregateInputType
    _min?: CoursMinAggregateInputType
    _max?: CoursMaxAggregateInputType
  }

  export type CoursGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    description: string | null
    dateDebut: Date
    dateFin: Date
    heureDebut: Date
    heureFin: Date
    matiereId: number | null
    salleId: number | null
    classeId: number | null
    professeurId: number | null
    _count: CoursCountAggregateOutputType | null
    _avg: CoursAvgAggregateOutputType | null
    _sum: CoursSumAggregateOutputType | null
    _min: CoursMinAggregateOutputType | null
    _max: CoursMaxAggregateOutputType | null
  }

  type GetCoursGroupByPayload<T extends CoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursGroupByOutputType[P]>
            : GetScalarType<T[P], CoursGroupByOutputType[P]>
        }
      >
    >


  export type CoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    description?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    matiereId?: boolean
    salleId?: boolean
    classeId?: boolean
    professeurId?: boolean
    matiere?: boolean | Cours$matiereArgs<ExtArgs>
    salle?: boolean | Cours$salleArgs<ExtArgs>
    classe?: boolean | Cours$classeArgs<ExtArgs>
    professeur?: boolean | Cours$professeurArgs<ExtArgs>
    evaluationEtudiant?: boolean | Cours$evaluationEtudiantArgs<ExtArgs>
    feuillePresences?: boolean | Cours$feuillePresencesArgs<ExtArgs>
    emploiDuTemps?: boolean | Cours$emploiDuTempsArgs<ExtArgs>
    _count?: boolean | CoursCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cours"]>

  export type CoursSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    description?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    matiereId?: boolean
    salleId?: boolean
    classeId?: boolean
    professeurId?: boolean
  }

  export type CoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matiere?: boolean | Cours$matiereArgs<ExtArgs>
    salle?: boolean | Cours$salleArgs<ExtArgs>
    classe?: boolean | Cours$classeArgs<ExtArgs>
    professeur?: boolean | Cours$professeurArgs<ExtArgs>
    evaluationEtudiant?: boolean | Cours$evaluationEtudiantArgs<ExtArgs>
    feuillePresences?: boolean | Cours$feuillePresencesArgs<ExtArgs>
    emploiDuTemps?: boolean | Cours$emploiDuTempsArgs<ExtArgs>
    _count?: boolean | CoursCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cours"
    objects: {
      matiere: Prisma.$MatierePayload<ExtArgs> | null
      salle: Prisma.$SallePayload<ExtArgs> | null
      classe: Prisma.$ClassePayload<ExtArgs> | null
      professeur: Prisma.$ProfesseurPayload<ExtArgs> | null
      evaluationEtudiant: Prisma.$EvaluationEtudiantsPayload<ExtArgs>[]
      feuillePresences: Prisma.$FeuillePresencePayload<ExtArgs>[]
      emploiDuTemps: Prisma.$EmploiDuTempsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      description: string | null
      dateDebut: Date
      dateFin: Date
      heureDebut: Date
      heureFin: Date
      matiereId: number | null
      salleId: number | null
      classeId: number | null
      professeurId: number | null
    }, ExtArgs["result"]["cours"]>
    composites: {}
  }


  type CoursGetPayload<S extends boolean | null | undefined | CoursDefaultArgs> = $Result.GetResult<Prisma.$CoursPayload, S>

  type CoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoursFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoursCountAggregateInputType | true
    }

  export interface CoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cours'], meta: { name: 'Cours' } }
    /**
     * Find zero or one Cours that matches the filter.
     * @param {CoursFindUniqueArgs} args - Arguments to find a Cours
     * @example
     * // Get one Cours
     * const cours = await prisma.cours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoursFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CoursFindUniqueArgs<ExtArgs>>
    ): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cours that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CoursFindUniqueOrThrowArgs} args - Arguments to find a Cours
     * @example
     * // Get one Cours
     * const cours = await prisma.cours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CoursFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursFindFirstArgs} args - Arguments to find a Cours
     * @example
     * // Get one Cours
     * const cours = await prisma.cours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoursFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursFindFirstArgs<ExtArgs>>
    ): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursFindFirstOrThrowArgs} args - Arguments to find a Cours
     * @example
     * // Get one Cours
     * const cours = await prisma.cours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CoursFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cours
     * const cours = await prisma.cours.findMany()
     * 
     * // Get first 10 Cours
     * const cours = await prisma.cours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursWithIdOnly = await prisma.cours.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CoursFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cours.
     * @param {CoursCreateArgs} args - Arguments to create a Cours.
     * @example
     * // Create one Cours
     * const Cours = await prisma.cours.create({
     *   data: {
     *     // ... data to create a Cours
     *   }
     * })
     * 
    **/
    create<T extends CoursCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CoursCreateArgs<ExtArgs>>
    ): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cours.
     *     @param {CoursCreateManyArgs} args - Arguments to create many Cours.
     *     @example
     *     // Create many Cours
     *     const cours = await prisma.cours.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CoursCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cours.
     * @param {CoursDeleteArgs} args - Arguments to delete one Cours.
     * @example
     * // Delete one Cours
     * const Cours = await prisma.cours.delete({
     *   where: {
     *     // ... filter to delete one Cours
     *   }
     * })
     * 
    **/
    delete<T extends CoursDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CoursDeleteArgs<ExtArgs>>
    ): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cours.
     * @param {CoursUpdateArgs} args - Arguments to update one Cours.
     * @example
     * // Update one Cours
     * const cours = await prisma.cours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoursUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CoursUpdateArgs<ExtArgs>>
    ): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cours.
     * @param {CoursDeleteManyArgs} args - Arguments to filter Cours to delete.
     * @example
     * // Delete a few Cours
     * const { count } = await prisma.cours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoursDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cours
     * const cours = await prisma.cours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoursUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CoursUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cours.
     * @param {CoursUpsertArgs} args - Arguments to update or create a Cours.
     * @example
     * // Update or create a Cours
     * const cours = await prisma.cours.upsert({
     *   create: {
     *     // ... data to create a Cours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cours we want to update
     *   }
     * })
    **/
    upsert<T extends CoursUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CoursUpsertArgs<ExtArgs>>
    ): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursCountArgs} args - Arguments to filter Cours to count.
     * @example
     * // Count the number of Cours
     * const count = await prisma.cours.count({
     *   where: {
     *     // ... the filter for the Cours we want to count
     *   }
     * })
    **/
    count<T extends CoursCountArgs>(
      args?: Subset<T, CoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursAggregateArgs>(args: Subset<T, CoursAggregateArgs>): Prisma.PrismaPromise<GetCoursAggregateType<T>>

    /**
     * Group by Cours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoursGroupByArgs['orderBy'] }
        : { orderBy?: CoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cours model
   */
  readonly fields: CoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    matiere<T extends Cours$matiereArgs<ExtArgs> = {}>(args?: Subset<T, Cours$matiereArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    salle<T extends Cours$salleArgs<ExtArgs> = {}>(args?: Subset<T, Cours$salleArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    classe<T extends Cours$classeArgs<ExtArgs> = {}>(args?: Subset<T, Cours$classeArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    professeur<T extends Cours$professeurArgs<ExtArgs> = {}>(args?: Subset<T, Cours$professeurArgs<ExtArgs>>): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    evaluationEtudiant<T extends Cours$evaluationEtudiantArgs<ExtArgs> = {}>(args?: Subset<T, Cours$evaluationEtudiantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationEtudiantsPayload<ExtArgs>, T, 'findMany'> | Null>;

    feuillePresences<T extends Cours$feuillePresencesArgs<ExtArgs> = {}>(args?: Subset<T, Cours$feuillePresencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'findMany'> | Null>;

    emploiDuTemps<T extends Cours$emploiDuTempsArgs<ExtArgs> = {}>(args?: Subset<T, Cours$emploiDuTempsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Cours model
   */ 
  interface CoursFieldRefs {
    readonly id: FieldRef<"Cours", 'Int'>
    readonly createdAt: FieldRef<"Cours", 'DateTime'>
    readonly updatedAt: FieldRef<"Cours", 'DateTime'>
    readonly nom: FieldRef<"Cours", 'String'>
    readonly description: FieldRef<"Cours", 'String'>
    readonly dateDebut: FieldRef<"Cours", 'DateTime'>
    readonly dateFin: FieldRef<"Cours", 'DateTime'>
    readonly heureDebut: FieldRef<"Cours", 'DateTime'>
    readonly heureFin: FieldRef<"Cours", 'DateTime'>
    readonly matiereId: FieldRef<"Cours", 'Int'>
    readonly salleId: FieldRef<"Cours", 'Int'>
    readonly classeId: FieldRef<"Cours", 'Int'>
    readonly professeurId: FieldRef<"Cours", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Cours findUnique
   */
  export type CoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    /**
     * Filter, which Cours to fetch.
     */
    where: CoursWhereUniqueInput
  }


  /**
   * Cours findUniqueOrThrow
   */
  export type CoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    /**
     * Filter, which Cours to fetch.
     */
    where: CoursWhereUniqueInput
  }


  /**
   * Cours findFirst
   */
  export type CoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    /**
     * Filter, which Cours to fetch.
     */
    where?: CoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cours to fetch.
     */
    orderBy?: CoursOrderByWithRelationInput | CoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cours.
     */
    cursor?: CoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cours.
     */
    distinct?: CoursScalarFieldEnum | CoursScalarFieldEnum[]
  }


  /**
   * Cours findFirstOrThrow
   */
  export type CoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    /**
     * Filter, which Cours to fetch.
     */
    where?: CoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cours to fetch.
     */
    orderBy?: CoursOrderByWithRelationInput | CoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cours.
     */
    cursor?: CoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cours.
     */
    distinct?: CoursScalarFieldEnum | CoursScalarFieldEnum[]
  }


  /**
   * Cours findMany
   */
  export type CoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    /**
     * Filter, which Cours to fetch.
     */
    where?: CoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cours to fetch.
     */
    orderBy?: CoursOrderByWithRelationInput | CoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cours.
     */
    cursor?: CoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cours.
     */
    skip?: number
    distinct?: CoursScalarFieldEnum | CoursScalarFieldEnum[]
  }


  /**
   * Cours create
   */
  export type CoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    /**
     * The data needed to create a Cours.
     */
    data: XOR<CoursCreateInput, CoursUncheckedCreateInput>
  }


  /**
   * Cours createMany
   */
  export type CoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cours.
     */
    data: CoursCreateManyInput | CoursCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Cours update
   */
  export type CoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    /**
     * The data needed to update a Cours.
     */
    data: XOR<CoursUpdateInput, CoursUncheckedUpdateInput>
    /**
     * Choose, which Cours to update.
     */
    where: CoursWhereUniqueInput
  }


  /**
   * Cours updateMany
   */
  export type CoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cours.
     */
    data: XOR<CoursUpdateManyMutationInput, CoursUncheckedUpdateManyInput>
    /**
     * Filter which Cours to update
     */
    where?: CoursWhereInput
  }


  /**
   * Cours upsert
   */
  export type CoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    /**
     * The filter to search for the Cours to update in case it exists.
     */
    where: CoursWhereUniqueInput
    /**
     * In case the Cours found by the `where` argument doesn't exist, create a new Cours with this data.
     */
    create: XOR<CoursCreateInput, CoursUncheckedCreateInput>
    /**
     * In case the Cours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoursUpdateInput, CoursUncheckedUpdateInput>
  }


  /**
   * Cours delete
   */
  export type CoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    /**
     * Filter which Cours to delete.
     */
    where: CoursWhereUniqueInput
  }


  /**
   * Cours deleteMany
   */
  export type CoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cours to delete
     */
    where?: CoursWhereInput
  }


  /**
   * Cours.matiere
   */
  export type Cours$matiereArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    where?: MatiereWhereInput
  }


  /**
   * Cours.salle
   */
  export type Cours$salleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    where?: SalleWhereInput
  }


  /**
   * Cours.classe
   */
  export type Cours$classeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClasseInclude<ExtArgs> | null
    where?: ClasseWhereInput
  }


  /**
   * Cours.professeur
   */
  export type Cours$professeurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    where?: ProfesseurWhereInput
  }


  /**
   * Cours.evaluationEtudiant
   */
  export type Cours$evaluationEtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEtudiants
     */
    select?: EvaluationEtudiantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationEtudiantsInclude<ExtArgs> | null
    where?: EvaluationEtudiantsWhereInput
    orderBy?: EvaluationEtudiantsOrderByWithRelationInput | EvaluationEtudiantsOrderByWithRelationInput[]
    cursor?: EvaluationEtudiantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationEtudiantsScalarFieldEnum | EvaluationEtudiantsScalarFieldEnum[]
  }


  /**
   * Cours.feuillePresences
   */
  export type Cours$feuillePresencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    where?: FeuillePresenceWhereInput
    orderBy?: FeuillePresenceOrderByWithRelationInput | FeuillePresenceOrderByWithRelationInput[]
    cursor?: FeuillePresenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeuillePresenceScalarFieldEnum | FeuillePresenceScalarFieldEnum[]
  }


  /**
   * Cours.emploiDuTemps
   */
  export type Cours$emploiDuTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    where?: EmploiDuTempsWhereInput
    orderBy?: EmploiDuTempsOrderByWithRelationInput | EmploiDuTempsOrderByWithRelationInput[]
    cursor?: EmploiDuTempsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploiDuTempsScalarFieldEnum | EmploiDuTempsScalarFieldEnum[]
  }


  /**
   * Cours without action
   */
  export type CoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
  }



  /**
   * Model Salle
   */

  export type AggregateSalle = {
    _count: SalleCountAggregateOutputType | null
    _avg: SalleAvgAggregateOutputType | null
    _sum: SalleSumAggregateOutputType | null
    _min: SalleMinAggregateOutputType | null
    _max: SalleMaxAggregateOutputType | null
  }

  export type SalleAvgAggregateOutputType = {
    id: number | null
    capacite: number | null
    etablissementId: number | null
  }

  export type SalleSumAggregateOutputType = {
    id: number | null
    capacite: number | null
    etablissementId: number | null
  }

  export type SalleMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    capacite: number | null
    batiment: string | null
    etablissementId: number | null
    estDisponible: boolean | null
  }

  export type SalleMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    capacite: number | null
    batiment: string | null
    etablissementId: number | null
    estDisponible: boolean | null
  }

  export type SalleCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    capacite: number
    batiment: number
    etablissementId: number
    estDisponible: number
    _all: number
  }


  export type SalleAvgAggregateInputType = {
    id?: true
    capacite?: true
    etablissementId?: true
  }

  export type SalleSumAggregateInputType = {
    id?: true
    capacite?: true
    etablissementId?: true
  }

  export type SalleMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    capacite?: true
    batiment?: true
    etablissementId?: true
    estDisponible?: true
  }

  export type SalleMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    capacite?: true
    batiment?: true
    etablissementId?: true
    estDisponible?: true
  }

  export type SalleCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    capacite?: true
    batiment?: true
    etablissementId?: true
    estDisponible?: true
    _all?: true
  }

  export type SalleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salle to aggregate.
     */
    where?: SalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salles to fetch.
     */
    orderBy?: SalleOrderByWithRelationInput | SalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salles
    **/
    _count?: true | SalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalleMaxAggregateInputType
  }

  export type GetSalleAggregateType<T extends SalleAggregateArgs> = {
        [P in keyof T & keyof AggregateSalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalle[P]>
      : GetScalarType<T[P], AggregateSalle[P]>
  }




  export type SalleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalleWhereInput
    orderBy?: SalleOrderByWithAggregationInput | SalleOrderByWithAggregationInput[]
    by: SalleScalarFieldEnum[] | SalleScalarFieldEnum
    having?: SalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalleCountAggregateInputType | true
    _avg?: SalleAvgAggregateInputType
    _sum?: SalleSumAggregateInputType
    _min?: SalleMinAggregateInputType
    _max?: SalleMaxAggregateInputType
  }

  export type SalleGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    capacite: number | null
    batiment: string | null
    etablissementId: number
    estDisponible: boolean
    _count: SalleCountAggregateOutputType | null
    _avg: SalleAvgAggregateOutputType | null
    _sum: SalleSumAggregateOutputType | null
    _min: SalleMinAggregateOutputType | null
    _max: SalleMaxAggregateOutputType | null
  }

  type GetSalleGroupByPayload<T extends SalleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalleGroupByOutputType[P]>
            : GetScalarType<T[P], SalleGroupByOutputType[P]>
        }
      >
    >


  export type SalleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    capacite?: boolean
    batiment?: boolean
    etablissementId?: boolean
    estDisponible?: boolean
    etablissement?: boolean | EtablissementDefaultArgs<ExtArgs>
    cours?: boolean | Salle$coursArgs<ExtArgs>
    EmploiDuTemps?: boolean | Salle$EmploiDuTempsArgs<ExtArgs>
    _count?: boolean | SalleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salle"]>

  export type SalleSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    capacite?: boolean
    batiment?: boolean
    etablissementId?: boolean
    estDisponible?: boolean
  }

  export type SalleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etablissement?: boolean | EtablissementDefaultArgs<ExtArgs>
    cours?: boolean | Salle$coursArgs<ExtArgs>
    EmploiDuTemps?: boolean | Salle$EmploiDuTempsArgs<ExtArgs>
    _count?: boolean | SalleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SallePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Salle"
    objects: {
      etablissement: Prisma.$EtablissementPayload<ExtArgs>
      cours: Prisma.$CoursPayload<ExtArgs>[]
      EmploiDuTemps: Prisma.$EmploiDuTempsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      capacite: number | null
      batiment: string | null
      etablissementId: number
      estDisponible: boolean
    }, ExtArgs["result"]["salle"]>
    composites: {}
  }


  type SalleGetPayload<S extends boolean | null | undefined | SalleDefaultArgs> = $Result.GetResult<Prisma.$SallePayload, S>

  type SalleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalleCountAggregateInputType | true
    }

  export interface SalleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Salle'], meta: { name: 'Salle' } }
    /**
     * Find zero or one Salle that matches the filter.
     * @param {SalleFindUniqueArgs} args - Arguments to find a Salle
     * @example
     * // Get one Salle
     * const salle = await prisma.salle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SalleFindUniqueArgs<ExtArgs>>
    ): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Salle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SalleFindUniqueOrThrowArgs} args - Arguments to find a Salle
     * @example
     * // Get one Salle
     * const salle = await prisma.salle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SalleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SalleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Salle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleFindFirstArgs} args - Arguments to find a Salle
     * @example
     * // Get one Salle
     * const salle = await prisma.salle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SalleFindFirstArgs<ExtArgs>>
    ): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Salle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleFindFirstOrThrowArgs} args - Arguments to find a Salle
     * @example
     * // Get one Salle
     * const salle = await prisma.salle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SalleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SalleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Salles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salles
     * const salles = await prisma.salle.findMany()
     * 
     * // Get first 10 Salles
     * const salles = await prisma.salle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salleWithIdOnly = await prisma.salle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SalleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Salle.
     * @param {SalleCreateArgs} args - Arguments to create a Salle.
     * @example
     * // Create one Salle
     * const Salle = await prisma.salle.create({
     *   data: {
     *     // ... data to create a Salle
     *   }
     * })
     * 
    **/
    create<T extends SalleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SalleCreateArgs<ExtArgs>>
    ): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Salles.
     *     @param {SalleCreateManyArgs} args - Arguments to create many Salles.
     *     @example
     *     // Create many Salles
     *     const salle = await prisma.salle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SalleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SalleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Salle.
     * @param {SalleDeleteArgs} args - Arguments to delete one Salle.
     * @example
     * // Delete one Salle
     * const Salle = await prisma.salle.delete({
     *   where: {
     *     // ... filter to delete one Salle
     *   }
     * })
     * 
    **/
    delete<T extends SalleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SalleDeleteArgs<ExtArgs>>
    ): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Salle.
     * @param {SalleUpdateArgs} args - Arguments to update one Salle.
     * @example
     * // Update one Salle
     * const salle = await prisma.salle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SalleUpdateArgs<ExtArgs>>
    ): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Salles.
     * @param {SalleDeleteManyArgs} args - Arguments to filter Salles to delete.
     * @example
     * // Delete a few Salles
     * const { count } = await prisma.salle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SalleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salles
     * const salle = await prisma.salle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SalleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Salle.
     * @param {SalleUpsertArgs} args - Arguments to update or create a Salle.
     * @example
     * // Update or create a Salle
     * const salle = await prisma.salle.upsert({
     *   create: {
     *     // ... data to create a Salle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salle we want to update
     *   }
     * })
    **/
    upsert<T extends SalleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SalleUpsertArgs<ExtArgs>>
    ): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Salles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleCountArgs} args - Arguments to filter Salles to count.
     * @example
     * // Count the number of Salles
     * const count = await prisma.salle.count({
     *   where: {
     *     // ... the filter for the Salles we want to count
     *   }
     * })
    **/
    count<T extends SalleCountArgs>(
      args?: Subset<T, SalleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalleAggregateArgs>(args: Subset<T, SalleAggregateArgs>): Prisma.PrismaPromise<GetSalleAggregateType<T>>

    /**
     * Group by Salle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalleGroupByArgs['orderBy'] }
        : { orderBy?: SalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Salle model
   */
  readonly fields: SalleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    etablissement<T extends EtablissementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtablissementDefaultArgs<ExtArgs>>): Prisma__EtablissementClient<$Result.GetResult<Prisma.$EtablissementPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cours<T extends Salle$coursArgs<ExtArgs> = {}>(args?: Subset<T, Salle$coursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findMany'> | Null>;

    EmploiDuTemps<T extends Salle$EmploiDuTempsArgs<ExtArgs> = {}>(args?: Subset<T, Salle$EmploiDuTempsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Salle model
   */ 
  interface SalleFieldRefs {
    readonly id: FieldRef<"Salle", 'Int'>
    readonly createdAt: FieldRef<"Salle", 'DateTime'>
    readonly updatedAt: FieldRef<"Salle", 'DateTime'>
    readonly nom: FieldRef<"Salle", 'String'>
    readonly capacite: FieldRef<"Salle", 'Int'>
    readonly batiment: FieldRef<"Salle", 'String'>
    readonly etablissementId: FieldRef<"Salle", 'Int'>
    readonly estDisponible: FieldRef<"Salle", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Salle findUnique
   */
  export type SalleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    /**
     * Filter, which Salle to fetch.
     */
    where: SalleWhereUniqueInput
  }


  /**
   * Salle findUniqueOrThrow
   */
  export type SalleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    /**
     * Filter, which Salle to fetch.
     */
    where: SalleWhereUniqueInput
  }


  /**
   * Salle findFirst
   */
  export type SalleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    /**
     * Filter, which Salle to fetch.
     */
    where?: SalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salles to fetch.
     */
    orderBy?: SalleOrderByWithRelationInput | SalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salles.
     */
    cursor?: SalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salles.
     */
    distinct?: SalleScalarFieldEnum | SalleScalarFieldEnum[]
  }


  /**
   * Salle findFirstOrThrow
   */
  export type SalleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    /**
     * Filter, which Salle to fetch.
     */
    where?: SalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salles to fetch.
     */
    orderBy?: SalleOrderByWithRelationInput | SalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salles.
     */
    cursor?: SalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salles.
     */
    distinct?: SalleScalarFieldEnum | SalleScalarFieldEnum[]
  }


  /**
   * Salle findMany
   */
  export type SalleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    /**
     * Filter, which Salles to fetch.
     */
    where?: SalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salles to fetch.
     */
    orderBy?: SalleOrderByWithRelationInput | SalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salles.
     */
    cursor?: SalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salles.
     */
    skip?: number
    distinct?: SalleScalarFieldEnum | SalleScalarFieldEnum[]
  }


  /**
   * Salle create
   */
  export type SalleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    /**
     * The data needed to create a Salle.
     */
    data: XOR<SalleCreateInput, SalleUncheckedCreateInput>
  }


  /**
   * Salle createMany
   */
  export type SalleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Salles.
     */
    data: SalleCreateManyInput | SalleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Salle update
   */
  export type SalleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    /**
     * The data needed to update a Salle.
     */
    data: XOR<SalleUpdateInput, SalleUncheckedUpdateInput>
    /**
     * Choose, which Salle to update.
     */
    where: SalleWhereUniqueInput
  }


  /**
   * Salle updateMany
   */
  export type SalleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Salles.
     */
    data: XOR<SalleUpdateManyMutationInput, SalleUncheckedUpdateManyInput>
    /**
     * Filter which Salles to update
     */
    where?: SalleWhereInput
  }


  /**
   * Salle upsert
   */
  export type SalleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    /**
     * The filter to search for the Salle to update in case it exists.
     */
    where: SalleWhereUniqueInput
    /**
     * In case the Salle found by the `where` argument doesn't exist, create a new Salle with this data.
     */
    create: XOR<SalleCreateInput, SalleUncheckedCreateInput>
    /**
     * In case the Salle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalleUpdateInput, SalleUncheckedUpdateInput>
  }


  /**
   * Salle delete
   */
  export type SalleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
    /**
     * Filter which Salle to delete.
     */
    where: SalleWhereUniqueInput
  }


  /**
   * Salle deleteMany
   */
  export type SalleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salles to delete
     */
    where?: SalleWhereInput
  }


  /**
   * Salle.cours
   */
  export type Salle$coursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cours
     */
    select?: CoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursInclude<ExtArgs> | null
    where?: CoursWhereInput
    orderBy?: CoursOrderByWithRelationInput | CoursOrderByWithRelationInput[]
    cursor?: CoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursScalarFieldEnum | CoursScalarFieldEnum[]
  }


  /**
   * Salle.EmploiDuTemps
   */
  export type Salle$EmploiDuTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    where?: EmploiDuTempsWhereInput
    orderBy?: EmploiDuTempsOrderByWithRelationInput | EmploiDuTempsOrderByWithRelationInput[]
    cursor?: EmploiDuTempsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploiDuTempsScalarFieldEnum | EmploiDuTempsScalarFieldEnum[]
  }


  /**
   * Salle without action
   */
  export type SalleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalleInclude<ExtArgs> | null
  }



  /**
   * Model FeuillePresence
   */

  export type AggregateFeuillePresence = {
    _count: FeuillePresenceCountAggregateOutputType | null
    _avg: FeuillePresenceAvgAggregateOutputType | null
    _sum: FeuillePresenceSumAggregateOutputType | null
    _min: FeuillePresenceMinAggregateOutputType | null
    _max: FeuillePresenceMaxAggregateOutputType | null
  }

  export type FeuillePresenceAvgAggregateOutputType = {
    id: number | null
    coursId: number | null
    etudiantId: number | null
  }

  export type FeuillePresenceSumAggregateOutputType = {
    id: number | null
    coursId: number | null
    etudiantId: number | null
  }

  export type FeuillePresenceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    heureDebut: Date | null
    heureFin: Date | null
    coursId: number | null
    etudiantId: number | null
  }

  export type FeuillePresenceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    heureDebut: Date | null
    heureFin: Date | null
    coursId: number | null
    etudiantId: number | null
  }

  export type FeuillePresenceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    date: number
    heureDebut: number
    heureFin: number
    coursId: number
    etudiantId: number
    _all: number
  }


  export type FeuillePresenceAvgAggregateInputType = {
    id?: true
    coursId?: true
    etudiantId?: true
  }

  export type FeuillePresenceSumAggregateInputType = {
    id?: true
    coursId?: true
    etudiantId?: true
  }

  export type FeuillePresenceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    heureDebut?: true
    heureFin?: true
    coursId?: true
    etudiantId?: true
  }

  export type FeuillePresenceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    heureDebut?: true
    heureFin?: true
    coursId?: true
    etudiantId?: true
  }

  export type FeuillePresenceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    heureDebut?: true
    heureFin?: true
    coursId?: true
    etudiantId?: true
    _all?: true
  }

  export type FeuillePresenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeuillePresence to aggregate.
     */
    where?: FeuillePresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeuillePresences to fetch.
     */
    orderBy?: FeuillePresenceOrderByWithRelationInput | FeuillePresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeuillePresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeuillePresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeuillePresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeuillePresences
    **/
    _count?: true | FeuillePresenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeuillePresenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeuillePresenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeuillePresenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeuillePresenceMaxAggregateInputType
  }

  export type GetFeuillePresenceAggregateType<T extends FeuillePresenceAggregateArgs> = {
        [P in keyof T & keyof AggregateFeuillePresence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeuillePresence[P]>
      : GetScalarType<T[P], AggregateFeuillePresence[P]>
  }




  export type FeuillePresenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeuillePresenceWhereInput
    orderBy?: FeuillePresenceOrderByWithAggregationInput | FeuillePresenceOrderByWithAggregationInput[]
    by: FeuillePresenceScalarFieldEnum[] | FeuillePresenceScalarFieldEnum
    having?: FeuillePresenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeuillePresenceCountAggregateInputType | true
    _avg?: FeuillePresenceAvgAggregateInputType
    _sum?: FeuillePresenceSumAggregateInputType
    _min?: FeuillePresenceMinAggregateInputType
    _max?: FeuillePresenceMaxAggregateInputType
  }

  export type FeuillePresenceGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    date: Date
    heureDebut: Date
    heureFin: Date
    coursId: number
    etudiantId: number | null
    _count: FeuillePresenceCountAggregateOutputType | null
    _avg: FeuillePresenceAvgAggregateOutputType | null
    _sum: FeuillePresenceSumAggregateOutputType | null
    _min: FeuillePresenceMinAggregateOutputType | null
    _max: FeuillePresenceMaxAggregateOutputType | null
  }

  type GetFeuillePresenceGroupByPayload<T extends FeuillePresenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeuillePresenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeuillePresenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeuillePresenceGroupByOutputType[P]>
            : GetScalarType<T[P], FeuillePresenceGroupByOutputType[P]>
        }
      >
    >


  export type FeuillePresenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    coursId?: boolean
    etudiantId?: boolean
    cours?: boolean | CoursDefaultArgs<ExtArgs>
    etudiant?: boolean | FeuillePresence$etudiantArgs<ExtArgs>
  }, ExtArgs["result"]["feuillePresence"]>

  export type FeuillePresenceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    coursId?: boolean
    etudiantId?: boolean
  }

  export type FeuillePresenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cours?: boolean | CoursDefaultArgs<ExtArgs>
    etudiant?: boolean | FeuillePresence$etudiantArgs<ExtArgs>
  }


  export type $FeuillePresencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeuillePresence"
    objects: {
      cours: Prisma.$CoursPayload<ExtArgs>
      etudiant: Prisma.$EtudiantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      date: Date
      heureDebut: Date
      heureFin: Date
      coursId: number
      etudiantId: number | null
    }, ExtArgs["result"]["feuillePresence"]>
    composites: {}
  }


  type FeuillePresenceGetPayload<S extends boolean | null | undefined | FeuillePresenceDefaultArgs> = $Result.GetResult<Prisma.$FeuillePresencePayload, S>

  type FeuillePresenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeuillePresenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeuillePresenceCountAggregateInputType | true
    }

  export interface FeuillePresenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeuillePresence'], meta: { name: 'FeuillePresence' } }
    /**
     * Find zero or one FeuillePresence that matches the filter.
     * @param {FeuillePresenceFindUniqueArgs} args - Arguments to find a FeuillePresence
     * @example
     * // Get one FeuillePresence
     * const feuillePresence = await prisma.feuillePresence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeuillePresenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeuillePresenceFindUniqueArgs<ExtArgs>>
    ): Prisma__FeuillePresenceClient<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FeuillePresence that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeuillePresenceFindUniqueOrThrowArgs} args - Arguments to find a FeuillePresence
     * @example
     * // Get one FeuillePresence
     * const feuillePresence = await prisma.feuillePresence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeuillePresenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeuillePresenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeuillePresenceClient<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FeuillePresence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeuillePresenceFindFirstArgs} args - Arguments to find a FeuillePresence
     * @example
     * // Get one FeuillePresence
     * const feuillePresence = await prisma.feuillePresence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeuillePresenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeuillePresenceFindFirstArgs<ExtArgs>>
    ): Prisma__FeuillePresenceClient<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FeuillePresence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeuillePresenceFindFirstOrThrowArgs} args - Arguments to find a FeuillePresence
     * @example
     * // Get one FeuillePresence
     * const feuillePresence = await prisma.feuillePresence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeuillePresenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeuillePresenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeuillePresenceClient<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FeuillePresences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeuillePresenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeuillePresences
     * const feuillePresences = await prisma.feuillePresence.findMany()
     * 
     * // Get first 10 FeuillePresences
     * const feuillePresences = await prisma.feuillePresence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feuillePresenceWithIdOnly = await prisma.feuillePresence.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeuillePresenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeuillePresenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FeuillePresence.
     * @param {FeuillePresenceCreateArgs} args - Arguments to create a FeuillePresence.
     * @example
     * // Create one FeuillePresence
     * const FeuillePresence = await prisma.feuillePresence.create({
     *   data: {
     *     // ... data to create a FeuillePresence
     *   }
     * })
     * 
    **/
    create<T extends FeuillePresenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeuillePresenceCreateArgs<ExtArgs>>
    ): Prisma__FeuillePresenceClient<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FeuillePresences.
     *     @param {FeuillePresenceCreateManyArgs} args - Arguments to create many FeuillePresences.
     *     @example
     *     // Create many FeuillePresences
     *     const feuillePresence = await prisma.feuillePresence.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeuillePresenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeuillePresenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeuillePresence.
     * @param {FeuillePresenceDeleteArgs} args - Arguments to delete one FeuillePresence.
     * @example
     * // Delete one FeuillePresence
     * const FeuillePresence = await prisma.feuillePresence.delete({
     *   where: {
     *     // ... filter to delete one FeuillePresence
     *   }
     * })
     * 
    **/
    delete<T extends FeuillePresenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeuillePresenceDeleteArgs<ExtArgs>>
    ): Prisma__FeuillePresenceClient<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FeuillePresence.
     * @param {FeuillePresenceUpdateArgs} args - Arguments to update one FeuillePresence.
     * @example
     * // Update one FeuillePresence
     * const feuillePresence = await prisma.feuillePresence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeuillePresenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeuillePresenceUpdateArgs<ExtArgs>>
    ): Prisma__FeuillePresenceClient<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FeuillePresences.
     * @param {FeuillePresenceDeleteManyArgs} args - Arguments to filter FeuillePresences to delete.
     * @example
     * // Delete a few FeuillePresences
     * const { count } = await prisma.feuillePresence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeuillePresenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeuillePresenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeuillePresences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeuillePresenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeuillePresences
     * const feuillePresence = await prisma.feuillePresence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeuillePresenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeuillePresenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeuillePresence.
     * @param {FeuillePresenceUpsertArgs} args - Arguments to update or create a FeuillePresence.
     * @example
     * // Update or create a FeuillePresence
     * const feuillePresence = await prisma.feuillePresence.upsert({
     *   create: {
     *     // ... data to create a FeuillePresence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeuillePresence we want to update
     *   }
     * })
    **/
    upsert<T extends FeuillePresenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeuillePresenceUpsertArgs<ExtArgs>>
    ): Prisma__FeuillePresenceClient<$Result.GetResult<Prisma.$FeuillePresencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FeuillePresences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeuillePresenceCountArgs} args - Arguments to filter FeuillePresences to count.
     * @example
     * // Count the number of FeuillePresences
     * const count = await prisma.feuillePresence.count({
     *   where: {
     *     // ... the filter for the FeuillePresences we want to count
     *   }
     * })
    **/
    count<T extends FeuillePresenceCountArgs>(
      args?: Subset<T, FeuillePresenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeuillePresenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeuillePresence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeuillePresenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeuillePresenceAggregateArgs>(args: Subset<T, FeuillePresenceAggregateArgs>): Prisma.PrismaPromise<GetFeuillePresenceAggregateType<T>>

    /**
     * Group by FeuillePresence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeuillePresenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeuillePresenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeuillePresenceGroupByArgs['orderBy'] }
        : { orderBy?: FeuillePresenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeuillePresenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeuillePresenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeuillePresence model
   */
  readonly fields: FeuillePresenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeuillePresence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeuillePresenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cours<T extends CoursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursDefaultArgs<ExtArgs>>): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    etudiant<T extends FeuillePresence$etudiantArgs<ExtArgs> = {}>(args?: Subset<T, FeuillePresence$etudiantArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FeuillePresence model
   */ 
  interface FeuillePresenceFieldRefs {
    readonly id: FieldRef<"FeuillePresence", 'Int'>
    readonly createdAt: FieldRef<"FeuillePresence", 'DateTime'>
    readonly updatedAt: FieldRef<"FeuillePresence", 'DateTime'>
    readonly date: FieldRef<"FeuillePresence", 'DateTime'>
    readonly heureDebut: FieldRef<"FeuillePresence", 'DateTime'>
    readonly heureFin: FieldRef<"FeuillePresence", 'DateTime'>
    readonly coursId: FieldRef<"FeuillePresence", 'Int'>
    readonly etudiantId: FieldRef<"FeuillePresence", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * FeuillePresence findUnique
   */
  export type FeuillePresenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    /**
     * Filter, which FeuillePresence to fetch.
     */
    where: FeuillePresenceWhereUniqueInput
  }


  /**
   * FeuillePresence findUniqueOrThrow
   */
  export type FeuillePresenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    /**
     * Filter, which FeuillePresence to fetch.
     */
    where: FeuillePresenceWhereUniqueInput
  }


  /**
   * FeuillePresence findFirst
   */
  export type FeuillePresenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    /**
     * Filter, which FeuillePresence to fetch.
     */
    where?: FeuillePresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeuillePresences to fetch.
     */
    orderBy?: FeuillePresenceOrderByWithRelationInput | FeuillePresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeuillePresences.
     */
    cursor?: FeuillePresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeuillePresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeuillePresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeuillePresences.
     */
    distinct?: FeuillePresenceScalarFieldEnum | FeuillePresenceScalarFieldEnum[]
  }


  /**
   * FeuillePresence findFirstOrThrow
   */
  export type FeuillePresenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    /**
     * Filter, which FeuillePresence to fetch.
     */
    where?: FeuillePresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeuillePresences to fetch.
     */
    orderBy?: FeuillePresenceOrderByWithRelationInput | FeuillePresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeuillePresences.
     */
    cursor?: FeuillePresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeuillePresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeuillePresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeuillePresences.
     */
    distinct?: FeuillePresenceScalarFieldEnum | FeuillePresenceScalarFieldEnum[]
  }


  /**
   * FeuillePresence findMany
   */
  export type FeuillePresenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    /**
     * Filter, which FeuillePresences to fetch.
     */
    where?: FeuillePresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeuillePresences to fetch.
     */
    orderBy?: FeuillePresenceOrderByWithRelationInput | FeuillePresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeuillePresences.
     */
    cursor?: FeuillePresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeuillePresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeuillePresences.
     */
    skip?: number
    distinct?: FeuillePresenceScalarFieldEnum | FeuillePresenceScalarFieldEnum[]
  }


  /**
   * FeuillePresence create
   */
  export type FeuillePresenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    /**
     * The data needed to create a FeuillePresence.
     */
    data: XOR<FeuillePresenceCreateInput, FeuillePresenceUncheckedCreateInput>
  }


  /**
   * FeuillePresence createMany
   */
  export type FeuillePresenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeuillePresences.
     */
    data: FeuillePresenceCreateManyInput | FeuillePresenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FeuillePresence update
   */
  export type FeuillePresenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    /**
     * The data needed to update a FeuillePresence.
     */
    data: XOR<FeuillePresenceUpdateInput, FeuillePresenceUncheckedUpdateInput>
    /**
     * Choose, which FeuillePresence to update.
     */
    where: FeuillePresenceWhereUniqueInput
  }


  /**
   * FeuillePresence updateMany
   */
  export type FeuillePresenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeuillePresences.
     */
    data: XOR<FeuillePresenceUpdateManyMutationInput, FeuillePresenceUncheckedUpdateManyInput>
    /**
     * Filter which FeuillePresences to update
     */
    where?: FeuillePresenceWhereInput
  }


  /**
   * FeuillePresence upsert
   */
  export type FeuillePresenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    /**
     * The filter to search for the FeuillePresence to update in case it exists.
     */
    where: FeuillePresenceWhereUniqueInput
    /**
     * In case the FeuillePresence found by the `where` argument doesn't exist, create a new FeuillePresence with this data.
     */
    create: XOR<FeuillePresenceCreateInput, FeuillePresenceUncheckedCreateInput>
    /**
     * In case the FeuillePresence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeuillePresenceUpdateInput, FeuillePresenceUncheckedUpdateInput>
  }


  /**
   * FeuillePresence delete
   */
  export type FeuillePresenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
    /**
     * Filter which FeuillePresence to delete.
     */
    where: FeuillePresenceWhereUniqueInput
  }


  /**
   * FeuillePresence deleteMany
   */
  export type FeuillePresenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeuillePresences to delete
     */
    where?: FeuillePresenceWhereInput
  }


  /**
   * FeuillePresence.etudiant
   */
  export type FeuillePresence$etudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    where?: EtudiantWhereInput
  }


  /**
   * FeuillePresence without action
   */
  export type FeuillePresenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeuillePresence
     */
    select?: FeuillePresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeuillePresenceInclude<ExtArgs> | null
  }



  /**
   * Model EmploiDuTemps
   */

  export type AggregateEmploiDuTemps = {
    _count: EmploiDuTempsCountAggregateOutputType | null
    _avg: EmploiDuTempsAvgAggregateOutputType | null
    _sum: EmploiDuTempsSumAggregateOutputType | null
    _min: EmploiDuTempsMinAggregateOutputType | null
    _max: EmploiDuTempsMaxAggregateOutputType | null
  }

  export type EmploiDuTempsAvgAggregateOutputType = {
    id: number | null
    coursId: number | null
    classeId: number | null
    professeurId: number | null
    salleId: number | null
  }

  export type EmploiDuTempsSumAggregateOutputType = {
    id: number | null
    coursId: number | null
    classeId: number | null
    professeurId: number | null
    salleId: number | null
  }

  export type EmploiDuTempsMinAggregateOutputType = {
    id: number | null
    coursId: number | null
    classeId: number | null
    professeurId: number | null
    salleId: number | null
    dateDebut: Date | null
    dateFin: Date | null
  }

  export type EmploiDuTempsMaxAggregateOutputType = {
    id: number | null
    coursId: number | null
    classeId: number | null
    professeurId: number | null
    salleId: number | null
    dateDebut: Date | null
    dateFin: Date | null
  }

  export type EmploiDuTempsCountAggregateOutputType = {
    id: number
    coursId: number
    classeId: number
    professeurId: number
    salleId: number
    dateDebut: number
    dateFin: number
    _all: number
  }


  export type EmploiDuTempsAvgAggregateInputType = {
    id?: true
    coursId?: true
    classeId?: true
    professeurId?: true
    salleId?: true
  }

  export type EmploiDuTempsSumAggregateInputType = {
    id?: true
    coursId?: true
    classeId?: true
    professeurId?: true
    salleId?: true
  }

  export type EmploiDuTempsMinAggregateInputType = {
    id?: true
    coursId?: true
    classeId?: true
    professeurId?: true
    salleId?: true
    dateDebut?: true
    dateFin?: true
  }

  export type EmploiDuTempsMaxAggregateInputType = {
    id?: true
    coursId?: true
    classeId?: true
    professeurId?: true
    salleId?: true
    dateDebut?: true
    dateFin?: true
  }

  export type EmploiDuTempsCountAggregateInputType = {
    id?: true
    coursId?: true
    classeId?: true
    professeurId?: true
    salleId?: true
    dateDebut?: true
    dateFin?: true
    _all?: true
  }

  export type EmploiDuTempsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploiDuTemps to aggregate.
     */
    where?: EmploiDuTempsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploiDuTemps to fetch.
     */
    orderBy?: EmploiDuTempsOrderByWithRelationInput | EmploiDuTempsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmploiDuTempsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploiDuTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploiDuTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmploiDuTemps
    **/
    _count?: true | EmploiDuTempsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmploiDuTempsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmploiDuTempsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmploiDuTempsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmploiDuTempsMaxAggregateInputType
  }

  export type GetEmploiDuTempsAggregateType<T extends EmploiDuTempsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmploiDuTemps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmploiDuTemps[P]>
      : GetScalarType<T[P], AggregateEmploiDuTemps[P]>
  }




  export type EmploiDuTempsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploiDuTempsWhereInput
    orderBy?: EmploiDuTempsOrderByWithAggregationInput | EmploiDuTempsOrderByWithAggregationInput[]
    by: EmploiDuTempsScalarFieldEnum[] | EmploiDuTempsScalarFieldEnum
    having?: EmploiDuTempsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmploiDuTempsCountAggregateInputType | true
    _avg?: EmploiDuTempsAvgAggregateInputType
    _sum?: EmploiDuTempsSumAggregateInputType
    _min?: EmploiDuTempsMinAggregateInputType
    _max?: EmploiDuTempsMaxAggregateInputType
  }

  export type EmploiDuTempsGroupByOutputType = {
    id: number
    coursId: number
    classeId: number
    professeurId: number | null
    salleId: number
    dateDebut: Date
    dateFin: Date
    _count: EmploiDuTempsCountAggregateOutputType | null
    _avg: EmploiDuTempsAvgAggregateOutputType | null
    _sum: EmploiDuTempsSumAggregateOutputType | null
    _min: EmploiDuTempsMinAggregateOutputType | null
    _max: EmploiDuTempsMaxAggregateOutputType | null
  }

  type GetEmploiDuTempsGroupByPayload<T extends EmploiDuTempsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmploiDuTempsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmploiDuTempsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmploiDuTempsGroupByOutputType[P]>
            : GetScalarType<T[P], EmploiDuTempsGroupByOutputType[P]>
        }
      >
    >


  export type EmploiDuTempsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coursId?: boolean
    classeId?: boolean
    professeurId?: boolean
    salleId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    cours?: boolean | CoursDefaultArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    professeur?: boolean | EmploiDuTemps$professeurArgs<ExtArgs>
    salle?: boolean | SalleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emploiDuTemps"]>

  export type EmploiDuTempsSelectScalar = {
    id?: boolean
    coursId?: boolean
    classeId?: boolean
    professeurId?: boolean
    salleId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
  }

  export type EmploiDuTempsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cours?: boolean | CoursDefaultArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    professeur?: boolean | EmploiDuTemps$professeurArgs<ExtArgs>
    salle?: boolean | SalleDefaultArgs<ExtArgs>
  }


  export type $EmploiDuTempsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmploiDuTemps"
    objects: {
      cours: Prisma.$CoursPayload<ExtArgs>
      classe: Prisma.$ClassePayload<ExtArgs>
      professeur: Prisma.$ProfesseurPayload<ExtArgs> | null
      salle: Prisma.$SallePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      coursId: number
      classeId: number
      professeurId: number | null
      salleId: number
      dateDebut: Date
      dateFin: Date
    }, ExtArgs["result"]["emploiDuTemps"]>
    composites: {}
  }


  type EmploiDuTempsGetPayload<S extends boolean | null | undefined | EmploiDuTempsDefaultArgs> = $Result.GetResult<Prisma.$EmploiDuTempsPayload, S>

  type EmploiDuTempsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmploiDuTempsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmploiDuTempsCountAggregateInputType | true
    }

  export interface EmploiDuTempsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmploiDuTemps'], meta: { name: 'EmploiDuTemps' } }
    /**
     * Find zero or one EmploiDuTemps that matches the filter.
     * @param {EmploiDuTempsFindUniqueArgs} args - Arguments to find a EmploiDuTemps
     * @example
     * // Get one EmploiDuTemps
     * const emploiDuTemps = await prisma.emploiDuTemps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmploiDuTempsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmploiDuTempsFindUniqueArgs<ExtArgs>>
    ): Prisma__EmploiDuTempsClient<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmploiDuTemps that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmploiDuTempsFindUniqueOrThrowArgs} args - Arguments to find a EmploiDuTemps
     * @example
     * // Get one EmploiDuTemps
     * const emploiDuTemps = await prisma.emploiDuTemps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmploiDuTempsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploiDuTempsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmploiDuTempsClient<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmploiDuTemps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploiDuTempsFindFirstArgs} args - Arguments to find a EmploiDuTemps
     * @example
     * // Get one EmploiDuTemps
     * const emploiDuTemps = await prisma.emploiDuTemps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmploiDuTempsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploiDuTempsFindFirstArgs<ExtArgs>>
    ): Prisma__EmploiDuTempsClient<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmploiDuTemps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploiDuTempsFindFirstOrThrowArgs} args - Arguments to find a EmploiDuTemps
     * @example
     * // Get one EmploiDuTemps
     * const emploiDuTemps = await prisma.emploiDuTemps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmploiDuTempsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploiDuTempsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmploiDuTempsClient<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmploiDuTemps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploiDuTempsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmploiDuTemps
     * const emploiDuTemps = await prisma.emploiDuTemps.findMany()
     * 
     * // Get first 10 EmploiDuTemps
     * const emploiDuTemps = await prisma.emploiDuTemps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emploiDuTempsWithIdOnly = await prisma.emploiDuTemps.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmploiDuTempsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploiDuTempsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmploiDuTemps.
     * @param {EmploiDuTempsCreateArgs} args - Arguments to create a EmploiDuTemps.
     * @example
     * // Create one EmploiDuTemps
     * const EmploiDuTemps = await prisma.emploiDuTemps.create({
     *   data: {
     *     // ... data to create a EmploiDuTemps
     *   }
     * })
     * 
    **/
    create<T extends EmploiDuTempsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmploiDuTempsCreateArgs<ExtArgs>>
    ): Prisma__EmploiDuTempsClient<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmploiDuTemps.
     *     @param {EmploiDuTempsCreateManyArgs} args - Arguments to create many EmploiDuTemps.
     *     @example
     *     // Create many EmploiDuTemps
     *     const emploiDuTemps = await prisma.emploiDuTemps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmploiDuTempsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploiDuTempsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmploiDuTemps.
     * @param {EmploiDuTempsDeleteArgs} args - Arguments to delete one EmploiDuTemps.
     * @example
     * // Delete one EmploiDuTemps
     * const EmploiDuTemps = await prisma.emploiDuTemps.delete({
     *   where: {
     *     // ... filter to delete one EmploiDuTemps
     *   }
     * })
     * 
    **/
    delete<T extends EmploiDuTempsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmploiDuTempsDeleteArgs<ExtArgs>>
    ): Prisma__EmploiDuTempsClient<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmploiDuTemps.
     * @param {EmploiDuTempsUpdateArgs} args - Arguments to update one EmploiDuTemps.
     * @example
     * // Update one EmploiDuTemps
     * const emploiDuTemps = await prisma.emploiDuTemps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmploiDuTempsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmploiDuTempsUpdateArgs<ExtArgs>>
    ): Prisma__EmploiDuTempsClient<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmploiDuTemps.
     * @param {EmploiDuTempsDeleteManyArgs} args - Arguments to filter EmploiDuTemps to delete.
     * @example
     * // Delete a few EmploiDuTemps
     * const { count } = await prisma.emploiDuTemps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmploiDuTempsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploiDuTempsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmploiDuTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploiDuTempsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmploiDuTemps
     * const emploiDuTemps = await prisma.emploiDuTemps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmploiDuTempsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmploiDuTempsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmploiDuTemps.
     * @param {EmploiDuTempsUpsertArgs} args - Arguments to update or create a EmploiDuTemps.
     * @example
     * // Update or create a EmploiDuTemps
     * const emploiDuTemps = await prisma.emploiDuTemps.upsert({
     *   create: {
     *     // ... data to create a EmploiDuTemps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmploiDuTemps we want to update
     *   }
     * })
    **/
    upsert<T extends EmploiDuTempsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmploiDuTempsUpsertArgs<ExtArgs>>
    ): Prisma__EmploiDuTempsClient<$Result.GetResult<Prisma.$EmploiDuTempsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmploiDuTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploiDuTempsCountArgs} args - Arguments to filter EmploiDuTemps to count.
     * @example
     * // Count the number of EmploiDuTemps
     * const count = await prisma.emploiDuTemps.count({
     *   where: {
     *     // ... the filter for the EmploiDuTemps we want to count
     *   }
     * })
    **/
    count<T extends EmploiDuTempsCountArgs>(
      args?: Subset<T, EmploiDuTempsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmploiDuTempsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmploiDuTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploiDuTempsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmploiDuTempsAggregateArgs>(args: Subset<T, EmploiDuTempsAggregateArgs>): Prisma.PrismaPromise<GetEmploiDuTempsAggregateType<T>>

    /**
     * Group by EmploiDuTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploiDuTempsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmploiDuTempsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmploiDuTempsGroupByArgs['orderBy'] }
        : { orderBy?: EmploiDuTempsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmploiDuTempsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmploiDuTempsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmploiDuTemps model
   */
  readonly fields: EmploiDuTempsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmploiDuTemps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmploiDuTempsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cours<T extends CoursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursDefaultArgs<ExtArgs>>): Prisma__CoursClient<$Result.GetResult<Prisma.$CoursPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    classe<T extends ClasseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClasseDefaultArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    professeur<T extends EmploiDuTemps$professeurArgs<ExtArgs> = {}>(args?: Subset<T, EmploiDuTemps$professeurArgs<ExtArgs>>): Prisma__ProfesseurClient<$Result.GetResult<Prisma.$ProfesseurPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    salle<T extends SalleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalleDefaultArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmploiDuTemps model
   */ 
  interface EmploiDuTempsFieldRefs {
    readonly id: FieldRef<"EmploiDuTemps", 'Int'>
    readonly coursId: FieldRef<"EmploiDuTemps", 'Int'>
    readonly classeId: FieldRef<"EmploiDuTemps", 'Int'>
    readonly professeurId: FieldRef<"EmploiDuTemps", 'Int'>
    readonly salleId: FieldRef<"EmploiDuTemps", 'Int'>
    readonly dateDebut: FieldRef<"EmploiDuTemps", 'DateTime'>
    readonly dateFin: FieldRef<"EmploiDuTemps", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmploiDuTemps findUnique
   */
  export type EmploiDuTempsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    /**
     * Filter, which EmploiDuTemps to fetch.
     */
    where: EmploiDuTempsWhereUniqueInput
  }


  /**
   * EmploiDuTemps findUniqueOrThrow
   */
  export type EmploiDuTempsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    /**
     * Filter, which EmploiDuTemps to fetch.
     */
    where: EmploiDuTempsWhereUniqueInput
  }


  /**
   * EmploiDuTemps findFirst
   */
  export type EmploiDuTempsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    /**
     * Filter, which EmploiDuTemps to fetch.
     */
    where?: EmploiDuTempsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploiDuTemps to fetch.
     */
    orderBy?: EmploiDuTempsOrderByWithRelationInput | EmploiDuTempsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploiDuTemps.
     */
    cursor?: EmploiDuTempsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploiDuTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploiDuTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploiDuTemps.
     */
    distinct?: EmploiDuTempsScalarFieldEnum | EmploiDuTempsScalarFieldEnum[]
  }


  /**
   * EmploiDuTemps findFirstOrThrow
   */
  export type EmploiDuTempsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    /**
     * Filter, which EmploiDuTemps to fetch.
     */
    where?: EmploiDuTempsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploiDuTemps to fetch.
     */
    orderBy?: EmploiDuTempsOrderByWithRelationInput | EmploiDuTempsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploiDuTemps.
     */
    cursor?: EmploiDuTempsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploiDuTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploiDuTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploiDuTemps.
     */
    distinct?: EmploiDuTempsScalarFieldEnum | EmploiDuTempsScalarFieldEnum[]
  }


  /**
   * EmploiDuTemps findMany
   */
  export type EmploiDuTempsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    /**
     * Filter, which EmploiDuTemps to fetch.
     */
    where?: EmploiDuTempsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploiDuTemps to fetch.
     */
    orderBy?: EmploiDuTempsOrderByWithRelationInput | EmploiDuTempsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmploiDuTemps.
     */
    cursor?: EmploiDuTempsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploiDuTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploiDuTemps.
     */
    skip?: number
    distinct?: EmploiDuTempsScalarFieldEnum | EmploiDuTempsScalarFieldEnum[]
  }


  /**
   * EmploiDuTemps create
   */
  export type EmploiDuTempsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    /**
     * The data needed to create a EmploiDuTemps.
     */
    data: XOR<EmploiDuTempsCreateInput, EmploiDuTempsUncheckedCreateInput>
  }


  /**
   * EmploiDuTemps createMany
   */
  export type EmploiDuTempsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmploiDuTemps.
     */
    data: EmploiDuTempsCreateManyInput | EmploiDuTempsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmploiDuTemps update
   */
  export type EmploiDuTempsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    /**
     * The data needed to update a EmploiDuTemps.
     */
    data: XOR<EmploiDuTempsUpdateInput, EmploiDuTempsUncheckedUpdateInput>
    /**
     * Choose, which EmploiDuTemps to update.
     */
    where: EmploiDuTempsWhereUniqueInput
  }


  /**
   * EmploiDuTemps updateMany
   */
  export type EmploiDuTempsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmploiDuTemps.
     */
    data: XOR<EmploiDuTempsUpdateManyMutationInput, EmploiDuTempsUncheckedUpdateManyInput>
    /**
     * Filter which EmploiDuTemps to update
     */
    where?: EmploiDuTempsWhereInput
  }


  /**
   * EmploiDuTemps upsert
   */
  export type EmploiDuTempsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    /**
     * The filter to search for the EmploiDuTemps to update in case it exists.
     */
    where: EmploiDuTempsWhereUniqueInput
    /**
     * In case the EmploiDuTemps found by the `where` argument doesn't exist, create a new EmploiDuTemps with this data.
     */
    create: XOR<EmploiDuTempsCreateInput, EmploiDuTempsUncheckedCreateInput>
    /**
     * In case the EmploiDuTemps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmploiDuTempsUpdateInput, EmploiDuTempsUncheckedUpdateInput>
  }


  /**
   * EmploiDuTemps delete
   */
  export type EmploiDuTempsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
    /**
     * Filter which EmploiDuTemps to delete.
     */
    where: EmploiDuTempsWhereUniqueInput
  }


  /**
   * EmploiDuTemps deleteMany
   */
  export type EmploiDuTempsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploiDuTemps to delete
     */
    where?: EmploiDuTempsWhereInput
  }


  /**
   * EmploiDuTemps.professeur
   */
  export type EmploiDuTemps$professeurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Professeur
     */
    select?: ProfesseurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurInclude<ExtArgs> | null
    where?: ProfesseurWhereInput
  }


  /**
   * EmploiDuTemps without action
   */
  export type EmploiDuTempsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploiDuTemps
     */
    select?: EmploiDuTempsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploiDuTempsInclude<ExtArgs> | null
  }



  /**
   * Model Paiement
   */

  export type AggregatePaiement = {
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  export type PaiementAvgAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    montant: number | null
  }

  export type PaiementSumAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    montant: number | null
  }

  export type PaiementMinAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    montant: number | null
    datePaiement: Date | null
    methodePaiement: string | null
    referencePaiement: string | null
    typeFrais: string | null
    statutPaiement: string | null
  }

  export type PaiementMaxAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    montant: number | null
    datePaiement: Date | null
    methodePaiement: string | null
    referencePaiement: string | null
    typeFrais: string | null
    statutPaiement: string | null
  }

  export type PaiementCountAggregateOutputType = {
    id: number
    etudiantId: number
    montant: number
    datePaiement: number
    methodePaiement: number
    referencePaiement: number
    typeFrais: number
    statutPaiement: number
    _all: number
  }


  export type PaiementAvgAggregateInputType = {
    id?: true
    etudiantId?: true
    montant?: true
  }

  export type PaiementSumAggregateInputType = {
    id?: true
    etudiantId?: true
    montant?: true
  }

  export type PaiementMinAggregateInputType = {
    id?: true
    etudiantId?: true
    montant?: true
    datePaiement?: true
    methodePaiement?: true
    referencePaiement?: true
    typeFrais?: true
    statutPaiement?: true
  }

  export type PaiementMaxAggregateInputType = {
    id?: true
    etudiantId?: true
    montant?: true
    datePaiement?: true
    methodePaiement?: true
    referencePaiement?: true
    typeFrais?: true
    statutPaiement?: true
  }

  export type PaiementCountAggregateInputType = {
    id?: true
    etudiantId?: true
    montant?: true
    datePaiement?: true
    methodePaiement?: true
    referencePaiement?: true
    typeFrais?: true
    statutPaiement?: true
    _all?: true
  }

  export type PaiementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiement to aggregate.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paiements
    **/
    _count?: true | PaiementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaiementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaiementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaiementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaiementMaxAggregateInputType
  }

  export type GetPaiementAggregateType<T extends PaiementAggregateArgs> = {
        [P in keyof T & keyof AggregatePaiement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaiement[P]>
      : GetScalarType<T[P], AggregatePaiement[P]>
  }




  export type PaiementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithAggregationInput | PaiementOrderByWithAggregationInput[]
    by: PaiementScalarFieldEnum[] | PaiementScalarFieldEnum
    having?: PaiementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaiementCountAggregateInputType | true
    _avg?: PaiementAvgAggregateInputType
    _sum?: PaiementSumAggregateInputType
    _min?: PaiementMinAggregateInputType
    _max?: PaiementMaxAggregateInputType
  }

  export type PaiementGroupByOutputType = {
    id: number
    etudiantId: number
    montant: number
    datePaiement: Date
    methodePaiement: string
    referencePaiement: string
    typeFrais: string
    statutPaiement: string
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  type GetPaiementGroupByPayload<T extends PaiementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaiementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaiementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaiementGroupByOutputType[P]>
            : GetScalarType<T[P], PaiementGroupByOutputType[P]>
        }
      >
    >


  export type PaiementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    etudiantId?: boolean
    montant?: boolean
    datePaiement?: boolean
    methodePaiement?: boolean
    referencePaiement?: boolean
    typeFrais?: boolean
    statutPaiement?: boolean
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectScalar = {
    id?: boolean
    etudiantId?: boolean
    montant?: boolean
    datePaiement?: boolean
    methodePaiement?: boolean
    referencePaiement?: boolean
    typeFrais?: boolean
    statutPaiement?: boolean
  }

  export type PaiementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
  }


  export type $PaiementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paiement"
    objects: {
      etudiant: Prisma.$EtudiantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      etudiantId: number
      montant: number
      datePaiement: Date
      methodePaiement: string
      referencePaiement: string
      typeFrais: string
      statutPaiement: string
    }, ExtArgs["result"]["paiement"]>
    composites: {}
  }


  type PaiementGetPayload<S extends boolean | null | undefined | PaiementDefaultArgs> = $Result.GetResult<Prisma.$PaiementPayload, S>

  type PaiementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaiementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaiementCountAggregateInputType | true
    }

  export interface PaiementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paiement'], meta: { name: 'Paiement' } }
    /**
     * Find zero or one Paiement that matches the filter.
     * @param {PaiementFindUniqueArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaiementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PaiementFindUniqueArgs<ExtArgs>>
    ): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Paiement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaiementFindUniqueOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaiementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaiementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Paiement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaiementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PaiementFindFirstArgs<ExtArgs>>
    ): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Paiement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaiementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaiementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Paiements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paiements
     * const paiements = await prisma.paiement.findMany()
     * 
     * // Get first 10 Paiements
     * const paiements = await prisma.paiement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paiementWithIdOnly = await prisma.paiement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaiementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaiementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Paiement.
     * @param {PaiementCreateArgs} args - Arguments to create a Paiement.
     * @example
     * // Create one Paiement
     * const Paiement = await prisma.paiement.create({
     *   data: {
     *     // ... data to create a Paiement
     *   }
     * })
     * 
    **/
    create<T extends PaiementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaiementCreateArgs<ExtArgs>>
    ): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Paiements.
     *     @param {PaiementCreateManyArgs} args - Arguments to create many Paiements.
     *     @example
     *     // Create many Paiements
     *     const paiement = await prisma.paiement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaiementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaiementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Paiement.
     * @param {PaiementDeleteArgs} args - Arguments to delete one Paiement.
     * @example
     * // Delete one Paiement
     * const Paiement = await prisma.paiement.delete({
     *   where: {
     *     // ... filter to delete one Paiement
     *   }
     * })
     * 
    **/
    delete<T extends PaiementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaiementDeleteArgs<ExtArgs>>
    ): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Paiement.
     * @param {PaiementUpdateArgs} args - Arguments to update one Paiement.
     * @example
     * // Update one Paiement
     * const paiement = await prisma.paiement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaiementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaiementUpdateArgs<ExtArgs>>
    ): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Paiements.
     * @param {PaiementDeleteManyArgs} args - Arguments to filter Paiements to delete.
     * @example
     * // Delete a few Paiements
     * const { count } = await prisma.paiement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaiementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaiementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaiementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaiementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paiement.
     * @param {PaiementUpsertArgs} args - Arguments to update or create a Paiement.
     * @example
     * // Update or create a Paiement
     * const paiement = await prisma.paiement.upsert({
     *   create: {
     *     // ... data to create a Paiement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paiement we want to update
     *   }
     * })
    **/
    upsert<T extends PaiementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaiementUpsertArgs<ExtArgs>>
    ): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementCountArgs} args - Arguments to filter Paiements to count.
     * @example
     * // Count the number of Paiements
     * const count = await prisma.paiement.count({
     *   where: {
     *     // ... the filter for the Paiements we want to count
     *   }
     * })
    **/
    count<T extends PaiementCountArgs>(
      args?: Subset<T, PaiementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaiementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaiementAggregateArgs>(args: Subset<T, PaiementAggregateArgs>): Prisma.PrismaPromise<GetPaiementAggregateType<T>>

    /**
     * Group by Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaiementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaiementGroupByArgs['orderBy'] }
        : { orderBy?: PaiementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaiementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaiementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paiement model
   */
  readonly fields: PaiementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paiement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaiementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    etudiant<T extends EtudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtudiantDefaultArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Paiement model
   */ 
  interface PaiementFieldRefs {
    readonly id: FieldRef<"Paiement", 'Int'>
    readonly etudiantId: FieldRef<"Paiement", 'Int'>
    readonly montant: FieldRef<"Paiement", 'Float'>
    readonly datePaiement: FieldRef<"Paiement", 'DateTime'>
    readonly methodePaiement: FieldRef<"Paiement", 'String'>
    readonly referencePaiement: FieldRef<"Paiement", 'String'>
    readonly typeFrais: FieldRef<"Paiement", 'String'>
    readonly statutPaiement: FieldRef<"Paiement", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Paiement findUnique
   */
  export type PaiementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }


  /**
   * Paiement findUniqueOrThrow
   */
  export type PaiementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }


  /**
   * Paiement findFirst
   */
  export type PaiementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }


  /**
   * Paiement findFirstOrThrow
   */
  export type PaiementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }


  /**
   * Paiement findMany
   */
  export type PaiementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiements to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }


  /**
   * Paiement create
   */
  export type PaiementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to create a Paiement.
     */
    data: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
  }


  /**
   * Paiement createMany
   */
  export type PaiementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Paiement update
   */
  export type PaiementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to update a Paiement.
     */
    data: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
    /**
     * Choose, which Paiement to update.
     */
    where: PaiementWhereUniqueInput
  }


  /**
   * Paiement updateMany
   */
  export type PaiementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
  }


  /**
   * Paiement upsert
   */
  export type PaiementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The filter to search for the Paiement to update in case it exists.
     */
    where: PaiementWhereUniqueInput
    /**
     * In case the Paiement found by the `where` argument doesn't exist, create a new Paiement with this data.
     */
    create: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
    /**
     * In case the Paiement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
  }


  /**
   * Paiement delete
   */
  export type PaiementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter which Paiement to delete.
     */
    where: PaiementWhereUniqueInput
  }


  /**
   * Paiement deleteMany
   */
  export type PaiementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiements to delete
     */
    where?: PaiementWhereInput
  }


  /**
   * Paiement without action
   */
  export type PaiementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaiementInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    username: 'username',
    password: 'password',
    roles: 'roles',
    isActive: 'isActive',
    userId: 'userId'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const UtilisateurScalarFieldEnum: {
    id: 'id',
    matricule: 'matricule',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    prenom: 'prenom',
    nom: 'nom',
    dateNaissance: 'dateNaissance',
    lieuNaissance: 'lieuNaissance',
    cni: 'cni',
    genre: 'genre',
    nationalite: 'nationalite',
    groupeSanguin: 'groupeSanguin',
    etablissementId: 'etablissementId',
    statutCompte: 'statutCompte',
    roles: 'roles',
    contactId: 'contactId',
    adresseId: 'adresseId',
    accountId: 'accountId'
  };

  export type UtilisateurScalarFieldEnum = (typeof UtilisateurScalarFieldEnum)[keyof typeof UtilisateurScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    role: 'role',
    label: 'label',
    slug: 'slug'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const AdresseScalarFieldEnum: {
    id: 'id',
    pays: 'pays',
    region: 'region',
    ville: 'ville',
    codePostal: 'codePostal',
    geolocalisation: 'geolocalisation'
  };

  export type AdresseScalarFieldEnum = (typeof AdresseScalarFieldEnum)[keyof typeof AdresseScalarFieldEnum]


  export const ReseauSocialScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    username: 'username',
    url: 'url',
    contactId: 'contactId'
  };

  export type ReseauSocialScalarFieldEnum = (typeof ReseauSocialScalarFieldEnum)[keyof typeof ReseauSocialScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    telephone: 'telephone',
    fix: 'fix',
    fax: 'fax',
    email: 'email',
    siteWeb: 'siteWeb'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const EtudiantScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    slug: 'slug',
    ine: 'ine',
    baccaleaureat: 'baccaleaureat',
    anneeBaccaleaureat: 'anneeBaccaleaureat',
    profileId: 'profileId',
    feuillePresencesId: 'feuillePresencesId'
  };

  export type EtudiantScalarFieldEnum = (typeof EtudiantScalarFieldEnum)[keyof typeof EtudiantScalarFieldEnum]


  export const ProfesseurScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileId: 'profileId'
  };

  export type ProfesseurScalarFieldEnum = (typeof ProfesseurScalarFieldEnum)[keyof typeof ProfesseurScalarFieldEnum]


  export const InscriptionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reference: 'reference',
    premiereInscription: 'premiereInscription',
    dernierDiplome: 'dernierDiplome',
    autreEtablissement: 'autreEtablissement',
    activiteProfessionnel: 'activiteProfessionnel',
    niveau: 'niveau',
    statut: 'statut',
    diplomeId: 'diplomeId',
    etudiantId: 'etudiantId',
    classeId: 'classeId'
  };

  export type InscriptionScalarFieldEnum = (typeof InscriptionScalarFieldEnum)[keyof typeof InscriptionScalarFieldEnum]


  export const DomaineScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    slug: 'slug'
  };

  export type DomaineScalarFieldEnum = (typeof DomaineScalarFieldEnum)[keyof typeof DomaineScalarFieldEnum]


  export const MentionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    slug: 'slug',
    domaineId: 'domaineId'
  };

  export type MentionScalarFieldEnum = (typeof MentionScalarFieldEnum)[keyof typeof MentionScalarFieldEnum]


  export const SpecialiteScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    slug: 'slug',
    mentionId: 'mentionId'
  };

  export type SpecialiteScalarFieldEnum = (typeof SpecialiteScalarFieldEnum)[keyof typeof SpecialiteScalarFieldEnum]


  export const DiplomeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    finalite: 'finalite',
    entite: 'entite',
    habilitation: 'habilitation',
    partenaires: 'partenaires',
    dateCreation: 'dateCreation',
    dateHabilitation: 'dateHabilitation',
    dateEcheance: 'dateEcheance',
    duree: 'duree',
    specialiteId: 'specialiteId'
  };

  export type DiplomeScalarFieldEnum = (typeof DiplomeScalarFieldEnum)[keyof typeof DiplomeScalarFieldEnum]


  export const SemestreScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    numero: 'numero',
    grade: 'grade',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    nombreSemaine: 'nombreSemaine',
    classeId: 'classeId'
  };

  export type SemestreScalarFieldEnum = (typeof SemestreScalarFieldEnum)[keyof typeof SemestreScalarFieldEnum]


  export const UniteEnseignementScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    code: 'code',
    nom: 'nom',
    numero: 'numero',
    credit: 'credit',
    semestreId: 'semestreId'
  };

  export type UniteEnseignementScalarFieldEnum = (typeof UniteEnseignementScalarFieldEnum)[keyof typeof UniteEnseignementScalarFieldEnum]


  export const MatiereScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    code: 'code',
    nom: 'nom',
    credit: 'credit',
    coefficient: 'coefficient',
    nbHeure: 'nbHeure',
    uniteEnseignementId: 'uniteEnseignementId'
  };

  export type MatiereScalarFieldEnum = (typeof MatiereScalarFieldEnum)[keyof typeof MatiereScalarFieldEnum]


  export const EtablissementScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    matricule: 'matricule',
    sigle: 'sigle',
    dateCreation: 'dateCreation',
    logo: 'logo',
    anneeEnCours: 'anneeEnCours',
    adresseId: 'adresseId',
    contactId: 'contactId'
  };

  export type EtablissementScalarFieldEnum = (typeof EtablissementScalarFieldEnum)[keyof typeof EtablissementScalarFieldEnum]


  export const ClasseScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    code: 'code',
    niveau: 'niveau',
    etablissementId: 'etablissementId',
    specialiteId: 'specialiteId',
    anneeScolaireId: 'anneeScolaireId'
  };

  export type ClasseScalarFieldEnum = (typeof ClasseScalarFieldEnum)[keyof typeof ClasseScalarFieldEnum]


  export const AnneeScolaireScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    nom: 'nom'
  };

  export type AnneeScolaireScalarFieldEnum = (typeof AnneeScolaireScalarFieldEnum)[keyof typeof AnneeScolaireScalarFieldEnum]


  export const EvaluationEtudiantsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    typeEvaluation: 'typeEvaluation',
    dateEvaluation: 'dateEvaluation',
    duree: 'duree',
    document: 'document',
    description: 'description',
    coursId: 'coursId'
  };

  export type EvaluationEtudiantsScalarFieldEnum = (typeof EvaluationEtudiantsScalarFieldEnum)[keyof typeof EvaluationEtudiantsScalarFieldEnum]


  export const NoteEtudiantScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    note: 'note',
    evaluationEtudiantId: 'evaluationEtudiantId',
    etudiantId: 'etudiantId'
  };

  export type NoteEtudiantScalarFieldEnum = (typeof NoteEtudiantScalarFieldEnum)[keyof typeof NoteEtudiantScalarFieldEnum]


  export const CoursScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    description: 'description',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    heureDebut: 'heureDebut',
    heureFin: 'heureFin',
    matiereId: 'matiereId',
    salleId: 'salleId',
    classeId: 'classeId',
    professeurId: 'professeurId'
  };

  export type CoursScalarFieldEnum = (typeof CoursScalarFieldEnum)[keyof typeof CoursScalarFieldEnum]


  export const SalleScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    capacite: 'capacite',
    batiment: 'batiment',
    etablissementId: 'etablissementId',
    estDisponible: 'estDisponible'
  };

  export type SalleScalarFieldEnum = (typeof SalleScalarFieldEnum)[keyof typeof SalleScalarFieldEnum]


  export const FeuillePresenceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    date: 'date',
    heureDebut: 'heureDebut',
    heureFin: 'heureFin',
    coursId: 'coursId',
    etudiantId: 'etudiantId'
  };

  export type FeuillePresenceScalarFieldEnum = (typeof FeuillePresenceScalarFieldEnum)[keyof typeof FeuillePresenceScalarFieldEnum]


  export const EmploiDuTempsScalarFieldEnum: {
    id: 'id',
    coursId: 'coursId',
    classeId: 'classeId',
    professeurId: 'professeurId',
    salleId: 'salleId',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin'
  };

  export type EmploiDuTempsScalarFieldEnum = (typeof EmploiDuTempsScalarFieldEnum)[keyof typeof EmploiDuTempsScalarFieldEnum]


  export const PaiementScalarFieldEnum: {
    id: 'id',
    etudiantId: 'etudiantId',
    montant: 'montant',
    datePaiement: 'datePaiement',
    methodePaiement: 'methodePaiement',
    referencePaiement: 'referencePaiement',
    typeFrais: 'typeFrais',
    statutPaiement: 'statutPaiement'
  };

  export type PaiementScalarFieldEnum = (typeof PaiementScalarFieldEnum)[keyof typeof PaiementScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Genre'
   */
  export type EnumGenreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Genre'>
    


  /**
   * Reference to a field of type 'Genre[]'
   */
  export type ListEnumGenreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Genre[]'>
    


  /**
   * Reference to a field of type 'GroupeSanguin'
   */
  export type EnumGroupeSanguinFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupeSanguin'>
    


  /**
   * Reference to a field of type 'GroupeSanguin[]'
   */
  export type ListEnumGroupeSanguinFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupeSanguin[]'>
    


  /**
   * Reference to a field of type 'TypeDiplome'
   */
  export type EnumTypeDiplomeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeDiplome'>
    


  /**
   * Reference to a field of type 'TypeDiplome[]'
   */
  export type ListEnumTypeDiplomeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeDiplome[]'>
    


  /**
   * Reference to a field of type 'TypeEvaluation'
   */
  export type EnumTypeEvaluationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeEvaluation'>
    


  /**
   * Reference to a field of type 'TypeEvaluation[]'
   */
  export type ListEnumTypeEvaluationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeEvaluation[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    uid?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    username?: StringFilter<"Account"> | string
    password?: StringFilter<"Account"> | string
    roles?: EnumRoleNullableListFilter<"Account">
    isActive?: BoolFilter<"Account"> | boolean
    userId?: IntFilter<"Account"> | number
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    uid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    password?: SortOrder
    roles?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uid?: string
    username?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    password?: StringFilter<"Account"> | string
    roles?: EnumRoleNullableListFilter<"Account">
    isActive?: BoolFilter<"Account"> | boolean
    userId?: IntFilter<"Account"> | number
  }, "id" | "uid" | "username">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    uid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    password?: SortOrder
    roles?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    uid?: StringWithAggregatesFilter<"Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    username?: StringWithAggregatesFilter<"Account"> | string
    password?: StringWithAggregatesFilter<"Account"> | string
    roles?: EnumRoleNullableListFilter<"Account">
    isActive?: BoolWithAggregatesFilter<"Account"> | boolean
    userId?: IntWithAggregatesFilter<"Account"> | number
  }

  export type UtilisateurWhereInput = {
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    id?: IntFilter<"Utilisateur"> | number
    matricule?: StringFilter<"Utilisateur"> | string
    createdAt?: DateTimeFilter<"Utilisateur"> | Date | string
    updatedAt?: DateTimeFilter<"Utilisateur"> | Date | string
    prenom?: StringFilter<"Utilisateur"> | string
    nom?: StringFilter<"Utilisateur"> | string
    dateNaissance?: DateTimeNullableFilter<"Utilisateur"> | Date | string | null
    lieuNaissance?: StringNullableFilter<"Utilisateur"> | string | null
    cni?: StringNullableFilter<"Utilisateur"> | string | null
    genre?: EnumGenreFilter<"Utilisateur"> | $Enums.Genre
    nationalite?: StringNullableFilter<"Utilisateur"> | string | null
    groupeSanguin?: EnumGroupeSanguinNullableFilter<"Utilisateur"> | $Enums.GroupeSanguin | null
    etablissementId?: IntNullableFilter<"Utilisateur"> | number | null
    statutCompte?: StringNullableFilter<"Utilisateur"> | string | null
    roles?: EnumRoleNullableListFilter<"Utilisateur">
    contactId?: IntNullableFilter<"Utilisateur"> | number | null
    adresseId?: IntNullableFilter<"Utilisateur"> | number | null
    accountId?: IntNullableFilter<"Utilisateur"> | number | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    adresse?: XOR<AdresseNullableRelationFilter, AdresseWhereInput> | null
    etablissement?: XOR<EtablissementNullableRelationFilter, EtablissementWhereInput> | null
    etudiant?: XOR<EtudiantNullableRelationFilter, EtudiantWhereInput> | null
    permissions?: PermissionListRelationFilter
    Professeur?: XOR<ProfesseurNullableRelationFilter, ProfesseurWhereInput> | null
  }

  export type UtilisateurOrderByWithRelationInput = {
    id?: SortOrder
    matricule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    lieuNaissance?: SortOrderInput | SortOrder
    cni?: SortOrderInput | SortOrder
    genre?: SortOrder
    nationalite?: SortOrderInput | SortOrder
    groupeSanguin?: SortOrderInput | SortOrder
    etablissementId?: SortOrderInput | SortOrder
    statutCompte?: SortOrderInput | SortOrder
    roles?: SortOrder
    contactId?: SortOrderInput | SortOrder
    adresseId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    contact?: ContactOrderByWithRelationInput
    adresse?: AdresseOrderByWithRelationInput
    etablissement?: EtablissementOrderByWithRelationInput
    etudiant?: EtudiantOrderByWithRelationInput
    permissions?: PermissionOrderByRelationAggregateInput
    Professeur?: ProfesseurOrderByWithRelationInput
  }

  export type UtilisateurWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    matricule?: string
    accountId?: number
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    createdAt?: DateTimeFilter<"Utilisateur"> | Date | string
    updatedAt?: DateTimeFilter<"Utilisateur"> | Date | string
    prenom?: StringFilter<"Utilisateur"> | string
    nom?: StringFilter<"Utilisateur"> | string
    dateNaissance?: DateTimeNullableFilter<"Utilisateur"> | Date | string | null
    lieuNaissance?: StringNullableFilter<"Utilisateur"> | string | null
    cni?: StringNullableFilter<"Utilisateur"> | string | null
    genre?: EnumGenreFilter<"Utilisateur"> | $Enums.Genre
    nationalite?: StringNullableFilter<"Utilisateur"> | string | null
    groupeSanguin?: EnumGroupeSanguinNullableFilter<"Utilisateur"> | $Enums.GroupeSanguin | null
    etablissementId?: IntNullableFilter<"Utilisateur"> | number | null
    statutCompte?: StringNullableFilter<"Utilisateur"> | string | null
    roles?: EnumRoleNullableListFilter<"Utilisateur">
    contactId?: IntNullableFilter<"Utilisateur"> | number | null
    adresseId?: IntNullableFilter<"Utilisateur"> | number | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    adresse?: XOR<AdresseNullableRelationFilter, AdresseWhereInput> | null
    etablissement?: XOR<EtablissementNullableRelationFilter, EtablissementWhereInput> | null
    etudiant?: XOR<EtudiantNullableRelationFilter, EtudiantWhereInput> | null
    permissions?: PermissionListRelationFilter
    Professeur?: XOR<ProfesseurNullableRelationFilter, ProfesseurWhereInput> | null
  }, "id" | "matricule" | "accountId">

  export type UtilisateurOrderByWithAggregationInput = {
    id?: SortOrder
    matricule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    lieuNaissance?: SortOrderInput | SortOrder
    cni?: SortOrderInput | SortOrder
    genre?: SortOrder
    nationalite?: SortOrderInput | SortOrder
    groupeSanguin?: SortOrderInput | SortOrder
    etablissementId?: SortOrderInput | SortOrder
    statutCompte?: SortOrderInput | SortOrder
    roles?: SortOrder
    contactId?: SortOrderInput | SortOrder
    adresseId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    _count?: UtilisateurCountOrderByAggregateInput
    _avg?: UtilisateurAvgOrderByAggregateInput
    _max?: UtilisateurMaxOrderByAggregateInput
    _min?: UtilisateurMinOrderByAggregateInput
    _sum?: UtilisateurSumOrderByAggregateInput
  }

  export type UtilisateurScalarWhereWithAggregatesInput = {
    AND?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    OR?: UtilisateurScalarWhereWithAggregatesInput[]
    NOT?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Utilisateur"> | number
    matricule?: StringWithAggregatesFilter<"Utilisateur"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Utilisateur"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Utilisateur"> | Date | string
    prenom?: StringWithAggregatesFilter<"Utilisateur"> | string
    nom?: StringWithAggregatesFilter<"Utilisateur"> | string
    dateNaissance?: DateTimeNullableWithAggregatesFilter<"Utilisateur"> | Date | string | null
    lieuNaissance?: StringNullableWithAggregatesFilter<"Utilisateur"> | string | null
    cni?: StringNullableWithAggregatesFilter<"Utilisateur"> | string | null
    genre?: EnumGenreWithAggregatesFilter<"Utilisateur"> | $Enums.Genre
    nationalite?: StringNullableWithAggregatesFilter<"Utilisateur"> | string | null
    groupeSanguin?: EnumGroupeSanguinNullableWithAggregatesFilter<"Utilisateur"> | $Enums.GroupeSanguin | null
    etablissementId?: IntNullableWithAggregatesFilter<"Utilisateur"> | number | null
    statutCompte?: StringNullableWithAggregatesFilter<"Utilisateur"> | string | null
    roles?: EnumRoleNullableListFilter<"Utilisateur">
    contactId?: IntNullableWithAggregatesFilter<"Utilisateur"> | number | null
    adresseId?: IntNullableWithAggregatesFilter<"Utilisateur"> | number | null
    accountId?: IntNullableWithAggregatesFilter<"Utilisateur"> | number | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    role?: EnumRoleNullableListFilter<"Permission">
    label?: StringFilter<"Permission"> | string
    slug?: StringNullableFilter<"Permission"> | string | null
    utilisateurs?: UtilisateurListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    label?: SortOrder
    slug?: SortOrderInput | SortOrder
    utilisateurs?: UtilisateurOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    label?: string
    slug?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    role?: EnumRoleNullableListFilter<"Permission">
    utilisateurs?: UtilisateurListRelationFilter
  }, "id" | "label" | "slug">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    label?: SortOrder
    slug?: SortOrderInput | SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    role?: EnumRoleNullableListFilter<"Permission">
    label?: StringWithAggregatesFilter<"Permission"> | string
    slug?: StringNullableWithAggregatesFilter<"Permission"> | string | null
  }

  export type AdresseWhereInput = {
    AND?: AdresseWhereInput | AdresseWhereInput[]
    OR?: AdresseWhereInput[]
    NOT?: AdresseWhereInput | AdresseWhereInput[]
    id?: IntFilter<"Adresse"> | number
    pays?: StringFilter<"Adresse"> | string
    region?: StringFilter<"Adresse"> | string
    ville?: StringFilter<"Adresse"> | string
    codePostal?: StringNullableFilter<"Adresse"> | string | null
    geolocalisation?: StringNullableFilter<"Adresse"> | string | null
    utilisateurs?: UtilisateurListRelationFilter
    etablissements?: EtablissementListRelationFilter
  }

  export type AdresseOrderByWithRelationInput = {
    id?: SortOrder
    pays?: SortOrder
    region?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrderInput | SortOrder
    geolocalisation?: SortOrderInput | SortOrder
    utilisateurs?: UtilisateurOrderByRelationAggregateInput
    etablissements?: EtablissementOrderByRelationAggregateInput
  }

  export type AdresseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdresseWhereInput | AdresseWhereInput[]
    OR?: AdresseWhereInput[]
    NOT?: AdresseWhereInput | AdresseWhereInput[]
    pays?: StringFilter<"Adresse"> | string
    region?: StringFilter<"Adresse"> | string
    ville?: StringFilter<"Adresse"> | string
    codePostal?: StringNullableFilter<"Adresse"> | string | null
    geolocalisation?: StringNullableFilter<"Adresse"> | string | null
    utilisateurs?: UtilisateurListRelationFilter
    etablissements?: EtablissementListRelationFilter
  }, "id">

  export type AdresseOrderByWithAggregationInput = {
    id?: SortOrder
    pays?: SortOrder
    region?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrderInput | SortOrder
    geolocalisation?: SortOrderInput | SortOrder
    _count?: AdresseCountOrderByAggregateInput
    _avg?: AdresseAvgOrderByAggregateInput
    _max?: AdresseMaxOrderByAggregateInput
    _min?: AdresseMinOrderByAggregateInput
    _sum?: AdresseSumOrderByAggregateInput
  }

  export type AdresseScalarWhereWithAggregatesInput = {
    AND?: AdresseScalarWhereWithAggregatesInput | AdresseScalarWhereWithAggregatesInput[]
    OR?: AdresseScalarWhereWithAggregatesInput[]
    NOT?: AdresseScalarWhereWithAggregatesInput | AdresseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Adresse"> | number
    pays?: StringWithAggregatesFilter<"Adresse"> | string
    region?: StringWithAggregatesFilter<"Adresse"> | string
    ville?: StringWithAggregatesFilter<"Adresse"> | string
    codePostal?: StringNullableWithAggregatesFilter<"Adresse"> | string | null
    geolocalisation?: StringNullableWithAggregatesFilter<"Adresse"> | string | null
  }

  export type ReseauSocialWhereInput = {
    AND?: ReseauSocialWhereInput | ReseauSocialWhereInput[]
    OR?: ReseauSocialWhereInput[]
    NOT?: ReseauSocialWhereInput | ReseauSocialWhereInput[]
    id?: IntFilter<"ReseauSocial"> | number
    createdAt?: DateTimeFilter<"ReseauSocial"> | Date | string
    updatedAt?: DateTimeFilter<"ReseauSocial"> | Date | string
    nom?: StringFilter<"ReseauSocial"> | string
    username?: StringFilter<"ReseauSocial"> | string
    url?: StringFilter<"ReseauSocial"> | string
    contactId?: IntNullableFilter<"ReseauSocial"> | number | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
  }

  export type ReseauSocialOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    username?: SortOrder
    url?: SortOrder
    contactId?: SortOrderInput | SortOrder
    contact?: ContactOrderByWithRelationInput
  }

  export type ReseauSocialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReseauSocialWhereInput | ReseauSocialWhereInput[]
    OR?: ReseauSocialWhereInput[]
    NOT?: ReseauSocialWhereInput | ReseauSocialWhereInput[]
    createdAt?: DateTimeFilter<"ReseauSocial"> | Date | string
    updatedAt?: DateTimeFilter<"ReseauSocial"> | Date | string
    nom?: StringFilter<"ReseauSocial"> | string
    username?: StringFilter<"ReseauSocial"> | string
    url?: StringFilter<"ReseauSocial"> | string
    contactId?: IntNullableFilter<"ReseauSocial"> | number | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
  }, "id">

  export type ReseauSocialOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    username?: SortOrder
    url?: SortOrder
    contactId?: SortOrderInput | SortOrder
    _count?: ReseauSocialCountOrderByAggregateInput
    _avg?: ReseauSocialAvgOrderByAggregateInput
    _max?: ReseauSocialMaxOrderByAggregateInput
    _min?: ReseauSocialMinOrderByAggregateInput
    _sum?: ReseauSocialSumOrderByAggregateInput
  }

  export type ReseauSocialScalarWhereWithAggregatesInput = {
    AND?: ReseauSocialScalarWhereWithAggregatesInput | ReseauSocialScalarWhereWithAggregatesInput[]
    OR?: ReseauSocialScalarWhereWithAggregatesInput[]
    NOT?: ReseauSocialScalarWhereWithAggregatesInput | ReseauSocialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReseauSocial"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReseauSocial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReseauSocial"> | Date | string
    nom?: StringWithAggregatesFilter<"ReseauSocial"> | string
    username?: StringWithAggregatesFilter<"ReseauSocial"> | string
    url?: StringWithAggregatesFilter<"ReseauSocial"> | string
    contactId?: IntNullableWithAggregatesFilter<"ReseauSocial"> | number | null
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: IntFilter<"Contact"> | number
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    telephone?: StringFilter<"Contact"> | string
    fix?: StringNullableFilter<"Contact"> | string | null
    fax?: StringNullableFilter<"Contact"> | string | null
    email?: StringFilter<"Contact"> | string
    siteWeb?: StringNullableFilter<"Contact"> | string | null
    reseauxSociaux?: ReseauSocialListRelationFilter
    utilisateurs?: UtilisateurListRelationFilter
    etablissements?: EtablissementListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telephone?: SortOrder
    fix?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    email?: SortOrder
    siteWeb?: SortOrderInput | SortOrder
    reseauxSociaux?: ReseauSocialOrderByRelationAggregateInput
    utilisateurs?: UtilisateurOrderByRelationAggregateInput
    etablissements?: EtablissementOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    telephone?: string
    fix?: string
    fax?: string
    email?: string
    siteWeb?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    reseauxSociaux?: ReseauSocialListRelationFilter
    utilisateurs?: UtilisateurListRelationFilter
    etablissements?: EtablissementListRelationFilter
  }, "id" | "telephone" | "fix" | "fax" | "email" | "siteWeb">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telephone?: SortOrder
    fix?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    email?: SortOrder
    siteWeb?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    telephone?: StringWithAggregatesFilter<"Contact"> | string
    fix?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    fax?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringWithAggregatesFilter<"Contact"> | string
    siteWeb?: StringNullableWithAggregatesFilter<"Contact"> | string | null
  }

  export type EtudiantWhereInput = {
    AND?: EtudiantWhereInput | EtudiantWhereInput[]
    OR?: EtudiantWhereInput[]
    NOT?: EtudiantWhereInput | EtudiantWhereInput[]
    id?: IntFilter<"Etudiant"> | number
    createdAt?: DateTimeFilter<"Etudiant"> | Date | string
    updatedAt?: DateTimeFilter<"Etudiant"> | Date | string
    slug?: StringNullableFilter<"Etudiant"> | string | null
    ine?: StringFilter<"Etudiant"> | string
    baccaleaureat?: StringNullableFilter<"Etudiant"> | string | null
    anneeBaccaleaureat?: IntNullableFilter<"Etudiant"> | number | null
    profileId?: IntFilter<"Etudiant"> | number
    feuillePresencesId?: IntNullableFilter<"Etudiant"> | number | null
    profile?: XOR<UtilisateurRelationFilter, UtilisateurWhereInput>
    inscriptions?: InscriptionListRelationFilter
    notes?: NoteEtudiantListRelationFilter
    feuillePresences?: FeuillePresenceListRelationFilter
    Paiement?: PaiementListRelationFilter
  }

  export type EtudiantOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrderInput | SortOrder
    ine?: SortOrder
    baccaleaureat?: SortOrderInput | SortOrder
    anneeBaccaleaureat?: SortOrderInput | SortOrder
    profileId?: SortOrder
    feuillePresencesId?: SortOrderInput | SortOrder
    profile?: UtilisateurOrderByWithRelationInput
    inscriptions?: InscriptionOrderByRelationAggregateInput
    notes?: NoteEtudiantOrderByRelationAggregateInput
    feuillePresences?: FeuillePresenceOrderByRelationAggregateInput
    Paiement?: PaiementOrderByRelationAggregateInput
  }

  export type EtudiantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    ine?: string
    profileId?: number
    AND?: EtudiantWhereInput | EtudiantWhereInput[]
    OR?: EtudiantWhereInput[]
    NOT?: EtudiantWhereInput | EtudiantWhereInput[]
    createdAt?: DateTimeFilter<"Etudiant"> | Date | string
    updatedAt?: DateTimeFilter<"Etudiant"> | Date | string
    baccaleaureat?: StringNullableFilter<"Etudiant"> | string | null
    anneeBaccaleaureat?: IntNullableFilter<"Etudiant"> | number | null
    feuillePresencesId?: IntNullableFilter<"Etudiant"> | number | null
    profile?: XOR<UtilisateurRelationFilter, UtilisateurWhereInput>
    inscriptions?: InscriptionListRelationFilter
    notes?: NoteEtudiantListRelationFilter
    feuillePresences?: FeuillePresenceListRelationFilter
    Paiement?: PaiementListRelationFilter
  }, "id" | "slug" | "ine" | "profileId">

  export type EtudiantOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrderInput | SortOrder
    ine?: SortOrder
    baccaleaureat?: SortOrderInput | SortOrder
    anneeBaccaleaureat?: SortOrderInput | SortOrder
    profileId?: SortOrder
    feuillePresencesId?: SortOrderInput | SortOrder
    _count?: EtudiantCountOrderByAggregateInput
    _avg?: EtudiantAvgOrderByAggregateInput
    _max?: EtudiantMaxOrderByAggregateInput
    _min?: EtudiantMinOrderByAggregateInput
    _sum?: EtudiantSumOrderByAggregateInput
  }

  export type EtudiantScalarWhereWithAggregatesInput = {
    AND?: EtudiantScalarWhereWithAggregatesInput | EtudiantScalarWhereWithAggregatesInput[]
    OR?: EtudiantScalarWhereWithAggregatesInput[]
    NOT?: EtudiantScalarWhereWithAggregatesInput | EtudiantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Etudiant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Etudiant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Etudiant"> | Date | string
    slug?: StringNullableWithAggregatesFilter<"Etudiant"> | string | null
    ine?: StringWithAggregatesFilter<"Etudiant"> | string
    baccaleaureat?: StringNullableWithAggregatesFilter<"Etudiant"> | string | null
    anneeBaccaleaureat?: IntNullableWithAggregatesFilter<"Etudiant"> | number | null
    profileId?: IntWithAggregatesFilter<"Etudiant"> | number
    feuillePresencesId?: IntNullableWithAggregatesFilter<"Etudiant"> | number | null
  }

  export type ProfesseurWhereInput = {
    AND?: ProfesseurWhereInput | ProfesseurWhereInput[]
    OR?: ProfesseurWhereInput[]
    NOT?: ProfesseurWhereInput | ProfesseurWhereInput[]
    id?: IntFilter<"Professeur"> | number
    createdAt?: DateTimeFilter<"Professeur"> | Date | string
    updatedAt?: DateTimeFilter<"Professeur"> | Date | string
    profileId?: IntFilter<"Professeur"> | number
    profile?: XOR<UtilisateurRelationFilter, UtilisateurWhereInput>
    cours?: CoursListRelationFilter
    EmploiDuTemps?: EmploiDuTempsListRelationFilter
  }

  export type ProfesseurOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    profile?: UtilisateurOrderByWithRelationInput
    cours?: CoursOrderByRelationAggregateInput
    EmploiDuTemps?: EmploiDuTempsOrderByRelationAggregateInput
  }

  export type ProfesseurWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    profileId?: number
    AND?: ProfesseurWhereInput | ProfesseurWhereInput[]
    OR?: ProfesseurWhereInput[]
    NOT?: ProfesseurWhereInput | ProfesseurWhereInput[]
    createdAt?: DateTimeFilter<"Professeur"> | Date | string
    updatedAt?: DateTimeFilter<"Professeur"> | Date | string
    profile?: XOR<UtilisateurRelationFilter, UtilisateurWhereInput>
    cours?: CoursListRelationFilter
    EmploiDuTemps?: EmploiDuTempsListRelationFilter
  }, "id" | "profileId">

  export type ProfesseurOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    _count?: ProfesseurCountOrderByAggregateInput
    _avg?: ProfesseurAvgOrderByAggregateInput
    _max?: ProfesseurMaxOrderByAggregateInput
    _min?: ProfesseurMinOrderByAggregateInput
    _sum?: ProfesseurSumOrderByAggregateInput
  }

  export type ProfesseurScalarWhereWithAggregatesInput = {
    AND?: ProfesseurScalarWhereWithAggregatesInput | ProfesseurScalarWhereWithAggregatesInput[]
    OR?: ProfesseurScalarWhereWithAggregatesInput[]
    NOT?: ProfesseurScalarWhereWithAggregatesInput | ProfesseurScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Professeur"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Professeur"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Professeur"> | Date | string
    profileId?: IntWithAggregatesFilter<"Professeur"> | number
  }

  export type InscriptionWhereInput = {
    AND?: InscriptionWhereInput | InscriptionWhereInput[]
    OR?: InscriptionWhereInput[]
    NOT?: InscriptionWhereInput | InscriptionWhereInput[]
    id?: IntFilter<"Inscription"> | number
    createdAt?: DateTimeFilter<"Inscription"> | Date | string
    updatedAt?: DateTimeFilter<"Inscription"> | Date | string
    reference?: StringFilter<"Inscription"> | string
    premiereInscription?: BoolFilter<"Inscription"> | boolean
    dernierDiplome?: StringNullableFilter<"Inscription"> | string | null
    autreEtablissement?: StringNullableFilter<"Inscription"> | string | null
    activiteProfessionnel?: StringNullableFilter<"Inscription"> | string | null
    niveau?: StringNullableFilter<"Inscription"> | string | null
    statut?: StringNullableFilter<"Inscription"> | string | null
    diplomeId?: IntFilter<"Inscription"> | number
    etudiantId?: IntFilter<"Inscription"> | number
    classeId?: IntFilter<"Inscription"> | number
    diplome?: XOR<DiplomeRelationFilter, DiplomeWhereInput>
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
  }

  export type InscriptionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reference?: SortOrder
    premiereInscription?: SortOrder
    dernierDiplome?: SortOrderInput | SortOrder
    autreEtablissement?: SortOrderInput | SortOrder
    activiteProfessionnel?: SortOrderInput | SortOrder
    niveau?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    diplomeId?: SortOrder
    etudiantId?: SortOrder
    classeId?: SortOrder
    diplome?: DiplomeOrderByWithRelationInput
    etudiant?: EtudiantOrderByWithRelationInput
    classe?: ClasseOrderByWithRelationInput
  }

  export type InscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reference?: string
    AND?: InscriptionWhereInput | InscriptionWhereInput[]
    OR?: InscriptionWhereInput[]
    NOT?: InscriptionWhereInput | InscriptionWhereInput[]
    createdAt?: DateTimeFilter<"Inscription"> | Date | string
    updatedAt?: DateTimeFilter<"Inscription"> | Date | string
    premiereInscription?: BoolFilter<"Inscription"> | boolean
    dernierDiplome?: StringNullableFilter<"Inscription"> | string | null
    autreEtablissement?: StringNullableFilter<"Inscription"> | string | null
    activiteProfessionnel?: StringNullableFilter<"Inscription"> | string | null
    niveau?: StringNullableFilter<"Inscription"> | string | null
    statut?: StringNullableFilter<"Inscription"> | string | null
    diplomeId?: IntFilter<"Inscription"> | number
    etudiantId?: IntFilter<"Inscription"> | number
    classeId?: IntFilter<"Inscription"> | number
    diplome?: XOR<DiplomeRelationFilter, DiplomeWhereInput>
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
  }, "id" | "reference">

  export type InscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reference?: SortOrder
    premiereInscription?: SortOrder
    dernierDiplome?: SortOrderInput | SortOrder
    autreEtablissement?: SortOrderInput | SortOrder
    activiteProfessionnel?: SortOrderInput | SortOrder
    niveau?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    diplomeId?: SortOrder
    etudiantId?: SortOrder
    classeId?: SortOrder
    _count?: InscriptionCountOrderByAggregateInput
    _avg?: InscriptionAvgOrderByAggregateInput
    _max?: InscriptionMaxOrderByAggregateInput
    _min?: InscriptionMinOrderByAggregateInput
    _sum?: InscriptionSumOrderByAggregateInput
  }

  export type InscriptionScalarWhereWithAggregatesInput = {
    AND?: InscriptionScalarWhereWithAggregatesInput | InscriptionScalarWhereWithAggregatesInput[]
    OR?: InscriptionScalarWhereWithAggregatesInput[]
    NOT?: InscriptionScalarWhereWithAggregatesInput | InscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inscription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Inscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inscription"> | Date | string
    reference?: StringWithAggregatesFilter<"Inscription"> | string
    premiereInscription?: BoolWithAggregatesFilter<"Inscription"> | boolean
    dernierDiplome?: StringNullableWithAggregatesFilter<"Inscription"> | string | null
    autreEtablissement?: StringNullableWithAggregatesFilter<"Inscription"> | string | null
    activiteProfessionnel?: StringNullableWithAggregatesFilter<"Inscription"> | string | null
    niveau?: StringNullableWithAggregatesFilter<"Inscription"> | string | null
    statut?: StringNullableWithAggregatesFilter<"Inscription"> | string | null
    diplomeId?: IntWithAggregatesFilter<"Inscription"> | number
    etudiantId?: IntWithAggregatesFilter<"Inscription"> | number
    classeId?: IntWithAggregatesFilter<"Inscription"> | number
  }

  export type DomaineWhereInput = {
    AND?: DomaineWhereInput | DomaineWhereInput[]
    OR?: DomaineWhereInput[]
    NOT?: DomaineWhereInput | DomaineWhereInput[]
    id?: IntFilter<"Domaine"> | number
    createdAt?: DateTimeFilter<"Domaine"> | Date | string
    updatedAt?: DateTimeFilter<"Domaine"> | Date | string
    nom?: StringFilter<"Domaine"> | string
    slug?: StringNullableFilter<"Domaine"> | string | null
    etablissements?: EtablissementListRelationFilter
    mentions?: MentionListRelationFilter
  }

  export type DomaineOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrderInput | SortOrder
    etablissements?: EtablissementOrderByRelationAggregateInput
    mentions?: MentionOrderByRelationAggregateInput
  }

  export type DomaineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: DomaineWhereInput | DomaineWhereInput[]
    OR?: DomaineWhereInput[]
    NOT?: DomaineWhereInput | DomaineWhereInput[]
    createdAt?: DateTimeFilter<"Domaine"> | Date | string
    updatedAt?: DateTimeFilter<"Domaine"> | Date | string
    nom?: StringFilter<"Domaine"> | string
    etablissements?: EtablissementListRelationFilter
    mentions?: MentionListRelationFilter
  }, "id" | "slug">

  export type DomaineOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrderInput | SortOrder
    _count?: DomaineCountOrderByAggregateInput
    _avg?: DomaineAvgOrderByAggregateInput
    _max?: DomaineMaxOrderByAggregateInput
    _min?: DomaineMinOrderByAggregateInput
    _sum?: DomaineSumOrderByAggregateInput
  }

  export type DomaineScalarWhereWithAggregatesInput = {
    AND?: DomaineScalarWhereWithAggregatesInput | DomaineScalarWhereWithAggregatesInput[]
    OR?: DomaineScalarWhereWithAggregatesInput[]
    NOT?: DomaineScalarWhereWithAggregatesInput | DomaineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Domaine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Domaine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Domaine"> | Date | string
    nom?: StringWithAggregatesFilter<"Domaine"> | string
    slug?: StringNullableWithAggregatesFilter<"Domaine"> | string | null
  }

  export type MentionWhereInput = {
    AND?: MentionWhereInput | MentionWhereInput[]
    OR?: MentionWhereInput[]
    NOT?: MentionWhereInput | MentionWhereInput[]
    id?: IntFilter<"Mention"> | number
    createdAt?: DateTimeFilter<"Mention"> | Date | string
    updatedAt?: DateTimeFilter<"Mention"> | Date | string
    nom?: StringFilter<"Mention"> | string
    slug?: StringNullableFilter<"Mention"> | string | null
    domaineId?: IntNullableFilter<"Mention"> | number | null
    domaine?: XOR<DomaineNullableRelationFilter, DomaineWhereInput> | null
    specialites?: SpecialiteListRelationFilter
  }

  export type MentionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrderInput | SortOrder
    domaineId?: SortOrderInput | SortOrder
    domaine?: DomaineOrderByWithRelationInput
    specialites?: SpecialiteOrderByRelationAggregateInput
  }

  export type MentionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: MentionWhereInput | MentionWhereInput[]
    OR?: MentionWhereInput[]
    NOT?: MentionWhereInput | MentionWhereInput[]
    createdAt?: DateTimeFilter<"Mention"> | Date | string
    updatedAt?: DateTimeFilter<"Mention"> | Date | string
    nom?: StringFilter<"Mention"> | string
    domaineId?: IntNullableFilter<"Mention"> | number | null
    domaine?: XOR<DomaineNullableRelationFilter, DomaineWhereInput> | null
    specialites?: SpecialiteListRelationFilter
  }, "id" | "slug">

  export type MentionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrderInput | SortOrder
    domaineId?: SortOrderInput | SortOrder
    _count?: MentionCountOrderByAggregateInput
    _avg?: MentionAvgOrderByAggregateInput
    _max?: MentionMaxOrderByAggregateInput
    _min?: MentionMinOrderByAggregateInput
    _sum?: MentionSumOrderByAggregateInput
  }

  export type MentionScalarWhereWithAggregatesInput = {
    AND?: MentionScalarWhereWithAggregatesInput | MentionScalarWhereWithAggregatesInput[]
    OR?: MentionScalarWhereWithAggregatesInput[]
    NOT?: MentionScalarWhereWithAggregatesInput | MentionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mention"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Mention"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mention"> | Date | string
    nom?: StringWithAggregatesFilter<"Mention"> | string
    slug?: StringNullableWithAggregatesFilter<"Mention"> | string | null
    domaineId?: IntNullableWithAggregatesFilter<"Mention"> | number | null
  }

  export type SpecialiteWhereInput = {
    AND?: SpecialiteWhereInput | SpecialiteWhereInput[]
    OR?: SpecialiteWhereInput[]
    NOT?: SpecialiteWhereInput | SpecialiteWhereInput[]
    id?: IntFilter<"Specialite"> | number
    createdAt?: DateTimeFilter<"Specialite"> | Date | string
    updatedAt?: DateTimeFilter<"Specialite"> | Date | string
    nom?: StringFilter<"Specialite"> | string
    slug?: StringNullableFilter<"Specialite"> | string | null
    mentionId?: IntNullableFilter<"Specialite"> | number | null
    mention?: XOR<MentionNullableRelationFilter, MentionWhereInput> | null
    Classe?: ClasseListRelationFilter
    Diplome?: DiplomeListRelationFilter
  }

  export type SpecialiteOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrderInput | SortOrder
    mentionId?: SortOrderInput | SortOrder
    mention?: MentionOrderByWithRelationInput
    Classe?: ClasseOrderByRelationAggregateInput
    Diplome?: DiplomeOrderByRelationAggregateInput
  }

  export type SpecialiteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: SpecialiteWhereInput | SpecialiteWhereInput[]
    OR?: SpecialiteWhereInput[]
    NOT?: SpecialiteWhereInput | SpecialiteWhereInput[]
    createdAt?: DateTimeFilter<"Specialite"> | Date | string
    updatedAt?: DateTimeFilter<"Specialite"> | Date | string
    nom?: StringFilter<"Specialite"> | string
    mentionId?: IntNullableFilter<"Specialite"> | number | null
    mention?: XOR<MentionNullableRelationFilter, MentionWhereInput> | null
    Classe?: ClasseListRelationFilter
    Diplome?: DiplomeListRelationFilter
  }, "id" | "slug">

  export type SpecialiteOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrderInput | SortOrder
    mentionId?: SortOrderInput | SortOrder
    _count?: SpecialiteCountOrderByAggregateInput
    _avg?: SpecialiteAvgOrderByAggregateInput
    _max?: SpecialiteMaxOrderByAggregateInput
    _min?: SpecialiteMinOrderByAggregateInput
    _sum?: SpecialiteSumOrderByAggregateInput
  }

  export type SpecialiteScalarWhereWithAggregatesInput = {
    AND?: SpecialiteScalarWhereWithAggregatesInput | SpecialiteScalarWhereWithAggregatesInput[]
    OR?: SpecialiteScalarWhereWithAggregatesInput[]
    NOT?: SpecialiteScalarWhereWithAggregatesInput | SpecialiteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Specialite"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Specialite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Specialite"> | Date | string
    nom?: StringWithAggregatesFilter<"Specialite"> | string
    slug?: StringNullableWithAggregatesFilter<"Specialite"> | string | null
    mentionId?: IntNullableWithAggregatesFilter<"Specialite"> | number | null
  }

  export type DiplomeWhereInput = {
    AND?: DiplomeWhereInput | DiplomeWhereInput[]
    OR?: DiplomeWhereInput[]
    NOT?: DiplomeWhereInput | DiplomeWhereInput[]
    id?: IntFilter<"Diplome"> | number
    createdAt?: DateTimeFilter<"Diplome"> | Date | string
    updatedAt?: DateTimeFilter<"Diplome"> | Date | string
    nom?: StringFilter<"Diplome"> | string
    finalite?: StringFilter<"Diplome"> | string
    entite?: StringFilter<"Diplome"> | string
    habilitation?: StringFilter<"Diplome"> | string
    partenaires?: StringNullableListFilter<"Diplome">
    dateCreation?: DateTimeFilter<"Diplome"> | Date | string
    dateHabilitation?: DateTimeFilter<"Diplome"> | Date | string
    dateEcheance?: DateTimeFilter<"Diplome"> | Date | string
    duree?: IntFilter<"Diplome"> | number
    specialiteId?: IntNullableFilter<"Diplome"> | number | null
    inscriptions?: InscriptionListRelationFilter
    specialite?: XOR<SpecialiteNullableRelationFilter, SpecialiteWhereInput> | null
  }

  export type DiplomeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    finalite?: SortOrder
    entite?: SortOrder
    habilitation?: SortOrder
    partenaires?: SortOrder
    dateCreation?: SortOrder
    dateHabilitation?: SortOrder
    dateEcheance?: SortOrder
    duree?: SortOrder
    specialiteId?: SortOrderInput | SortOrder
    inscriptions?: InscriptionOrderByRelationAggregateInput
    specialite?: SpecialiteOrderByWithRelationInput
  }

  export type DiplomeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DiplomeWhereInput | DiplomeWhereInput[]
    OR?: DiplomeWhereInput[]
    NOT?: DiplomeWhereInput | DiplomeWhereInput[]
    createdAt?: DateTimeFilter<"Diplome"> | Date | string
    updatedAt?: DateTimeFilter<"Diplome"> | Date | string
    nom?: StringFilter<"Diplome"> | string
    finalite?: StringFilter<"Diplome"> | string
    entite?: StringFilter<"Diplome"> | string
    habilitation?: StringFilter<"Diplome"> | string
    partenaires?: StringNullableListFilter<"Diplome">
    dateCreation?: DateTimeFilter<"Diplome"> | Date | string
    dateHabilitation?: DateTimeFilter<"Diplome"> | Date | string
    dateEcheance?: DateTimeFilter<"Diplome"> | Date | string
    duree?: IntFilter<"Diplome"> | number
    specialiteId?: IntNullableFilter<"Diplome"> | number | null
    inscriptions?: InscriptionListRelationFilter
    specialite?: XOR<SpecialiteNullableRelationFilter, SpecialiteWhereInput> | null
  }, "id">

  export type DiplomeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    finalite?: SortOrder
    entite?: SortOrder
    habilitation?: SortOrder
    partenaires?: SortOrder
    dateCreation?: SortOrder
    dateHabilitation?: SortOrder
    dateEcheance?: SortOrder
    duree?: SortOrder
    specialiteId?: SortOrderInput | SortOrder
    _count?: DiplomeCountOrderByAggregateInput
    _avg?: DiplomeAvgOrderByAggregateInput
    _max?: DiplomeMaxOrderByAggregateInput
    _min?: DiplomeMinOrderByAggregateInput
    _sum?: DiplomeSumOrderByAggregateInput
  }

  export type DiplomeScalarWhereWithAggregatesInput = {
    AND?: DiplomeScalarWhereWithAggregatesInput | DiplomeScalarWhereWithAggregatesInput[]
    OR?: DiplomeScalarWhereWithAggregatesInput[]
    NOT?: DiplomeScalarWhereWithAggregatesInput | DiplomeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Diplome"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Diplome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Diplome"> | Date | string
    nom?: StringWithAggregatesFilter<"Diplome"> | string
    finalite?: StringWithAggregatesFilter<"Diplome"> | string
    entite?: StringWithAggregatesFilter<"Diplome"> | string
    habilitation?: StringWithAggregatesFilter<"Diplome"> | string
    partenaires?: StringNullableListFilter<"Diplome">
    dateCreation?: DateTimeWithAggregatesFilter<"Diplome"> | Date | string
    dateHabilitation?: DateTimeWithAggregatesFilter<"Diplome"> | Date | string
    dateEcheance?: DateTimeWithAggregatesFilter<"Diplome"> | Date | string
    duree?: IntWithAggregatesFilter<"Diplome"> | number
    specialiteId?: IntNullableWithAggregatesFilter<"Diplome"> | number | null
  }

  export type SemestreWhereInput = {
    AND?: SemestreWhereInput | SemestreWhereInput[]
    OR?: SemestreWhereInput[]
    NOT?: SemestreWhereInput | SemestreWhereInput[]
    id?: IntFilter<"Semestre"> | number
    createdAt?: DateTimeFilter<"Semestre"> | Date | string
    updatedAt?: DateTimeFilter<"Semestre"> | Date | string
    numero?: IntFilter<"Semestre"> | number
    grade?: EnumTypeDiplomeFilter<"Semestre"> | $Enums.TypeDiplome
    dateDebut?: DateTimeFilter<"Semestre"> | Date | string
    dateFin?: DateTimeFilter<"Semestre"> | Date | string
    nombreSemaine?: IntFilter<"Semestre"> | number
    classeId?: IntNullableFilter<"Semestre"> | number | null
    uniteEnseignement?: UniteEnseignementListRelationFilter
    Classe?: XOR<ClasseNullableRelationFilter, ClasseWhereInput> | null
  }

  export type SemestreOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numero?: SortOrder
    grade?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nombreSemaine?: SortOrder
    classeId?: SortOrderInput | SortOrder
    uniteEnseignement?: UniteEnseignementOrderByRelationAggregateInput
    Classe?: ClasseOrderByWithRelationInput
  }

  export type SemestreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SemestreWhereInput | SemestreWhereInput[]
    OR?: SemestreWhereInput[]
    NOT?: SemestreWhereInput | SemestreWhereInput[]
    createdAt?: DateTimeFilter<"Semestre"> | Date | string
    updatedAt?: DateTimeFilter<"Semestre"> | Date | string
    numero?: IntFilter<"Semestre"> | number
    grade?: EnumTypeDiplomeFilter<"Semestre"> | $Enums.TypeDiplome
    dateDebut?: DateTimeFilter<"Semestre"> | Date | string
    dateFin?: DateTimeFilter<"Semestre"> | Date | string
    nombreSemaine?: IntFilter<"Semestre"> | number
    classeId?: IntNullableFilter<"Semestre"> | number | null
    uniteEnseignement?: UniteEnseignementListRelationFilter
    Classe?: XOR<ClasseNullableRelationFilter, ClasseWhereInput> | null
  }, "id">

  export type SemestreOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numero?: SortOrder
    grade?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nombreSemaine?: SortOrder
    classeId?: SortOrderInput | SortOrder
    _count?: SemestreCountOrderByAggregateInput
    _avg?: SemestreAvgOrderByAggregateInput
    _max?: SemestreMaxOrderByAggregateInput
    _min?: SemestreMinOrderByAggregateInput
    _sum?: SemestreSumOrderByAggregateInput
  }

  export type SemestreScalarWhereWithAggregatesInput = {
    AND?: SemestreScalarWhereWithAggregatesInput | SemestreScalarWhereWithAggregatesInput[]
    OR?: SemestreScalarWhereWithAggregatesInput[]
    NOT?: SemestreScalarWhereWithAggregatesInput | SemestreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Semestre"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Semestre"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Semestre"> | Date | string
    numero?: IntWithAggregatesFilter<"Semestre"> | number
    grade?: EnumTypeDiplomeWithAggregatesFilter<"Semestre"> | $Enums.TypeDiplome
    dateDebut?: DateTimeWithAggregatesFilter<"Semestre"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"Semestre"> | Date | string
    nombreSemaine?: IntWithAggregatesFilter<"Semestre"> | number
    classeId?: IntNullableWithAggregatesFilter<"Semestre"> | number | null
  }

  export type UniteEnseignementWhereInput = {
    AND?: UniteEnseignementWhereInput | UniteEnseignementWhereInput[]
    OR?: UniteEnseignementWhereInput[]
    NOT?: UniteEnseignementWhereInput | UniteEnseignementWhereInput[]
    id?: IntFilter<"UniteEnseignement"> | number
    createdAt?: DateTimeFilter<"UniteEnseignement"> | Date | string
    updatedAt?: DateTimeFilter<"UniteEnseignement"> | Date | string
    code?: StringFilter<"UniteEnseignement"> | string
    nom?: StringFilter<"UniteEnseignement"> | string
    numero?: IntFilter<"UniteEnseignement"> | number
    credit?: IntFilter<"UniteEnseignement"> | number
    semestreId?: IntNullableFilter<"UniteEnseignement"> | number | null
    semestre?: XOR<SemestreNullableRelationFilter, SemestreWhereInput> | null
    matieres?: MatiereListRelationFilter
  }

  export type UniteEnseignementOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    numero?: SortOrder
    credit?: SortOrder
    semestreId?: SortOrderInput | SortOrder
    semestre?: SemestreOrderByWithRelationInput
    matieres?: MatiereOrderByRelationAggregateInput
  }

  export type UniteEnseignementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UniteEnseignementWhereInput | UniteEnseignementWhereInput[]
    OR?: UniteEnseignementWhereInput[]
    NOT?: UniteEnseignementWhereInput | UniteEnseignementWhereInput[]
    createdAt?: DateTimeFilter<"UniteEnseignement"> | Date | string
    updatedAt?: DateTimeFilter<"UniteEnseignement"> | Date | string
    code?: StringFilter<"UniteEnseignement"> | string
    nom?: StringFilter<"UniteEnseignement"> | string
    numero?: IntFilter<"UniteEnseignement"> | number
    credit?: IntFilter<"UniteEnseignement"> | number
    semestreId?: IntNullableFilter<"UniteEnseignement"> | number | null
    semestre?: XOR<SemestreNullableRelationFilter, SemestreWhereInput> | null
    matieres?: MatiereListRelationFilter
  }, "id">

  export type UniteEnseignementOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    numero?: SortOrder
    credit?: SortOrder
    semestreId?: SortOrderInput | SortOrder
    _count?: UniteEnseignementCountOrderByAggregateInput
    _avg?: UniteEnseignementAvgOrderByAggregateInput
    _max?: UniteEnseignementMaxOrderByAggregateInput
    _min?: UniteEnseignementMinOrderByAggregateInput
    _sum?: UniteEnseignementSumOrderByAggregateInput
  }

  export type UniteEnseignementScalarWhereWithAggregatesInput = {
    AND?: UniteEnseignementScalarWhereWithAggregatesInput | UniteEnseignementScalarWhereWithAggregatesInput[]
    OR?: UniteEnseignementScalarWhereWithAggregatesInput[]
    NOT?: UniteEnseignementScalarWhereWithAggregatesInput | UniteEnseignementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UniteEnseignement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UniteEnseignement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UniteEnseignement"> | Date | string
    code?: StringWithAggregatesFilter<"UniteEnseignement"> | string
    nom?: StringWithAggregatesFilter<"UniteEnseignement"> | string
    numero?: IntWithAggregatesFilter<"UniteEnseignement"> | number
    credit?: IntWithAggregatesFilter<"UniteEnseignement"> | number
    semestreId?: IntNullableWithAggregatesFilter<"UniteEnseignement"> | number | null
  }

  export type MatiereWhereInput = {
    AND?: MatiereWhereInput | MatiereWhereInput[]
    OR?: MatiereWhereInput[]
    NOT?: MatiereWhereInput | MatiereWhereInput[]
    id?: IntFilter<"Matiere"> | number
    createdAt?: DateTimeFilter<"Matiere"> | Date | string
    updatedAt?: DateTimeFilter<"Matiere"> | Date | string
    code?: StringFilter<"Matiere"> | string
    nom?: StringFilter<"Matiere"> | string
    credit?: IntFilter<"Matiere"> | number
    coefficient?: IntFilter<"Matiere"> | number
    nbHeure?: IntNullableFilter<"Matiere"> | number | null
    uniteEnseignementId?: IntFilter<"Matiere"> | number
    cours?: CoursListRelationFilter
    uniteEnseignement?: XOR<UniteEnseignementRelationFilter, UniteEnseignementWhereInput>
  }

  export type MatiereOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    credit?: SortOrder
    coefficient?: SortOrder
    nbHeure?: SortOrderInput | SortOrder
    uniteEnseignementId?: SortOrder
    cours?: CoursOrderByRelationAggregateInput
    uniteEnseignement?: UniteEnseignementOrderByWithRelationInput
  }

  export type MatiereWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MatiereWhereInput | MatiereWhereInput[]
    OR?: MatiereWhereInput[]
    NOT?: MatiereWhereInput | MatiereWhereInput[]
    createdAt?: DateTimeFilter<"Matiere"> | Date | string
    updatedAt?: DateTimeFilter<"Matiere"> | Date | string
    code?: StringFilter<"Matiere"> | string
    nom?: StringFilter<"Matiere"> | string
    credit?: IntFilter<"Matiere"> | number
    coefficient?: IntFilter<"Matiere"> | number
    nbHeure?: IntNullableFilter<"Matiere"> | number | null
    uniteEnseignementId?: IntFilter<"Matiere"> | number
    cours?: CoursListRelationFilter
    uniteEnseignement?: XOR<UniteEnseignementRelationFilter, UniteEnseignementWhereInput>
  }, "id">

  export type MatiereOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    credit?: SortOrder
    coefficient?: SortOrder
    nbHeure?: SortOrderInput | SortOrder
    uniteEnseignementId?: SortOrder
    _count?: MatiereCountOrderByAggregateInput
    _avg?: MatiereAvgOrderByAggregateInput
    _max?: MatiereMaxOrderByAggregateInput
    _min?: MatiereMinOrderByAggregateInput
    _sum?: MatiereSumOrderByAggregateInput
  }

  export type MatiereScalarWhereWithAggregatesInput = {
    AND?: MatiereScalarWhereWithAggregatesInput | MatiereScalarWhereWithAggregatesInput[]
    OR?: MatiereScalarWhereWithAggregatesInput[]
    NOT?: MatiereScalarWhereWithAggregatesInput | MatiereScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Matiere"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Matiere"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Matiere"> | Date | string
    code?: StringWithAggregatesFilter<"Matiere"> | string
    nom?: StringWithAggregatesFilter<"Matiere"> | string
    credit?: IntWithAggregatesFilter<"Matiere"> | number
    coefficient?: IntWithAggregatesFilter<"Matiere"> | number
    nbHeure?: IntNullableWithAggregatesFilter<"Matiere"> | number | null
    uniteEnseignementId?: IntWithAggregatesFilter<"Matiere"> | number
  }

  export type EtablissementWhereInput = {
    AND?: EtablissementWhereInput | EtablissementWhereInput[]
    OR?: EtablissementWhereInput[]
    NOT?: EtablissementWhereInput | EtablissementWhereInput[]
    id?: IntFilter<"Etablissement"> | number
    createdAt?: DateTimeFilter<"Etablissement"> | Date | string
    updatedAt?: DateTimeFilter<"Etablissement"> | Date | string
    nom?: StringFilter<"Etablissement"> | string
    matricule?: StringNullableFilter<"Etablissement"> | string | null
    sigle?: StringNullableFilter<"Etablissement"> | string | null
    dateCreation?: DateTimeNullableFilter<"Etablissement"> | Date | string | null
    logo?: StringNullableFilter<"Etablissement"> | string | null
    anneeEnCours?: StringNullableFilter<"Etablissement"> | string | null
    adresseId?: IntNullableFilter<"Etablissement"> | number | null
    contactId?: IntNullableFilter<"Etablissement"> | number | null
    adresse?: XOR<AdresseNullableRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    utilisateurs?: UtilisateurListRelationFilter
    domaines?: DomaineListRelationFilter
    classes?: ClasseListRelationFilter
    salle?: SalleListRelationFilter
  }

  export type EtablissementOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    matricule?: SortOrderInput | SortOrder
    sigle?: SortOrderInput | SortOrder
    dateCreation?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    anneeEnCours?: SortOrderInput | SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    adresse?: AdresseOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    utilisateurs?: UtilisateurOrderByRelationAggregateInput
    domaines?: DomaineOrderByRelationAggregateInput
    classes?: ClasseOrderByRelationAggregateInput
    salle?: SalleOrderByRelationAggregateInput
  }

  export type EtablissementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EtablissementWhereInput | EtablissementWhereInput[]
    OR?: EtablissementWhereInput[]
    NOT?: EtablissementWhereInput | EtablissementWhereInput[]
    createdAt?: DateTimeFilter<"Etablissement"> | Date | string
    updatedAt?: DateTimeFilter<"Etablissement"> | Date | string
    nom?: StringFilter<"Etablissement"> | string
    matricule?: StringNullableFilter<"Etablissement"> | string | null
    sigle?: StringNullableFilter<"Etablissement"> | string | null
    dateCreation?: DateTimeNullableFilter<"Etablissement"> | Date | string | null
    logo?: StringNullableFilter<"Etablissement"> | string | null
    anneeEnCours?: StringNullableFilter<"Etablissement"> | string | null
    adresseId?: IntNullableFilter<"Etablissement"> | number | null
    contactId?: IntNullableFilter<"Etablissement"> | number | null
    adresse?: XOR<AdresseNullableRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    utilisateurs?: UtilisateurListRelationFilter
    domaines?: DomaineListRelationFilter
    classes?: ClasseListRelationFilter
    salle?: SalleListRelationFilter
  }, "id">

  export type EtablissementOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    matricule?: SortOrderInput | SortOrder
    sigle?: SortOrderInput | SortOrder
    dateCreation?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    anneeEnCours?: SortOrderInput | SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    _count?: EtablissementCountOrderByAggregateInput
    _avg?: EtablissementAvgOrderByAggregateInput
    _max?: EtablissementMaxOrderByAggregateInput
    _min?: EtablissementMinOrderByAggregateInput
    _sum?: EtablissementSumOrderByAggregateInput
  }

  export type EtablissementScalarWhereWithAggregatesInput = {
    AND?: EtablissementScalarWhereWithAggregatesInput | EtablissementScalarWhereWithAggregatesInput[]
    OR?: EtablissementScalarWhereWithAggregatesInput[]
    NOT?: EtablissementScalarWhereWithAggregatesInput | EtablissementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Etablissement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Etablissement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Etablissement"> | Date | string
    nom?: StringWithAggregatesFilter<"Etablissement"> | string
    matricule?: StringNullableWithAggregatesFilter<"Etablissement"> | string | null
    sigle?: StringNullableWithAggregatesFilter<"Etablissement"> | string | null
    dateCreation?: DateTimeNullableWithAggregatesFilter<"Etablissement"> | Date | string | null
    logo?: StringNullableWithAggregatesFilter<"Etablissement"> | string | null
    anneeEnCours?: StringNullableWithAggregatesFilter<"Etablissement"> | string | null
    adresseId?: IntNullableWithAggregatesFilter<"Etablissement"> | number | null
    contactId?: IntNullableWithAggregatesFilter<"Etablissement"> | number | null
  }

  export type ClasseWhereInput = {
    AND?: ClasseWhereInput | ClasseWhereInput[]
    OR?: ClasseWhereInput[]
    NOT?: ClasseWhereInput | ClasseWhereInput[]
    id?: IntFilter<"Classe"> | number
    createdAt?: DateTimeFilter<"Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Classe"> | Date | string
    nom?: StringFilter<"Classe"> | string
    code?: StringFilter<"Classe"> | string
    niveau?: StringFilter<"Classe"> | string
    etablissementId?: IntFilter<"Classe"> | number
    specialiteId?: IntFilter<"Classe"> | number
    anneeScolaireId?: IntNullableFilter<"Classe"> | number | null
    etablissement?: XOR<EtablissementRelationFilter, EtablissementWhereInput>
    semestres?: SemestreListRelationFilter
    inscriptions?: InscriptionListRelationFilter
    specialite?: XOR<SpecialiteRelationFilter, SpecialiteWhereInput>
    Cours?: CoursListRelationFilter
    EmploiDuTemps?: EmploiDuTempsListRelationFilter
    AnneeScolaire?: XOR<AnneeScolaireNullableRelationFilter, AnneeScolaireWhereInput> | null
  }

  export type ClasseOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveau?: SortOrder
    etablissementId?: SortOrder
    specialiteId?: SortOrder
    anneeScolaireId?: SortOrderInput | SortOrder
    etablissement?: EtablissementOrderByWithRelationInput
    semestres?: SemestreOrderByRelationAggregateInput
    inscriptions?: InscriptionOrderByRelationAggregateInput
    specialite?: SpecialiteOrderByWithRelationInput
    Cours?: CoursOrderByRelationAggregateInput
    EmploiDuTemps?: EmploiDuTempsOrderByRelationAggregateInput
    AnneeScolaire?: AnneeScolaireOrderByWithRelationInput
  }

  export type ClasseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClasseWhereInput | ClasseWhereInput[]
    OR?: ClasseWhereInput[]
    NOT?: ClasseWhereInput | ClasseWhereInput[]
    createdAt?: DateTimeFilter<"Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Classe"> | Date | string
    nom?: StringFilter<"Classe"> | string
    code?: StringFilter<"Classe"> | string
    niveau?: StringFilter<"Classe"> | string
    etablissementId?: IntFilter<"Classe"> | number
    specialiteId?: IntFilter<"Classe"> | number
    anneeScolaireId?: IntNullableFilter<"Classe"> | number | null
    etablissement?: XOR<EtablissementRelationFilter, EtablissementWhereInput>
    semestres?: SemestreListRelationFilter
    inscriptions?: InscriptionListRelationFilter
    specialite?: XOR<SpecialiteRelationFilter, SpecialiteWhereInput>
    Cours?: CoursListRelationFilter
    EmploiDuTemps?: EmploiDuTempsListRelationFilter
    AnneeScolaire?: XOR<AnneeScolaireNullableRelationFilter, AnneeScolaireWhereInput> | null
  }, "id">

  export type ClasseOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveau?: SortOrder
    etablissementId?: SortOrder
    specialiteId?: SortOrder
    anneeScolaireId?: SortOrderInput | SortOrder
    _count?: ClasseCountOrderByAggregateInput
    _avg?: ClasseAvgOrderByAggregateInput
    _max?: ClasseMaxOrderByAggregateInput
    _min?: ClasseMinOrderByAggregateInput
    _sum?: ClasseSumOrderByAggregateInput
  }

  export type ClasseScalarWhereWithAggregatesInput = {
    AND?: ClasseScalarWhereWithAggregatesInput | ClasseScalarWhereWithAggregatesInput[]
    OR?: ClasseScalarWhereWithAggregatesInput[]
    NOT?: ClasseScalarWhereWithAggregatesInput | ClasseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Classe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Classe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Classe"> | Date | string
    nom?: StringWithAggregatesFilter<"Classe"> | string
    code?: StringWithAggregatesFilter<"Classe"> | string
    niveau?: StringWithAggregatesFilter<"Classe"> | string
    etablissementId?: IntWithAggregatesFilter<"Classe"> | number
    specialiteId?: IntWithAggregatesFilter<"Classe"> | number
    anneeScolaireId?: IntNullableWithAggregatesFilter<"Classe"> | number | null
  }

  export type AnneeScolaireWhereInput = {
    AND?: AnneeScolaireWhereInput | AnneeScolaireWhereInput[]
    OR?: AnneeScolaireWhereInput[]
    NOT?: AnneeScolaireWhereInput | AnneeScolaireWhereInput[]
    id?: IntFilter<"AnneeScolaire"> | number
    createdAt?: DateTimeFilter<"AnneeScolaire"> | Date | string
    updatedAt?: DateTimeFilter<"AnneeScolaire"> | Date | string
    dateDebut?: IntFilter<"AnneeScolaire"> | number
    dateFin?: IntFilter<"AnneeScolaire"> | number
    nom?: StringFilter<"AnneeScolaire"> | string
    classes?: ClasseListRelationFilter
  }

  export type AnneeScolaireOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nom?: SortOrder
    classes?: ClasseOrderByRelationAggregateInput
  }

  export type AnneeScolaireWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnneeScolaireWhereInput | AnneeScolaireWhereInput[]
    OR?: AnneeScolaireWhereInput[]
    NOT?: AnneeScolaireWhereInput | AnneeScolaireWhereInput[]
    createdAt?: DateTimeFilter<"AnneeScolaire"> | Date | string
    updatedAt?: DateTimeFilter<"AnneeScolaire"> | Date | string
    dateDebut?: IntFilter<"AnneeScolaire"> | number
    dateFin?: IntFilter<"AnneeScolaire"> | number
    nom?: StringFilter<"AnneeScolaire"> | string
    classes?: ClasseListRelationFilter
  }, "id">

  export type AnneeScolaireOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nom?: SortOrder
    _count?: AnneeScolaireCountOrderByAggregateInput
    _avg?: AnneeScolaireAvgOrderByAggregateInput
    _max?: AnneeScolaireMaxOrderByAggregateInput
    _min?: AnneeScolaireMinOrderByAggregateInput
    _sum?: AnneeScolaireSumOrderByAggregateInput
  }

  export type AnneeScolaireScalarWhereWithAggregatesInput = {
    AND?: AnneeScolaireScalarWhereWithAggregatesInput | AnneeScolaireScalarWhereWithAggregatesInput[]
    OR?: AnneeScolaireScalarWhereWithAggregatesInput[]
    NOT?: AnneeScolaireScalarWhereWithAggregatesInput | AnneeScolaireScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AnneeScolaire"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AnneeScolaire"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnneeScolaire"> | Date | string
    dateDebut?: IntWithAggregatesFilter<"AnneeScolaire"> | number
    dateFin?: IntWithAggregatesFilter<"AnneeScolaire"> | number
    nom?: StringWithAggregatesFilter<"AnneeScolaire"> | string
  }

  export type EvaluationEtudiantsWhereInput = {
    AND?: EvaluationEtudiantsWhereInput | EvaluationEtudiantsWhereInput[]
    OR?: EvaluationEtudiantsWhereInput[]
    NOT?: EvaluationEtudiantsWhereInput | EvaluationEtudiantsWhereInput[]
    id?: IntFilter<"EvaluationEtudiants"> | number
    createdAt?: DateTimeFilter<"EvaluationEtudiants"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationEtudiants"> | Date | string
    typeEvaluation?: EnumTypeEvaluationFilter<"EvaluationEtudiants"> | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFilter<"EvaluationEtudiants"> | Date | string
    duree?: IntFilter<"EvaluationEtudiants"> | number
    document?: StringFilter<"EvaluationEtudiants"> | string
    description?: StringNullableFilter<"EvaluationEtudiants"> | string | null
    coursId?: IntFilter<"EvaluationEtudiants"> | number
    cours?: XOR<CoursRelationFilter, CoursWhereInput>
    NoteEtudiant?: NoteEtudiantListRelationFilter
  }

  export type EvaluationEtudiantsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeEvaluation?: SortOrder
    dateEvaluation?: SortOrder
    duree?: SortOrder
    document?: SortOrder
    description?: SortOrderInput | SortOrder
    coursId?: SortOrder
    cours?: CoursOrderByWithRelationInput
    NoteEtudiant?: NoteEtudiantOrderByRelationAggregateInput
  }

  export type EvaluationEtudiantsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvaluationEtudiantsWhereInput | EvaluationEtudiantsWhereInput[]
    OR?: EvaluationEtudiantsWhereInput[]
    NOT?: EvaluationEtudiantsWhereInput | EvaluationEtudiantsWhereInput[]
    createdAt?: DateTimeFilter<"EvaluationEtudiants"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationEtudiants"> | Date | string
    typeEvaluation?: EnumTypeEvaluationFilter<"EvaluationEtudiants"> | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFilter<"EvaluationEtudiants"> | Date | string
    duree?: IntFilter<"EvaluationEtudiants"> | number
    document?: StringFilter<"EvaluationEtudiants"> | string
    description?: StringNullableFilter<"EvaluationEtudiants"> | string | null
    coursId?: IntFilter<"EvaluationEtudiants"> | number
    cours?: XOR<CoursRelationFilter, CoursWhereInput>
    NoteEtudiant?: NoteEtudiantListRelationFilter
  }, "id">

  export type EvaluationEtudiantsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeEvaluation?: SortOrder
    dateEvaluation?: SortOrder
    duree?: SortOrder
    document?: SortOrder
    description?: SortOrderInput | SortOrder
    coursId?: SortOrder
    _count?: EvaluationEtudiantsCountOrderByAggregateInput
    _avg?: EvaluationEtudiantsAvgOrderByAggregateInput
    _max?: EvaluationEtudiantsMaxOrderByAggregateInput
    _min?: EvaluationEtudiantsMinOrderByAggregateInput
    _sum?: EvaluationEtudiantsSumOrderByAggregateInput
  }

  export type EvaluationEtudiantsScalarWhereWithAggregatesInput = {
    AND?: EvaluationEtudiantsScalarWhereWithAggregatesInput | EvaluationEtudiantsScalarWhereWithAggregatesInput[]
    OR?: EvaluationEtudiantsScalarWhereWithAggregatesInput[]
    NOT?: EvaluationEtudiantsScalarWhereWithAggregatesInput | EvaluationEtudiantsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EvaluationEtudiants"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EvaluationEtudiants"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EvaluationEtudiants"> | Date | string
    typeEvaluation?: EnumTypeEvaluationWithAggregatesFilter<"EvaluationEtudiants"> | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeWithAggregatesFilter<"EvaluationEtudiants"> | Date | string
    duree?: IntWithAggregatesFilter<"EvaluationEtudiants"> | number
    document?: StringWithAggregatesFilter<"EvaluationEtudiants"> | string
    description?: StringNullableWithAggregatesFilter<"EvaluationEtudiants"> | string | null
    coursId?: IntWithAggregatesFilter<"EvaluationEtudiants"> | number
  }

  export type NoteEtudiantWhereInput = {
    AND?: NoteEtudiantWhereInput | NoteEtudiantWhereInput[]
    OR?: NoteEtudiantWhereInput[]
    NOT?: NoteEtudiantWhereInput | NoteEtudiantWhereInput[]
    id?: IntFilter<"NoteEtudiant"> | number
    createdAt?: DateTimeFilter<"NoteEtudiant"> | Date | string
    updatedAt?: DateTimeFilter<"NoteEtudiant"> | Date | string
    note?: FloatFilter<"NoteEtudiant"> | number
    evaluationEtudiantId?: IntNullableFilter<"NoteEtudiant"> | number | null
    etudiantId?: IntFilter<"NoteEtudiant"> | number
    evaluationEtudiant?: XOR<EvaluationEtudiantsNullableRelationFilter, EvaluationEtudiantsWhereInput> | null
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
  }

  export type NoteEtudiantOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note?: SortOrder
    evaluationEtudiantId?: SortOrderInput | SortOrder
    etudiantId?: SortOrder
    evaluationEtudiant?: EvaluationEtudiantsOrderByWithRelationInput
    etudiant?: EtudiantOrderByWithRelationInput
  }

  export type NoteEtudiantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    evaluationEtudiantId_etudiantId_note?: NoteEtudiantEvaluationEtudiantIdEtudiantIdNoteCompoundUniqueInput
    AND?: NoteEtudiantWhereInput | NoteEtudiantWhereInput[]
    OR?: NoteEtudiantWhereInput[]
    NOT?: NoteEtudiantWhereInput | NoteEtudiantWhereInput[]
    createdAt?: DateTimeFilter<"NoteEtudiant"> | Date | string
    updatedAt?: DateTimeFilter<"NoteEtudiant"> | Date | string
    note?: FloatFilter<"NoteEtudiant"> | number
    evaluationEtudiantId?: IntNullableFilter<"NoteEtudiant"> | number | null
    etudiantId?: IntFilter<"NoteEtudiant"> | number
    evaluationEtudiant?: XOR<EvaluationEtudiantsNullableRelationFilter, EvaluationEtudiantsWhereInput> | null
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
  }, "id" | "evaluationEtudiantId_etudiantId_note">

  export type NoteEtudiantOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note?: SortOrder
    evaluationEtudiantId?: SortOrderInput | SortOrder
    etudiantId?: SortOrder
    _count?: NoteEtudiantCountOrderByAggregateInput
    _avg?: NoteEtudiantAvgOrderByAggregateInput
    _max?: NoteEtudiantMaxOrderByAggregateInput
    _min?: NoteEtudiantMinOrderByAggregateInput
    _sum?: NoteEtudiantSumOrderByAggregateInput
  }

  export type NoteEtudiantScalarWhereWithAggregatesInput = {
    AND?: NoteEtudiantScalarWhereWithAggregatesInput | NoteEtudiantScalarWhereWithAggregatesInput[]
    OR?: NoteEtudiantScalarWhereWithAggregatesInput[]
    NOT?: NoteEtudiantScalarWhereWithAggregatesInput | NoteEtudiantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NoteEtudiant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"NoteEtudiant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NoteEtudiant"> | Date | string
    note?: FloatWithAggregatesFilter<"NoteEtudiant"> | number
    evaluationEtudiantId?: IntNullableWithAggregatesFilter<"NoteEtudiant"> | number | null
    etudiantId?: IntWithAggregatesFilter<"NoteEtudiant"> | number
  }

  export type CoursWhereInput = {
    AND?: CoursWhereInput | CoursWhereInput[]
    OR?: CoursWhereInput[]
    NOT?: CoursWhereInput | CoursWhereInput[]
    id?: IntFilter<"Cours"> | number
    createdAt?: DateTimeFilter<"Cours"> | Date | string
    updatedAt?: DateTimeFilter<"Cours"> | Date | string
    nom?: StringFilter<"Cours"> | string
    description?: StringNullableFilter<"Cours"> | string | null
    dateDebut?: DateTimeFilter<"Cours"> | Date | string
    dateFin?: DateTimeFilter<"Cours"> | Date | string
    heureDebut?: DateTimeFilter<"Cours"> | Date | string
    heureFin?: DateTimeFilter<"Cours"> | Date | string
    matiereId?: IntNullableFilter<"Cours"> | number | null
    salleId?: IntNullableFilter<"Cours"> | number | null
    classeId?: IntNullableFilter<"Cours"> | number | null
    professeurId?: IntNullableFilter<"Cours"> | number | null
    matiere?: XOR<MatiereNullableRelationFilter, MatiereWhereInput> | null
    salle?: XOR<SalleNullableRelationFilter, SalleWhereInput> | null
    classe?: XOR<ClasseNullableRelationFilter, ClasseWhereInput> | null
    professeur?: XOR<ProfesseurNullableRelationFilter, ProfesseurWhereInput> | null
    evaluationEtudiant?: EvaluationEtudiantsListRelationFilter
    feuillePresences?: FeuillePresenceListRelationFilter
    emploiDuTemps?: EmploiDuTempsListRelationFilter
  }

  export type CoursOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    matiereId?: SortOrderInput | SortOrder
    salleId?: SortOrderInput | SortOrder
    classeId?: SortOrderInput | SortOrder
    professeurId?: SortOrderInput | SortOrder
    matiere?: MatiereOrderByWithRelationInput
    salle?: SalleOrderByWithRelationInput
    classe?: ClasseOrderByWithRelationInput
    professeur?: ProfesseurOrderByWithRelationInput
    evaluationEtudiant?: EvaluationEtudiantsOrderByRelationAggregateInput
    feuillePresences?: FeuillePresenceOrderByRelationAggregateInput
    emploiDuTemps?: EmploiDuTempsOrderByRelationAggregateInput
  }

  export type CoursWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CoursWhereInput | CoursWhereInput[]
    OR?: CoursWhereInput[]
    NOT?: CoursWhereInput | CoursWhereInput[]
    createdAt?: DateTimeFilter<"Cours"> | Date | string
    updatedAt?: DateTimeFilter<"Cours"> | Date | string
    nom?: StringFilter<"Cours"> | string
    description?: StringNullableFilter<"Cours"> | string | null
    dateDebut?: DateTimeFilter<"Cours"> | Date | string
    dateFin?: DateTimeFilter<"Cours"> | Date | string
    heureDebut?: DateTimeFilter<"Cours"> | Date | string
    heureFin?: DateTimeFilter<"Cours"> | Date | string
    matiereId?: IntNullableFilter<"Cours"> | number | null
    salleId?: IntNullableFilter<"Cours"> | number | null
    classeId?: IntNullableFilter<"Cours"> | number | null
    professeurId?: IntNullableFilter<"Cours"> | number | null
    matiere?: XOR<MatiereNullableRelationFilter, MatiereWhereInput> | null
    salle?: XOR<SalleNullableRelationFilter, SalleWhereInput> | null
    classe?: XOR<ClasseNullableRelationFilter, ClasseWhereInput> | null
    professeur?: XOR<ProfesseurNullableRelationFilter, ProfesseurWhereInput> | null
    evaluationEtudiant?: EvaluationEtudiantsListRelationFilter
    feuillePresences?: FeuillePresenceListRelationFilter
    emploiDuTemps?: EmploiDuTempsListRelationFilter
  }, "id">

  export type CoursOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    matiereId?: SortOrderInput | SortOrder
    salleId?: SortOrderInput | SortOrder
    classeId?: SortOrderInput | SortOrder
    professeurId?: SortOrderInput | SortOrder
    _count?: CoursCountOrderByAggregateInput
    _avg?: CoursAvgOrderByAggregateInput
    _max?: CoursMaxOrderByAggregateInput
    _min?: CoursMinOrderByAggregateInput
    _sum?: CoursSumOrderByAggregateInput
  }

  export type CoursScalarWhereWithAggregatesInput = {
    AND?: CoursScalarWhereWithAggregatesInput | CoursScalarWhereWithAggregatesInput[]
    OR?: CoursScalarWhereWithAggregatesInput[]
    NOT?: CoursScalarWhereWithAggregatesInput | CoursScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cours"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Cours"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cours"> | Date | string
    nom?: StringWithAggregatesFilter<"Cours"> | string
    description?: StringNullableWithAggregatesFilter<"Cours"> | string | null
    dateDebut?: DateTimeWithAggregatesFilter<"Cours"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"Cours"> | Date | string
    heureDebut?: DateTimeWithAggregatesFilter<"Cours"> | Date | string
    heureFin?: DateTimeWithAggregatesFilter<"Cours"> | Date | string
    matiereId?: IntNullableWithAggregatesFilter<"Cours"> | number | null
    salleId?: IntNullableWithAggregatesFilter<"Cours"> | number | null
    classeId?: IntNullableWithAggregatesFilter<"Cours"> | number | null
    professeurId?: IntNullableWithAggregatesFilter<"Cours"> | number | null
  }

  export type SalleWhereInput = {
    AND?: SalleWhereInput | SalleWhereInput[]
    OR?: SalleWhereInput[]
    NOT?: SalleWhereInput | SalleWhereInput[]
    id?: IntFilter<"Salle"> | number
    createdAt?: DateTimeFilter<"Salle"> | Date | string
    updatedAt?: DateTimeFilter<"Salle"> | Date | string
    nom?: StringFilter<"Salle"> | string
    capacite?: IntNullableFilter<"Salle"> | number | null
    batiment?: StringNullableFilter<"Salle"> | string | null
    etablissementId?: IntFilter<"Salle"> | number
    estDisponible?: BoolFilter<"Salle"> | boolean
    etablissement?: XOR<EtablissementRelationFilter, EtablissementWhereInput>
    cours?: CoursListRelationFilter
    EmploiDuTemps?: EmploiDuTempsListRelationFilter
  }

  export type SalleOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    capacite?: SortOrderInput | SortOrder
    batiment?: SortOrderInput | SortOrder
    etablissementId?: SortOrder
    estDisponible?: SortOrder
    etablissement?: EtablissementOrderByWithRelationInput
    cours?: CoursOrderByRelationAggregateInput
    EmploiDuTemps?: EmploiDuTempsOrderByRelationAggregateInput
  }

  export type SalleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalleWhereInput | SalleWhereInput[]
    OR?: SalleWhereInput[]
    NOT?: SalleWhereInput | SalleWhereInput[]
    createdAt?: DateTimeFilter<"Salle"> | Date | string
    updatedAt?: DateTimeFilter<"Salle"> | Date | string
    nom?: StringFilter<"Salle"> | string
    capacite?: IntNullableFilter<"Salle"> | number | null
    batiment?: StringNullableFilter<"Salle"> | string | null
    etablissementId?: IntFilter<"Salle"> | number
    estDisponible?: BoolFilter<"Salle"> | boolean
    etablissement?: XOR<EtablissementRelationFilter, EtablissementWhereInput>
    cours?: CoursListRelationFilter
    EmploiDuTemps?: EmploiDuTempsListRelationFilter
  }, "id">

  export type SalleOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    capacite?: SortOrderInput | SortOrder
    batiment?: SortOrderInput | SortOrder
    etablissementId?: SortOrder
    estDisponible?: SortOrder
    _count?: SalleCountOrderByAggregateInput
    _avg?: SalleAvgOrderByAggregateInput
    _max?: SalleMaxOrderByAggregateInput
    _min?: SalleMinOrderByAggregateInput
    _sum?: SalleSumOrderByAggregateInput
  }

  export type SalleScalarWhereWithAggregatesInput = {
    AND?: SalleScalarWhereWithAggregatesInput | SalleScalarWhereWithAggregatesInput[]
    OR?: SalleScalarWhereWithAggregatesInput[]
    NOT?: SalleScalarWhereWithAggregatesInput | SalleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Salle"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Salle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Salle"> | Date | string
    nom?: StringWithAggregatesFilter<"Salle"> | string
    capacite?: IntNullableWithAggregatesFilter<"Salle"> | number | null
    batiment?: StringNullableWithAggregatesFilter<"Salle"> | string | null
    etablissementId?: IntWithAggregatesFilter<"Salle"> | number
    estDisponible?: BoolWithAggregatesFilter<"Salle"> | boolean
  }

  export type FeuillePresenceWhereInput = {
    AND?: FeuillePresenceWhereInput | FeuillePresenceWhereInput[]
    OR?: FeuillePresenceWhereInput[]
    NOT?: FeuillePresenceWhereInput | FeuillePresenceWhereInput[]
    id?: IntFilter<"FeuillePresence"> | number
    createdAt?: DateTimeFilter<"FeuillePresence"> | Date | string
    updatedAt?: DateTimeFilter<"FeuillePresence"> | Date | string
    date?: DateTimeFilter<"FeuillePresence"> | Date | string
    heureDebut?: DateTimeFilter<"FeuillePresence"> | Date | string
    heureFin?: DateTimeFilter<"FeuillePresence"> | Date | string
    coursId?: IntFilter<"FeuillePresence"> | number
    etudiantId?: IntNullableFilter<"FeuillePresence"> | number | null
    cours?: XOR<CoursRelationFilter, CoursWhereInput>
    etudiant?: XOR<EtudiantNullableRelationFilter, EtudiantWhereInput> | null
  }

  export type FeuillePresenceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    coursId?: SortOrder
    etudiantId?: SortOrderInput | SortOrder
    cours?: CoursOrderByWithRelationInput
    etudiant?: EtudiantOrderByWithRelationInput
  }

  export type FeuillePresenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeuillePresenceWhereInput | FeuillePresenceWhereInput[]
    OR?: FeuillePresenceWhereInput[]
    NOT?: FeuillePresenceWhereInput | FeuillePresenceWhereInput[]
    createdAt?: DateTimeFilter<"FeuillePresence"> | Date | string
    updatedAt?: DateTimeFilter<"FeuillePresence"> | Date | string
    date?: DateTimeFilter<"FeuillePresence"> | Date | string
    heureDebut?: DateTimeFilter<"FeuillePresence"> | Date | string
    heureFin?: DateTimeFilter<"FeuillePresence"> | Date | string
    coursId?: IntFilter<"FeuillePresence"> | number
    etudiantId?: IntNullableFilter<"FeuillePresence"> | number | null
    cours?: XOR<CoursRelationFilter, CoursWhereInput>
    etudiant?: XOR<EtudiantNullableRelationFilter, EtudiantWhereInput> | null
  }, "id">

  export type FeuillePresenceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    coursId?: SortOrder
    etudiantId?: SortOrderInput | SortOrder
    _count?: FeuillePresenceCountOrderByAggregateInput
    _avg?: FeuillePresenceAvgOrderByAggregateInput
    _max?: FeuillePresenceMaxOrderByAggregateInput
    _min?: FeuillePresenceMinOrderByAggregateInput
    _sum?: FeuillePresenceSumOrderByAggregateInput
  }

  export type FeuillePresenceScalarWhereWithAggregatesInput = {
    AND?: FeuillePresenceScalarWhereWithAggregatesInput | FeuillePresenceScalarWhereWithAggregatesInput[]
    OR?: FeuillePresenceScalarWhereWithAggregatesInput[]
    NOT?: FeuillePresenceScalarWhereWithAggregatesInput | FeuillePresenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeuillePresence"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FeuillePresence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeuillePresence"> | Date | string
    date?: DateTimeWithAggregatesFilter<"FeuillePresence"> | Date | string
    heureDebut?: DateTimeWithAggregatesFilter<"FeuillePresence"> | Date | string
    heureFin?: DateTimeWithAggregatesFilter<"FeuillePresence"> | Date | string
    coursId?: IntWithAggregatesFilter<"FeuillePresence"> | number
    etudiantId?: IntNullableWithAggregatesFilter<"FeuillePresence"> | number | null
  }

  export type EmploiDuTempsWhereInput = {
    AND?: EmploiDuTempsWhereInput | EmploiDuTempsWhereInput[]
    OR?: EmploiDuTempsWhereInput[]
    NOT?: EmploiDuTempsWhereInput | EmploiDuTempsWhereInput[]
    id?: IntFilter<"EmploiDuTemps"> | number
    coursId?: IntFilter<"EmploiDuTemps"> | number
    classeId?: IntFilter<"EmploiDuTemps"> | number
    professeurId?: IntNullableFilter<"EmploiDuTemps"> | number | null
    salleId?: IntFilter<"EmploiDuTemps"> | number
    dateDebut?: DateTimeFilter<"EmploiDuTemps"> | Date | string
    dateFin?: DateTimeFilter<"EmploiDuTemps"> | Date | string
    cours?: XOR<CoursRelationFilter, CoursWhereInput>
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
    professeur?: XOR<ProfesseurNullableRelationFilter, ProfesseurWhereInput> | null
    salle?: XOR<SalleRelationFilter, SalleWhereInput>
  }

  export type EmploiDuTempsOrderByWithRelationInput = {
    id?: SortOrder
    coursId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrderInput | SortOrder
    salleId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    cours?: CoursOrderByWithRelationInput
    classe?: ClasseOrderByWithRelationInput
    professeur?: ProfesseurOrderByWithRelationInput
    salle?: SalleOrderByWithRelationInput
  }

  export type EmploiDuTempsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmploiDuTempsWhereInput | EmploiDuTempsWhereInput[]
    OR?: EmploiDuTempsWhereInput[]
    NOT?: EmploiDuTempsWhereInput | EmploiDuTempsWhereInput[]
    coursId?: IntFilter<"EmploiDuTemps"> | number
    classeId?: IntFilter<"EmploiDuTemps"> | number
    professeurId?: IntNullableFilter<"EmploiDuTemps"> | number | null
    salleId?: IntFilter<"EmploiDuTemps"> | number
    dateDebut?: DateTimeFilter<"EmploiDuTemps"> | Date | string
    dateFin?: DateTimeFilter<"EmploiDuTemps"> | Date | string
    cours?: XOR<CoursRelationFilter, CoursWhereInput>
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
    professeur?: XOR<ProfesseurNullableRelationFilter, ProfesseurWhereInput> | null
    salle?: XOR<SalleRelationFilter, SalleWhereInput>
  }, "id">

  export type EmploiDuTempsOrderByWithAggregationInput = {
    id?: SortOrder
    coursId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrderInput | SortOrder
    salleId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    _count?: EmploiDuTempsCountOrderByAggregateInput
    _avg?: EmploiDuTempsAvgOrderByAggregateInput
    _max?: EmploiDuTempsMaxOrderByAggregateInput
    _min?: EmploiDuTempsMinOrderByAggregateInput
    _sum?: EmploiDuTempsSumOrderByAggregateInput
  }

  export type EmploiDuTempsScalarWhereWithAggregatesInput = {
    AND?: EmploiDuTempsScalarWhereWithAggregatesInput | EmploiDuTempsScalarWhereWithAggregatesInput[]
    OR?: EmploiDuTempsScalarWhereWithAggregatesInput[]
    NOT?: EmploiDuTempsScalarWhereWithAggregatesInput | EmploiDuTempsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmploiDuTemps"> | number
    coursId?: IntWithAggregatesFilter<"EmploiDuTemps"> | number
    classeId?: IntWithAggregatesFilter<"EmploiDuTemps"> | number
    professeurId?: IntNullableWithAggregatesFilter<"EmploiDuTemps"> | number | null
    salleId?: IntWithAggregatesFilter<"EmploiDuTemps"> | number
    dateDebut?: DateTimeWithAggregatesFilter<"EmploiDuTemps"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"EmploiDuTemps"> | Date | string
  }

  export type PaiementWhereInput = {
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    id?: IntFilter<"Paiement"> | number
    etudiantId?: IntFilter<"Paiement"> | number
    montant?: FloatFilter<"Paiement"> | number
    datePaiement?: DateTimeFilter<"Paiement"> | Date | string
    methodePaiement?: StringFilter<"Paiement"> | string
    referencePaiement?: StringFilter<"Paiement"> | string
    typeFrais?: StringFilter<"Paiement"> | string
    statutPaiement?: StringFilter<"Paiement"> | string
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
  }

  export type PaiementOrderByWithRelationInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    montant?: SortOrder
    datePaiement?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrder
    typeFrais?: SortOrder
    statutPaiement?: SortOrder
    etudiant?: EtudiantOrderByWithRelationInput
  }

  export type PaiementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    etudiantId?: IntFilter<"Paiement"> | number
    montant?: FloatFilter<"Paiement"> | number
    datePaiement?: DateTimeFilter<"Paiement"> | Date | string
    methodePaiement?: StringFilter<"Paiement"> | string
    referencePaiement?: StringFilter<"Paiement"> | string
    typeFrais?: StringFilter<"Paiement"> | string
    statutPaiement?: StringFilter<"Paiement"> | string
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
  }, "id">

  export type PaiementOrderByWithAggregationInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    montant?: SortOrder
    datePaiement?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrder
    typeFrais?: SortOrder
    statutPaiement?: SortOrder
    _count?: PaiementCountOrderByAggregateInput
    _avg?: PaiementAvgOrderByAggregateInput
    _max?: PaiementMaxOrderByAggregateInput
    _min?: PaiementMinOrderByAggregateInput
    _sum?: PaiementSumOrderByAggregateInput
  }

  export type PaiementScalarWhereWithAggregatesInput = {
    AND?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    OR?: PaiementScalarWhereWithAggregatesInput[]
    NOT?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Paiement"> | number
    etudiantId?: IntWithAggregatesFilter<"Paiement"> | number
    montant?: FloatWithAggregatesFilter<"Paiement"> | number
    datePaiement?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
    methodePaiement?: StringWithAggregatesFilter<"Paiement"> | string
    referencePaiement?: StringWithAggregatesFilter<"Paiement"> | string
    typeFrais?: StringWithAggregatesFilter<"Paiement"> | string
    statutPaiement?: StringWithAggregatesFilter<"Paiement"> | string
  }

  export type AccountCreateInput = {
    uid?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    password: string
    roles?: AccountCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    userId: number
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    uid?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    password: string
    roles?: AccountCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    userId: number
  }

  export type AccountUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roles?: AccountUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roles?: AccountUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AccountCreateManyInput = {
    id?: number
    uid?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    password: string
    roles?: AccountCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    userId: number
  }

  export type AccountUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roles?: AccountUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roles?: AccountUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UtilisateurCreateInput = {
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    accountId?: number | null
    contact?: ContactCreateNestedOneWithoutUtilisateursInput
    adresse?: AdresseCreateNestedOneWithoutUtilisateursInput
    etablissement?: EtablissementCreateNestedOneWithoutUtilisateursInput
    etudiant?: EtudiantCreateNestedOneWithoutProfileInput
    permissions?: PermissionCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurUncheckedCreateInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    etablissementId?: number | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    contactId?: number | null
    adresseId?: number | null
    accountId?: number | null
    etudiant?: EtudiantUncheckedCreateNestedOneWithoutProfileInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurUpdateInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: ContactUpdateOneWithoutUtilisateursNestedInput
    adresse?: AdresseUpdateOneWithoutUtilisateursNestedInput
    etablissement?: EtablissementUpdateOneWithoutUtilisateursNestedInput
    etudiant?: EtudiantUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    etudiant?: EtudiantUncheckedUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurCreateManyInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    etablissementId?: number | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    contactId?: number | null
    adresseId?: number | null
    accountId?: number | null
  }

  export type UtilisateurUpdateManyMutationInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UtilisateurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PermissionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: PermissionCreateroleInput | $Enums.Role[]
    label: string
    slug?: string | null
    utilisateurs?: UtilisateurCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: PermissionCreateroleInput | $Enums.Role[]
    label: string
    slug?: string | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: PermissionUpdateroleInput | $Enums.Role[]
    label?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurs?: UtilisateurUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: PermissionUpdateroleInput | $Enums.Role[]
    label?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: PermissionCreateroleInput | $Enums.Role[]
    label: string
    slug?: string | null
  }

  export type PermissionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: PermissionUpdateroleInput | $Enums.Role[]
    label?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: PermissionUpdateroleInput | $Enums.Role[]
    label?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdresseCreateInput = {
    pays: string
    region: string
    ville: string
    codePostal?: string | null
    geolocalisation?: string | null
    utilisateurs?: UtilisateurCreateNestedManyWithoutAdresseInput
    etablissements?: EtablissementCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateInput = {
    id?: number
    pays: string
    region: string
    ville: string
    codePostal?: string | null
    geolocalisation?: string | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutAdresseInput
    etablissements?: EtablissementUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUpdateInput = {
    pays?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    geolocalisation?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurs?: UtilisateurUpdateManyWithoutAdresseNestedInput
    etablissements?: EtablissementUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pays?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    geolocalisation?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutAdresseNestedInput
    etablissements?: EtablissementUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseCreateManyInput = {
    id?: number
    pays: string
    region: string
    ville: string
    codePostal?: string | null
    geolocalisation?: string | null
  }

  export type AdresseUpdateManyMutationInput = {
    pays?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    geolocalisation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdresseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pays?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    geolocalisation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReseauSocialCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    username: string
    url: string
    contact?: ContactCreateNestedOneWithoutReseauxSociauxInput
  }

  export type ReseauSocialUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    username: string
    url: string
    contactId?: number | null
  }

  export type ReseauSocialUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contact?: ContactUpdateOneWithoutReseauxSociauxNestedInput
  }

  export type ReseauSocialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReseauSocialCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    username: string
    url: string
    contactId?: number | null
  }

  export type ReseauSocialUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ReseauSocialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContactCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    telephone: string
    fix?: string | null
    fax?: string | null
    email: string
    siteWeb?: string | null
    reseauxSociaux?: ReseauSocialCreateNestedManyWithoutContactInput
    utilisateurs?: UtilisateurCreateNestedManyWithoutContactInput
    etablissements?: EtablissementCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    telephone: string
    fix?: string | null
    fax?: string | null
    email: string
    siteWeb?: string | null
    reseauxSociaux?: ReseauSocialUncheckedCreateNestedManyWithoutContactInput
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutContactInput
    etablissements?: EtablissementUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    reseauxSociaux?: ReseauSocialUpdateManyWithoutContactNestedInput
    utilisateurs?: UtilisateurUpdateManyWithoutContactNestedInput
    etablissements?: EtablissementUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    reseauxSociaux?: ReseauSocialUncheckedUpdateManyWithoutContactNestedInput
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutContactNestedInput
    etablissements?: EtablissementUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    telephone: string
    fix?: string | null
    fax?: string | null
    email: string
    siteWeb?: string | null
  }

  export type ContactUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EtudiantCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    feuillePresencesId?: number | null
    profile: UtilisateurCreateNestedOneWithoutEtudiantInput
    inscriptions?: InscriptionCreateNestedManyWithoutEtudiantInput
    notes?: NoteEtudiantCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    profileId: number
    feuillePresencesId?: number | null
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutEtudiantInput
    notes?: NoteEtudiantUncheckedCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: UtilisateurUpdateOneRequiredWithoutEtudiantNestedInput
    inscriptions?: InscriptionUpdateManyWithoutEtudiantNestedInput
    notes?: NoteEtudiantUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    profileId?: IntFieldUpdateOperationsInput | number
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    inscriptions?: InscriptionUncheckedUpdateManyWithoutEtudiantNestedInput
    notes?: NoteEtudiantUncheckedUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    profileId: number
    feuillePresencesId?: number | null
  }

  export type EtudiantUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EtudiantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    profileId?: IntFieldUpdateOperationsInput | number
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfesseurCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UtilisateurCreateNestedOneWithoutProfesseurInput
    cours?: CoursCreateNestedManyWithoutProfesseurInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutProfesseurInput
  }

  export type ProfesseurUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: number
    cours?: CoursUncheckedCreateNestedManyWithoutProfesseurInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutProfesseurInput
  }

  export type ProfesseurUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UtilisateurUpdateOneRequiredWithoutProfesseurNestedInput
    cours?: CoursUpdateManyWithoutProfesseurNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutProfesseurNestedInput
  }

  export type ProfesseurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: IntFieldUpdateOperationsInput | number
    cours?: CoursUncheckedUpdateManyWithoutProfesseurNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutProfesseurNestedInput
  }

  export type ProfesseurCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: number
  }

  export type ProfesseurUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesseurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type InscriptionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    diplome: DiplomeCreateNestedOneWithoutInscriptionsInput
    etudiant: EtudiantCreateNestedOneWithoutInscriptionsInput
    classe: ClasseCreateNestedOneWithoutInscriptionsInput
  }

  export type InscriptionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    diplomeId: number
    etudiantId: number
    classeId: number
  }

  export type InscriptionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    diplome?: DiplomeUpdateOneRequiredWithoutInscriptionsNestedInput
    etudiant?: EtudiantUpdateOneRequiredWithoutInscriptionsNestedInput
    classe?: ClasseUpdateOneRequiredWithoutInscriptionsNestedInput
  }

  export type InscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    diplomeId?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
  }

  export type InscriptionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    diplomeId: number
    etudiantId: number
    classeId: number
  }

  export type InscriptionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    diplomeId?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
  }

  export type DomaineCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    etablissements?: EtablissementCreateNestedManyWithoutDomainesInput
    mentions?: MentionCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    etablissements?: EtablissementUncheckedCreateNestedManyWithoutDomainesInput
    mentions?: MentionUncheckedCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    etablissements?: EtablissementUpdateManyWithoutDomainesNestedInput
    mentions?: MentionUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    etablissements?: EtablissementUncheckedUpdateManyWithoutDomainesNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
  }

  export type DomaineUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DomaineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    domaine?: DomaineCreateNestedOneWithoutMentionsInput
    specialites?: SpecialiteCreateNestedManyWithoutMentionInput
  }

  export type MentionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    domaineId?: number | null
    specialites?: SpecialiteUncheckedCreateNestedManyWithoutMentionInput
  }

  export type MentionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    domaine?: DomaineUpdateOneWithoutMentionsNestedInput
    specialites?: SpecialiteUpdateManyWithoutMentionNestedInput
  }

  export type MentionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    specialites?: SpecialiteUncheckedUpdateManyWithoutMentionNestedInput
  }

  export type MentionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    domaineId?: number | null
  }

  export type MentionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpecialiteCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    mention?: MentionCreateNestedOneWithoutSpecialitesInput
    Classe?: ClasseCreateNestedManyWithoutSpecialiteInput
    Diplome?: DiplomeCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    mentionId?: number | null
    Classe?: ClasseUncheckedCreateNestedManyWithoutSpecialiteInput
    Diplome?: DiplomeUncheckedCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    mention?: MentionUpdateOneWithoutSpecialitesNestedInput
    Classe?: ClasseUpdateManyWithoutSpecialiteNestedInput
    Diplome?: DiplomeUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    mentionId?: NullableIntFieldUpdateOperationsInput | number | null
    Classe?: ClasseUncheckedUpdateManyWithoutSpecialiteNestedInput
    Diplome?: DiplomeUncheckedUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    mentionId?: number | null
  }

  export type SpecialiteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecialiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    mentionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DiplomeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    finalite: string
    entite: string
    habilitation: string
    partenaires?: DiplomeCreatepartenairesInput | string[]
    dateCreation: Date | string
    dateHabilitation: Date | string
    dateEcheance: Date | string
    duree: number
    inscriptions?: InscriptionCreateNestedManyWithoutDiplomeInput
    specialite?: SpecialiteCreateNestedOneWithoutDiplomeInput
  }

  export type DiplomeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    finalite: string
    entite: string
    habilitation: string
    partenaires?: DiplomeCreatepartenairesInput | string[]
    dateCreation: Date | string
    dateHabilitation: Date | string
    dateEcheance: Date | string
    duree: number
    specialiteId?: number | null
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutDiplomeInput
  }

  export type DiplomeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    finalite?: StringFieldUpdateOperationsInput | string
    entite?: StringFieldUpdateOperationsInput | string
    habilitation?: StringFieldUpdateOperationsInput | string
    partenaires?: DiplomeUpdatepartenairesInput | string[]
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHabilitation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    inscriptions?: InscriptionUpdateManyWithoutDiplomeNestedInput
    specialite?: SpecialiteUpdateOneWithoutDiplomeNestedInput
  }

  export type DiplomeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    finalite?: StringFieldUpdateOperationsInput | string
    entite?: StringFieldUpdateOperationsInput | string
    habilitation?: StringFieldUpdateOperationsInput | string
    partenaires?: DiplomeUpdatepartenairesInput | string[]
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHabilitation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    specialiteId?: NullableIntFieldUpdateOperationsInput | number | null
    inscriptions?: InscriptionUncheckedUpdateManyWithoutDiplomeNestedInput
  }

  export type DiplomeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    finalite: string
    entite: string
    habilitation: string
    partenaires?: DiplomeCreatepartenairesInput | string[]
    dateCreation: Date | string
    dateHabilitation: Date | string
    dateEcheance: Date | string
    duree: number
    specialiteId?: number | null
  }

  export type DiplomeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    finalite?: StringFieldUpdateOperationsInput | string
    entite?: StringFieldUpdateOperationsInput | string
    habilitation?: StringFieldUpdateOperationsInput | string
    partenaires?: DiplomeUpdatepartenairesInput | string[]
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHabilitation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
  }

  export type DiplomeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    finalite?: StringFieldUpdateOperationsInput | string
    entite?: StringFieldUpdateOperationsInput | string
    habilitation?: StringFieldUpdateOperationsInput | string
    partenaires?: DiplomeUpdatepartenairesInput | string[]
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHabilitation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    specialiteId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SemestreCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    numero: number
    grade: $Enums.TypeDiplome
    dateDebut: Date | string
    dateFin: Date | string
    nombreSemaine: number
    uniteEnseignement?: UniteEnseignementCreateNestedManyWithoutSemestreInput
    Classe?: ClasseCreateNestedOneWithoutSemestresInput
  }

  export type SemestreUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    numero: number
    grade: $Enums.TypeDiplome
    dateDebut: Date | string
    dateFin: Date | string
    nombreSemaine: number
    classeId?: number | null
    uniteEnseignement?: UniteEnseignementUncheckedCreateNestedManyWithoutSemestreInput
  }

  export type SemestreUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numero?: IntFieldUpdateOperationsInput | number
    grade?: EnumTypeDiplomeFieldUpdateOperationsInput | $Enums.TypeDiplome
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreSemaine?: IntFieldUpdateOperationsInput | number
    uniteEnseignement?: UniteEnseignementUpdateManyWithoutSemestreNestedInput
    Classe?: ClasseUpdateOneWithoutSemestresNestedInput
  }

  export type SemestreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numero?: IntFieldUpdateOperationsInput | number
    grade?: EnumTypeDiplomeFieldUpdateOperationsInput | $Enums.TypeDiplome
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreSemaine?: IntFieldUpdateOperationsInput | number
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    uniteEnseignement?: UniteEnseignementUncheckedUpdateManyWithoutSemestreNestedInput
  }

  export type SemestreCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    numero: number
    grade: $Enums.TypeDiplome
    dateDebut: Date | string
    dateFin: Date | string
    nombreSemaine: number
    classeId?: number | null
  }

  export type SemestreUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numero?: IntFieldUpdateOperationsInput | number
    grade?: EnumTypeDiplomeFieldUpdateOperationsInput | $Enums.TypeDiplome
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreSemaine?: IntFieldUpdateOperationsInput | number
  }

  export type SemestreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numero?: IntFieldUpdateOperationsInput | number
    grade?: EnumTypeDiplomeFieldUpdateOperationsInput | $Enums.TypeDiplome
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreSemaine?: IntFieldUpdateOperationsInput | number
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UniteEnseignementCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    numero?: number
    credit: number
    semestre?: SemestreCreateNestedOneWithoutUniteEnseignementInput
    matieres?: MatiereCreateNestedManyWithoutUniteEnseignementInput
  }

  export type UniteEnseignementUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    numero?: number
    credit: number
    semestreId?: number | null
    matieres?: MatiereUncheckedCreateNestedManyWithoutUniteEnseignementInput
  }

  export type UniteEnseignementUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    credit?: IntFieldUpdateOperationsInput | number
    semestre?: SemestreUpdateOneWithoutUniteEnseignementNestedInput
    matieres?: MatiereUpdateManyWithoutUniteEnseignementNestedInput
  }

  export type UniteEnseignementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    credit?: IntFieldUpdateOperationsInput | number
    semestreId?: NullableIntFieldUpdateOperationsInput | number | null
    matieres?: MatiereUncheckedUpdateManyWithoutUniteEnseignementNestedInput
  }

  export type UniteEnseignementCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    numero?: number
    credit: number
    semestreId?: number | null
  }

  export type UniteEnseignementUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    credit?: IntFieldUpdateOperationsInput | number
  }

  export type UniteEnseignementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    credit?: IntFieldUpdateOperationsInput | number
    semestreId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MatiereCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    credit: number
    coefficient?: number
    nbHeure?: number | null
    cours?: CoursCreateNestedManyWithoutMatiereInput
    uniteEnseignement: UniteEnseignementCreateNestedOneWithoutMatieresInput
  }

  export type MatiereUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    credit: number
    coefficient?: number
    nbHeure?: number | null
    uniteEnseignementId: number
    cours?: CoursUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    nbHeure?: NullableIntFieldUpdateOperationsInput | number | null
    cours?: CoursUpdateManyWithoutMatiereNestedInput
    uniteEnseignement?: UniteEnseignementUpdateOneRequiredWithoutMatieresNestedInput
  }

  export type MatiereUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    nbHeure?: NullableIntFieldUpdateOperationsInput | number | null
    uniteEnseignementId?: IntFieldUpdateOperationsInput | number
    cours?: CoursUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    credit: number
    coefficient?: number
    nbHeure?: number | null
    uniteEnseignementId: number
  }

  export type MatiereUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    nbHeure?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MatiereUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    nbHeure?: NullableIntFieldUpdateOperationsInput | number | null
    uniteEnseignementId?: IntFieldUpdateOperationsInput | number
  }

  export type EtablissementCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresse?: AdresseCreateNestedOneWithoutEtablissementsInput
    contact?: ContactCreateNestedOneWithoutEtablissementsInput
    utilisateurs?: UtilisateurCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseCreateNestedManyWithoutEtablissementInput
    salle?: SalleCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresseId?: number | null
    contactId?: number | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineUncheckedCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseUncheckedCreateNestedManyWithoutEtablissementInput
    salle?: SalleUncheckedCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: AdresseUpdateOneWithoutEtablissementsNestedInput
    contact?: ContactUpdateOneWithoutEtablissementsNestedInput
    utilisateurs?: UtilisateurUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUncheckedUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUncheckedUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresseId?: number | null
    contactId?: number | null
  }

  export type EtablissementUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EtablissementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClasseCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissement: EtablissementCreateNestedOneWithoutClassesInput
    semestres?: SemestreCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionCreateNestedManyWithoutClasseInput
    specialite: SpecialiteCreateNestedOneWithoutClasseInput
    Cours?: CoursCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutClasseInput
    AnneeScolaire?: AnneeScolaireCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    specialiteId: number
    anneeScolaireId?: number | null
    semestres?: SemestreUncheckedCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutClasseInput
    Cours?: CoursUncheckedCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissement?: EtablissementUpdateOneRequiredWithoutClassesNestedInput
    semestres?: SemestreUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUpdateManyWithoutClasseNestedInput
    specialite?: SpecialiteUpdateOneRequiredWithoutClasseNestedInput
    Cours?: CoursUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutClasseNestedInput
    AnneeScolaire?: AnneeScolaireUpdateOneWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
    semestres?: SemestreUncheckedUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUncheckedUpdateManyWithoutClasseNestedInput
    Cours?: CoursUncheckedUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ClasseCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    specialiteId: number
    anneeScolaireId?: number | null
  }

  export type ClasseUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
  }

  export type ClasseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AnneeScolaireCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    dateDebut: number
    dateFin: number
    nom: string
    classes?: ClasseCreateNestedManyWithoutAnneeScolaireInput
  }

  export type AnneeScolaireUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dateDebut: number
    dateFin: number
    nom: string
    classes?: ClasseUncheckedCreateNestedManyWithoutAnneeScolaireInput
  }

  export type AnneeScolaireUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDebut?: IntFieldUpdateOperationsInput | number
    dateFin?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    classes?: ClasseUpdateManyWithoutAnneeScolaireNestedInput
  }

  export type AnneeScolaireUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDebut?: IntFieldUpdateOperationsInput | number
    dateFin?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    classes?: ClasseUncheckedUpdateManyWithoutAnneeScolaireNestedInput
  }

  export type AnneeScolaireCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dateDebut: number
    dateFin: number
    nom: string
  }

  export type AnneeScolaireUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDebut?: IntFieldUpdateOperationsInput | number
    dateFin?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type AnneeScolaireUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDebut?: IntFieldUpdateOperationsInput | number
    dateFin?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type EvaluationEtudiantsCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    typeEvaluation: $Enums.TypeEvaluation
    dateEvaluation: Date | string
    duree: number
    document: string
    description?: string | null
    cours: CoursCreateNestedOneWithoutEvaluationEtudiantInput
    NoteEtudiant?: NoteEtudiantCreateNestedManyWithoutEvaluationEtudiantInput
  }

  export type EvaluationEtudiantsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    typeEvaluation: $Enums.TypeEvaluation
    dateEvaluation: Date | string
    duree: number
    document: string
    description?: string | null
    coursId: number
    NoteEtudiant?: NoteEtudiantUncheckedCreateNestedManyWithoutEvaluationEtudiantInput
  }

  export type EvaluationEtudiantsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvaluation?: EnumTypeEvaluationFieldUpdateOperationsInput | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cours?: CoursUpdateOneRequiredWithoutEvaluationEtudiantNestedInput
    NoteEtudiant?: NoteEtudiantUpdateManyWithoutEvaluationEtudiantNestedInput
  }

  export type EvaluationEtudiantsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvaluation?: EnumTypeEvaluationFieldUpdateOperationsInput | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coursId?: IntFieldUpdateOperationsInput | number
    NoteEtudiant?: NoteEtudiantUncheckedUpdateManyWithoutEvaluationEtudiantNestedInput
  }

  export type EvaluationEtudiantsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    typeEvaluation: $Enums.TypeEvaluation
    dateEvaluation: Date | string
    duree: number
    document: string
    description?: string | null
    coursId: number
  }

  export type EvaluationEtudiantsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvaluation?: EnumTypeEvaluationFieldUpdateOperationsInput | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaluationEtudiantsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvaluation?: EnumTypeEvaluationFieldUpdateOperationsInput | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coursId?: IntFieldUpdateOperationsInput | number
  }

  export type NoteEtudiantCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    note: number
    evaluationEtudiant?: EvaluationEtudiantsCreateNestedOneWithoutNoteEtudiantInput
    etudiant: EtudiantCreateNestedOneWithoutNotesInput
  }

  export type NoteEtudiantUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note: number
    evaluationEtudiantId?: number | null
    etudiantId: number
  }

  export type NoteEtudiantUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
    evaluationEtudiant?: EvaluationEtudiantsUpdateOneWithoutNoteEtudiantNestedInput
    etudiant?: EtudiantUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteEtudiantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
    evaluationEtudiantId?: NullableIntFieldUpdateOperationsInput | number | null
    etudiantId?: IntFieldUpdateOperationsInput | number
  }

  export type NoteEtudiantCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note: number
    evaluationEtudiantId?: number | null
    etudiantId: number
  }

  export type NoteEtudiantUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
  }

  export type NoteEtudiantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
    evaluationEtudiantId?: NullableIntFieldUpdateOperationsInput | number | null
    etudiantId?: IntFieldUpdateOperationsInput | number
  }

  export type CoursCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiere?: MatiereCreateNestedOneWithoutCoursInput
    salle?: SalleCreateNestedOneWithoutCoursInput
    classe?: ClasseCreateNestedOneWithoutCoursInput
    professeur?: ProfesseurCreateNestedOneWithoutCoursInput
    evaluationEtudiant?: EvaluationEtudiantsCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutCoursInput
  }

  export type CoursUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    salleId?: number | null
    classeId?: number | null
    professeurId?: number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutCoursInput
  }

  export type CoursUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutCoursNestedInput
    salle?: SalleUpdateOneWithoutCoursNestedInput
    classe?: ClasseUpdateOneWithoutCoursNestedInput
    professeur?: ProfesseurUpdateOneWithoutCoursNestedInput
    evaluationEtudiant?: EvaluationEtudiantsUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutCoursNestedInput
  }

  export type CoursCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    salleId?: number | null
    classeId?: number | null
    professeurId?: number | null
  }

  export type CoursUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SalleCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    estDisponible?: boolean
    etablissement: EtablissementCreateNestedOneWithoutSalleInput
    cours?: CoursCreateNestedManyWithoutSalleInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutSalleInput
  }

  export type SalleUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    etablissementId: number
    estDisponible?: boolean
    cours?: CoursUncheckedCreateNestedManyWithoutSalleInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutSalleInput
  }

  export type SalleUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
    etablissement?: EtablissementUpdateOneRequiredWithoutSalleNestedInput
    cours?: CoursUpdateManyWithoutSalleNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutSalleNestedInput
  }

  export type SalleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    etablissementId?: IntFieldUpdateOperationsInput | number
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
    cours?: CoursUncheckedUpdateManyWithoutSalleNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutSalleNestedInput
  }

  export type SalleCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    etablissementId: number
    estDisponible?: boolean
  }

  export type SalleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    etablissementId?: IntFieldUpdateOperationsInput | number
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeuillePresenceCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    cours: CoursCreateNestedOneWithoutFeuillePresencesInput
    etudiant?: EtudiantCreateNestedOneWithoutFeuillePresencesInput
  }

  export type FeuillePresenceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    coursId: number
    etudiantId?: number | null
  }

  export type FeuillePresenceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cours?: CoursUpdateOneRequiredWithoutFeuillePresencesNestedInput
    etudiant?: EtudiantUpdateOneWithoutFeuillePresencesNestedInput
  }

  export type FeuillePresenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    coursId?: IntFieldUpdateOperationsInput | number
    etudiantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FeuillePresenceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    coursId: number
    etudiantId?: number | null
  }

  export type FeuillePresenceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeuillePresenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    coursId?: IntFieldUpdateOperationsInput | number
    etudiantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmploiDuTempsCreateInput = {
    dateDebut: Date | string
    dateFin: Date | string
    cours: CoursCreateNestedOneWithoutEmploiDuTempsInput
    classe: ClasseCreateNestedOneWithoutEmploiDuTempsInput
    professeur?: ProfesseurCreateNestedOneWithoutEmploiDuTempsInput
    salle: SalleCreateNestedOneWithoutEmploiDuTempsInput
  }

  export type EmploiDuTempsUncheckedCreateInput = {
    id?: number
    coursId: number
    classeId: number
    professeurId?: number | null
    salleId: number
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type EmploiDuTempsUpdateInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cours?: CoursUpdateOneRequiredWithoutEmploiDuTempsNestedInput
    classe?: ClasseUpdateOneRequiredWithoutEmploiDuTempsNestedInput
    professeur?: ProfesseurUpdateOneWithoutEmploiDuTempsNestedInput
    salle?: SalleUpdateOneRequiredWithoutEmploiDuTempsNestedInput
  }

  export type EmploiDuTempsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    coursId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploiDuTempsCreateManyInput = {
    id?: number
    coursId: number
    classeId: number
    professeurId?: number | null
    salleId: number
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type EmploiDuTempsUpdateManyMutationInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploiDuTempsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    coursId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateInput = {
    montant: number
    datePaiement: Date | string
    methodePaiement: string
    referencePaiement: string
    typeFrais: string
    statutPaiement: string
    etudiant: EtudiantCreateNestedOneWithoutPaiementInput
  }

  export type PaiementUncheckedCreateInput = {
    id?: number
    etudiantId: number
    montant: number
    datePaiement: Date | string
    methodePaiement: string
    referencePaiement: string
    typeFrais: string
    statutPaiement: string
  }

  export type PaiementUpdateInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: StringFieldUpdateOperationsInput | string
    typeFrais?: StringFieldUpdateOperationsInput | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    etudiant?: EtudiantUpdateOneRequiredWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: StringFieldUpdateOperationsInput | string
    typeFrais?: StringFieldUpdateOperationsInput | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
  }

  export type PaiementCreateManyInput = {
    id?: number
    etudiantId: number
    montant: number
    datePaiement: Date | string
    methodePaiement: string
    referencePaiement: string
    typeFrais: string
    statutPaiement: string
  }

  export type PaiementUpdateManyMutationInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: StringFieldUpdateOperationsInput | string
    typeFrais?: StringFieldUpdateOperationsInput | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
  }

  export type PaiementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: StringFieldUpdateOperationsInput | string
    typeFrais?: StringFieldUpdateOperationsInput | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    has?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    password?: SortOrder
    roles?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGenreFilter<$PrismaModel = never> = {
    equals?: $Enums.Genre | EnumGenreFieldRefInput<$PrismaModel>
    in?: $Enums.Genre[] | ListEnumGenreFieldRefInput<$PrismaModel>
    notIn?: $Enums.Genre[] | ListEnumGenreFieldRefInput<$PrismaModel>
    not?: NestedEnumGenreFilter<$PrismaModel> | $Enums.Genre
  }

  export type EnumGroupeSanguinNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupeSanguin | EnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    in?: $Enums.GroupeSanguin[] | ListEnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GroupeSanguin[] | ListEnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel> | $Enums.GroupeSanguin | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ContactNullableRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type AdresseNullableRelationFilter = {
    is?: AdresseWhereInput | null
    isNot?: AdresseWhereInput | null
  }

  export type EtablissementNullableRelationFilter = {
    is?: EtablissementWhereInput | null
    isNot?: EtablissementWhereInput | null
  }

  export type EtudiantNullableRelationFilter = {
    is?: EtudiantWhereInput | null
    isNot?: EtudiantWhereInput | null
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type ProfesseurNullableRelationFilter = {
    is?: ProfesseurWhereInput | null
    isNot?: ProfesseurWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UtilisateurCountOrderByAggregateInput = {
    id?: SortOrder
    matricule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrder
    lieuNaissance?: SortOrder
    cni?: SortOrder
    genre?: SortOrder
    nationalite?: SortOrder
    groupeSanguin?: SortOrder
    etablissementId?: SortOrder
    statutCompte?: SortOrder
    roles?: SortOrder
    contactId?: SortOrder
    adresseId?: SortOrder
    accountId?: SortOrder
  }

  export type UtilisateurAvgOrderByAggregateInput = {
    id?: SortOrder
    etablissementId?: SortOrder
    contactId?: SortOrder
    adresseId?: SortOrder
    accountId?: SortOrder
  }

  export type UtilisateurMaxOrderByAggregateInput = {
    id?: SortOrder
    matricule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrder
    lieuNaissance?: SortOrder
    cni?: SortOrder
    genre?: SortOrder
    nationalite?: SortOrder
    groupeSanguin?: SortOrder
    etablissementId?: SortOrder
    statutCompte?: SortOrder
    contactId?: SortOrder
    adresseId?: SortOrder
    accountId?: SortOrder
  }

  export type UtilisateurMinOrderByAggregateInput = {
    id?: SortOrder
    matricule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrder
    lieuNaissance?: SortOrder
    cni?: SortOrder
    genre?: SortOrder
    nationalite?: SortOrder
    groupeSanguin?: SortOrder
    etablissementId?: SortOrder
    statutCompte?: SortOrder
    contactId?: SortOrder
    adresseId?: SortOrder
    accountId?: SortOrder
  }

  export type UtilisateurSumOrderByAggregateInput = {
    id?: SortOrder
    etablissementId?: SortOrder
    contactId?: SortOrder
    adresseId?: SortOrder
    accountId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGenreWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Genre | EnumGenreFieldRefInput<$PrismaModel>
    in?: $Enums.Genre[] | ListEnumGenreFieldRefInput<$PrismaModel>
    notIn?: $Enums.Genre[] | ListEnumGenreFieldRefInput<$PrismaModel>
    not?: NestedEnumGenreWithAggregatesFilter<$PrismaModel> | $Enums.Genre
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenreFilter<$PrismaModel>
    _max?: NestedEnumGenreFilter<$PrismaModel>
  }

  export type EnumGroupeSanguinNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupeSanguin | EnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    in?: $Enums.GroupeSanguin[] | ListEnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GroupeSanguin[] | ListEnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGroupeSanguinNullableWithAggregatesFilter<$PrismaModel> | $Enums.GroupeSanguin | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel>
    _max?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UtilisateurListRelationFilter = {
    every?: UtilisateurWhereInput
    some?: UtilisateurWhereInput
    none?: UtilisateurWhereInput
  }

  export type UtilisateurOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    label?: SortOrder
    slug?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    label?: SortOrder
    slug?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    label?: SortOrder
    slug?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EtablissementListRelationFilter = {
    every?: EtablissementWhereInput
    some?: EtablissementWhereInput
    none?: EtablissementWhereInput
  }

  export type EtablissementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdresseCountOrderByAggregateInput = {
    id?: SortOrder
    pays?: SortOrder
    region?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    geolocalisation?: SortOrder
  }

  export type AdresseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdresseMaxOrderByAggregateInput = {
    id?: SortOrder
    pays?: SortOrder
    region?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    geolocalisation?: SortOrder
  }

  export type AdresseMinOrderByAggregateInput = {
    id?: SortOrder
    pays?: SortOrder
    region?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    geolocalisation?: SortOrder
  }

  export type AdresseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReseauSocialCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    username?: SortOrder
    url?: SortOrder
    contactId?: SortOrder
  }

  export type ReseauSocialAvgOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
  }

  export type ReseauSocialMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    username?: SortOrder
    url?: SortOrder
    contactId?: SortOrder
  }

  export type ReseauSocialMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    username?: SortOrder
    url?: SortOrder
    contactId?: SortOrder
  }

  export type ReseauSocialSumOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
  }

  export type ReseauSocialListRelationFilter = {
    every?: ReseauSocialWhereInput
    some?: ReseauSocialWhereInput
    none?: ReseauSocialWhereInput
  }

  export type ReseauSocialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telephone?: SortOrder
    fix?: SortOrder
    fax?: SortOrder
    email?: SortOrder
    siteWeb?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telephone?: SortOrder
    fix?: SortOrder
    fax?: SortOrder
    email?: SortOrder
    siteWeb?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telephone?: SortOrder
    fix?: SortOrder
    fax?: SortOrder
    email?: SortOrder
    siteWeb?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UtilisateurRelationFilter = {
    is?: UtilisateurWhereInput
    isNot?: UtilisateurWhereInput
  }

  export type InscriptionListRelationFilter = {
    every?: InscriptionWhereInput
    some?: InscriptionWhereInput
    none?: InscriptionWhereInput
  }

  export type NoteEtudiantListRelationFilter = {
    every?: NoteEtudiantWhereInput
    some?: NoteEtudiantWhereInput
    none?: NoteEtudiantWhereInput
  }

  export type FeuillePresenceListRelationFilter = {
    every?: FeuillePresenceWhereInput
    some?: FeuillePresenceWhereInput
    none?: FeuillePresenceWhereInput
  }

  export type PaiementListRelationFilter = {
    every?: PaiementWhereInput
    some?: PaiementWhereInput
    none?: PaiementWhereInput
  }

  export type InscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteEtudiantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeuillePresenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaiementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EtudiantCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    ine?: SortOrder
    baccaleaureat?: SortOrder
    anneeBaccaleaureat?: SortOrder
    profileId?: SortOrder
    feuillePresencesId?: SortOrder
  }

  export type EtudiantAvgOrderByAggregateInput = {
    id?: SortOrder
    anneeBaccaleaureat?: SortOrder
    profileId?: SortOrder
    feuillePresencesId?: SortOrder
  }

  export type EtudiantMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    ine?: SortOrder
    baccaleaureat?: SortOrder
    anneeBaccaleaureat?: SortOrder
    profileId?: SortOrder
    feuillePresencesId?: SortOrder
  }

  export type EtudiantMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    ine?: SortOrder
    baccaleaureat?: SortOrder
    anneeBaccaleaureat?: SortOrder
    profileId?: SortOrder
    feuillePresencesId?: SortOrder
  }

  export type EtudiantSumOrderByAggregateInput = {
    id?: SortOrder
    anneeBaccaleaureat?: SortOrder
    profileId?: SortOrder
    feuillePresencesId?: SortOrder
  }

  export type CoursListRelationFilter = {
    every?: CoursWhereInput
    some?: CoursWhereInput
    none?: CoursWhereInput
  }

  export type EmploiDuTempsListRelationFilter = {
    every?: EmploiDuTempsWhereInput
    some?: EmploiDuTempsWhereInput
    none?: EmploiDuTempsWhereInput
  }

  export type CoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmploiDuTempsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfesseurCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type ProfesseurAvgOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
  }

  export type ProfesseurMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type ProfesseurMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type ProfesseurSumOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
  }

  export type DiplomeRelationFilter = {
    is?: DiplomeWhereInput
    isNot?: DiplomeWhereInput
  }

  export type EtudiantRelationFilter = {
    is?: EtudiantWhereInput
    isNot?: EtudiantWhereInput
  }

  export type ClasseRelationFilter = {
    is?: ClasseWhereInput
    isNot?: ClasseWhereInput
  }

  export type InscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reference?: SortOrder
    premiereInscription?: SortOrder
    dernierDiplome?: SortOrder
    autreEtablissement?: SortOrder
    activiteProfessionnel?: SortOrder
    niveau?: SortOrder
    statut?: SortOrder
    diplomeId?: SortOrder
    etudiantId?: SortOrder
    classeId?: SortOrder
  }

  export type InscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    diplomeId?: SortOrder
    etudiantId?: SortOrder
    classeId?: SortOrder
  }

  export type InscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reference?: SortOrder
    premiereInscription?: SortOrder
    dernierDiplome?: SortOrder
    autreEtablissement?: SortOrder
    activiteProfessionnel?: SortOrder
    niveau?: SortOrder
    statut?: SortOrder
    diplomeId?: SortOrder
    etudiantId?: SortOrder
    classeId?: SortOrder
  }

  export type InscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reference?: SortOrder
    premiereInscription?: SortOrder
    dernierDiplome?: SortOrder
    autreEtablissement?: SortOrder
    activiteProfessionnel?: SortOrder
    niveau?: SortOrder
    statut?: SortOrder
    diplomeId?: SortOrder
    etudiantId?: SortOrder
    classeId?: SortOrder
  }

  export type InscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    diplomeId?: SortOrder
    etudiantId?: SortOrder
    classeId?: SortOrder
  }

  export type MentionListRelationFilter = {
    every?: MentionWhereInput
    some?: MentionWhereInput
    none?: MentionWhereInput
  }

  export type MentionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomaineCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrder
  }

  export type DomaineAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DomaineMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrder
  }

  export type DomaineMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrder
  }

  export type DomaineSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DomaineNullableRelationFilter = {
    is?: DomaineWhereInput | null
    isNot?: DomaineWhereInput | null
  }

  export type SpecialiteListRelationFilter = {
    every?: SpecialiteWhereInput
    some?: SpecialiteWhereInput
    none?: SpecialiteWhereInput
  }

  export type SpecialiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrder
    domaineId?: SortOrder
  }

  export type MentionAvgOrderByAggregateInput = {
    id?: SortOrder
    domaineId?: SortOrder
  }

  export type MentionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrder
    domaineId?: SortOrder
  }

  export type MentionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrder
    domaineId?: SortOrder
  }

  export type MentionSumOrderByAggregateInput = {
    id?: SortOrder
    domaineId?: SortOrder
  }

  export type MentionNullableRelationFilter = {
    is?: MentionWhereInput | null
    isNot?: MentionWhereInput | null
  }

  export type ClasseListRelationFilter = {
    every?: ClasseWhereInput
    some?: ClasseWhereInput
    none?: ClasseWhereInput
  }

  export type DiplomeListRelationFilter = {
    every?: DiplomeWhereInput
    some?: DiplomeWhereInput
    none?: DiplomeWhereInput
  }

  export type ClasseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiplomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialiteCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrder
    mentionId?: SortOrder
  }

  export type SpecialiteAvgOrderByAggregateInput = {
    id?: SortOrder
    mentionId?: SortOrder
  }

  export type SpecialiteMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrder
    mentionId?: SortOrder
  }

  export type SpecialiteMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    slug?: SortOrder
    mentionId?: SortOrder
  }

  export type SpecialiteSumOrderByAggregateInput = {
    id?: SortOrder
    mentionId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SpecialiteNullableRelationFilter = {
    is?: SpecialiteWhereInput | null
    isNot?: SpecialiteWhereInput | null
  }

  export type DiplomeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    finalite?: SortOrder
    entite?: SortOrder
    habilitation?: SortOrder
    partenaires?: SortOrder
    dateCreation?: SortOrder
    dateHabilitation?: SortOrder
    dateEcheance?: SortOrder
    duree?: SortOrder
    specialiteId?: SortOrder
  }

  export type DiplomeAvgOrderByAggregateInput = {
    id?: SortOrder
    duree?: SortOrder
    specialiteId?: SortOrder
  }

  export type DiplomeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    finalite?: SortOrder
    entite?: SortOrder
    habilitation?: SortOrder
    dateCreation?: SortOrder
    dateHabilitation?: SortOrder
    dateEcheance?: SortOrder
    duree?: SortOrder
    specialiteId?: SortOrder
  }

  export type DiplomeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    finalite?: SortOrder
    entite?: SortOrder
    habilitation?: SortOrder
    dateCreation?: SortOrder
    dateHabilitation?: SortOrder
    dateEcheance?: SortOrder
    duree?: SortOrder
    specialiteId?: SortOrder
  }

  export type DiplomeSumOrderByAggregateInput = {
    id?: SortOrder
    duree?: SortOrder
    specialiteId?: SortOrder
  }

  export type EnumTypeDiplomeFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeDiplome | EnumTypeDiplomeFieldRefInput<$PrismaModel>
    in?: $Enums.TypeDiplome[] | ListEnumTypeDiplomeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeDiplome[] | ListEnumTypeDiplomeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeDiplomeFilter<$PrismaModel> | $Enums.TypeDiplome
  }

  export type UniteEnseignementListRelationFilter = {
    every?: UniteEnseignementWhereInput
    some?: UniteEnseignementWhereInput
    none?: UniteEnseignementWhereInput
  }

  export type ClasseNullableRelationFilter = {
    is?: ClasseWhereInput | null
    isNot?: ClasseWhereInput | null
  }

  export type UniteEnseignementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemestreCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numero?: SortOrder
    grade?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nombreSemaine?: SortOrder
    classeId?: SortOrder
  }

  export type SemestreAvgOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    nombreSemaine?: SortOrder
    classeId?: SortOrder
  }

  export type SemestreMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numero?: SortOrder
    grade?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nombreSemaine?: SortOrder
    classeId?: SortOrder
  }

  export type SemestreMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numero?: SortOrder
    grade?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nombreSemaine?: SortOrder
    classeId?: SortOrder
  }

  export type SemestreSumOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    nombreSemaine?: SortOrder
    classeId?: SortOrder
  }

  export type EnumTypeDiplomeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeDiplome | EnumTypeDiplomeFieldRefInput<$PrismaModel>
    in?: $Enums.TypeDiplome[] | ListEnumTypeDiplomeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeDiplome[] | ListEnumTypeDiplomeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeDiplomeWithAggregatesFilter<$PrismaModel> | $Enums.TypeDiplome
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeDiplomeFilter<$PrismaModel>
    _max?: NestedEnumTypeDiplomeFilter<$PrismaModel>
  }

  export type SemestreNullableRelationFilter = {
    is?: SemestreWhereInput | null
    isNot?: SemestreWhereInput | null
  }

  export type MatiereListRelationFilter = {
    every?: MatiereWhereInput
    some?: MatiereWhereInput
    none?: MatiereWhereInput
  }

  export type MatiereOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UniteEnseignementCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    numero?: SortOrder
    credit?: SortOrder
    semestreId?: SortOrder
  }

  export type UniteEnseignementAvgOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    credit?: SortOrder
    semestreId?: SortOrder
  }

  export type UniteEnseignementMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    numero?: SortOrder
    credit?: SortOrder
    semestreId?: SortOrder
  }

  export type UniteEnseignementMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    numero?: SortOrder
    credit?: SortOrder
    semestreId?: SortOrder
  }

  export type UniteEnseignementSumOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    credit?: SortOrder
    semestreId?: SortOrder
  }

  export type UniteEnseignementRelationFilter = {
    is?: UniteEnseignementWhereInput
    isNot?: UniteEnseignementWhereInput
  }

  export type MatiereCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    credit?: SortOrder
    coefficient?: SortOrder
    nbHeure?: SortOrder
    uniteEnseignementId?: SortOrder
  }

  export type MatiereAvgOrderByAggregateInput = {
    id?: SortOrder
    credit?: SortOrder
    coefficient?: SortOrder
    nbHeure?: SortOrder
    uniteEnseignementId?: SortOrder
  }

  export type MatiereMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    credit?: SortOrder
    coefficient?: SortOrder
    nbHeure?: SortOrder
    uniteEnseignementId?: SortOrder
  }

  export type MatiereMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    credit?: SortOrder
    coefficient?: SortOrder
    nbHeure?: SortOrder
    uniteEnseignementId?: SortOrder
  }

  export type MatiereSumOrderByAggregateInput = {
    id?: SortOrder
    credit?: SortOrder
    coefficient?: SortOrder
    nbHeure?: SortOrder
    uniteEnseignementId?: SortOrder
  }

  export type DomaineListRelationFilter = {
    every?: DomaineWhereInput
    some?: DomaineWhereInput
    none?: DomaineWhereInput
  }

  export type SalleListRelationFilter = {
    every?: SalleWhereInput
    some?: SalleWhereInput
    none?: SalleWhereInput
  }

  export type DomaineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EtablissementCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    matricule?: SortOrder
    sigle?: SortOrder
    dateCreation?: SortOrder
    logo?: SortOrder
    anneeEnCours?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
  }

  export type EtablissementAvgOrderByAggregateInput = {
    id?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
  }

  export type EtablissementMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    matricule?: SortOrder
    sigle?: SortOrder
    dateCreation?: SortOrder
    logo?: SortOrder
    anneeEnCours?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
  }

  export type EtablissementMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    matricule?: SortOrder
    sigle?: SortOrder
    dateCreation?: SortOrder
    logo?: SortOrder
    anneeEnCours?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
  }

  export type EtablissementSumOrderByAggregateInput = {
    id?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
  }

  export type EtablissementRelationFilter = {
    is?: EtablissementWhereInput
    isNot?: EtablissementWhereInput
  }

  export type SemestreListRelationFilter = {
    every?: SemestreWhereInput
    some?: SemestreWhereInput
    none?: SemestreWhereInput
  }

  export type SpecialiteRelationFilter = {
    is?: SpecialiteWhereInput
    isNot?: SpecialiteWhereInput
  }

  export type AnneeScolaireNullableRelationFilter = {
    is?: AnneeScolaireWhereInput | null
    isNot?: AnneeScolaireWhereInput | null
  }

  export type SemestreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClasseCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveau?: SortOrder
    etablissementId?: SortOrder
    specialiteId?: SortOrder
    anneeScolaireId?: SortOrder
  }

  export type ClasseAvgOrderByAggregateInput = {
    id?: SortOrder
    etablissementId?: SortOrder
    specialiteId?: SortOrder
    anneeScolaireId?: SortOrder
  }

  export type ClasseMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveau?: SortOrder
    etablissementId?: SortOrder
    specialiteId?: SortOrder
    anneeScolaireId?: SortOrder
  }

  export type ClasseMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveau?: SortOrder
    etablissementId?: SortOrder
    specialiteId?: SortOrder
    anneeScolaireId?: SortOrder
  }

  export type ClasseSumOrderByAggregateInput = {
    id?: SortOrder
    etablissementId?: SortOrder
    specialiteId?: SortOrder
    anneeScolaireId?: SortOrder
  }

  export type AnneeScolaireCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nom?: SortOrder
  }

  export type AnneeScolaireAvgOrderByAggregateInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type AnneeScolaireMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nom?: SortOrder
  }

  export type AnneeScolaireMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nom?: SortOrder
  }

  export type AnneeScolaireSumOrderByAggregateInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type EnumTypeEvaluationFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeEvaluation | EnumTypeEvaluationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeEvaluation[] | ListEnumTypeEvaluationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeEvaluation[] | ListEnumTypeEvaluationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeEvaluationFilter<$PrismaModel> | $Enums.TypeEvaluation
  }

  export type CoursRelationFilter = {
    is?: CoursWhereInput
    isNot?: CoursWhereInput
  }

  export type EvaluationEtudiantsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeEvaluation?: SortOrder
    dateEvaluation?: SortOrder
    duree?: SortOrder
    document?: SortOrder
    description?: SortOrder
    coursId?: SortOrder
  }

  export type EvaluationEtudiantsAvgOrderByAggregateInput = {
    id?: SortOrder
    duree?: SortOrder
    coursId?: SortOrder
  }

  export type EvaluationEtudiantsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeEvaluation?: SortOrder
    dateEvaluation?: SortOrder
    duree?: SortOrder
    document?: SortOrder
    description?: SortOrder
    coursId?: SortOrder
  }

  export type EvaluationEtudiantsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeEvaluation?: SortOrder
    dateEvaluation?: SortOrder
    duree?: SortOrder
    document?: SortOrder
    description?: SortOrder
    coursId?: SortOrder
  }

  export type EvaluationEtudiantsSumOrderByAggregateInput = {
    id?: SortOrder
    duree?: SortOrder
    coursId?: SortOrder
  }

  export type EnumTypeEvaluationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeEvaluation | EnumTypeEvaluationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeEvaluation[] | ListEnumTypeEvaluationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeEvaluation[] | ListEnumTypeEvaluationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeEvaluationWithAggregatesFilter<$PrismaModel> | $Enums.TypeEvaluation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeEvaluationFilter<$PrismaModel>
    _max?: NestedEnumTypeEvaluationFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EvaluationEtudiantsNullableRelationFilter = {
    is?: EvaluationEtudiantsWhereInput | null
    isNot?: EvaluationEtudiantsWhereInput | null
  }

  export type NoteEtudiantEvaluationEtudiantIdEtudiantIdNoteCompoundUniqueInput = {
    evaluationEtudiantId: number
    etudiantId: number
    note: number
  }

  export type NoteEtudiantCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note?: SortOrder
    evaluationEtudiantId?: SortOrder
    etudiantId?: SortOrder
  }

  export type NoteEtudiantAvgOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    evaluationEtudiantId?: SortOrder
    etudiantId?: SortOrder
  }

  export type NoteEtudiantMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note?: SortOrder
    evaluationEtudiantId?: SortOrder
    etudiantId?: SortOrder
  }

  export type NoteEtudiantMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note?: SortOrder
    evaluationEtudiantId?: SortOrder
    etudiantId?: SortOrder
  }

  export type NoteEtudiantSumOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    evaluationEtudiantId?: SortOrder
    etudiantId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type MatiereNullableRelationFilter = {
    is?: MatiereWhereInput | null
    isNot?: MatiereWhereInput | null
  }

  export type SalleNullableRelationFilter = {
    is?: SalleWhereInput | null
    isNot?: SalleWhereInput | null
  }

  export type EvaluationEtudiantsListRelationFilter = {
    every?: EvaluationEtudiantsWhereInput
    some?: EvaluationEtudiantsWhereInput
    none?: EvaluationEtudiantsWhereInput
  }

  export type EvaluationEtudiantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoursCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    matiereId?: SortOrder
    salleId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
  }

  export type CoursAvgOrderByAggregateInput = {
    id?: SortOrder
    matiereId?: SortOrder
    salleId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
  }

  export type CoursMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    matiereId?: SortOrder
    salleId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
  }

  export type CoursMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    matiereId?: SortOrder
    salleId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
  }

  export type CoursSumOrderByAggregateInput = {
    id?: SortOrder
    matiereId?: SortOrder
    salleId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
  }

  export type SalleCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    capacite?: SortOrder
    batiment?: SortOrder
    etablissementId?: SortOrder
    estDisponible?: SortOrder
  }

  export type SalleAvgOrderByAggregateInput = {
    id?: SortOrder
    capacite?: SortOrder
    etablissementId?: SortOrder
  }

  export type SalleMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    capacite?: SortOrder
    batiment?: SortOrder
    etablissementId?: SortOrder
    estDisponible?: SortOrder
  }

  export type SalleMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    capacite?: SortOrder
    batiment?: SortOrder
    etablissementId?: SortOrder
    estDisponible?: SortOrder
  }

  export type SalleSumOrderByAggregateInput = {
    id?: SortOrder
    capacite?: SortOrder
    etablissementId?: SortOrder
  }

  export type FeuillePresenceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    coursId?: SortOrder
    etudiantId?: SortOrder
  }

  export type FeuillePresenceAvgOrderByAggregateInput = {
    id?: SortOrder
    coursId?: SortOrder
    etudiantId?: SortOrder
  }

  export type FeuillePresenceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    coursId?: SortOrder
    etudiantId?: SortOrder
  }

  export type FeuillePresenceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    coursId?: SortOrder
    etudiantId?: SortOrder
  }

  export type FeuillePresenceSumOrderByAggregateInput = {
    id?: SortOrder
    coursId?: SortOrder
    etudiantId?: SortOrder
  }

  export type SalleRelationFilter = {
    is?: SalleWhereInput
    isNot?: SalleWhereInput
  }

  export type EmploiDuTempsCountOrderByAggregateInput = {
    id?: SortOrder
    coursId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
    salleId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type EmploiDuTempsAvgOrderByAggregateInput = {
    id?: SortOrder
    coursId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
    salleId?: SortOrder
  }

  export type EmploiDuTempsMaxOrderByAggregateInput = {
    id?: SortOrder
    coursId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
    salleId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type EmploiDuTempsMinOrderByAggregateInput = {
    id?: SortOrder
    coursId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
    salleId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type EmploiDuTempsSumOrderByAggregateInput = {
    id?: SortOrder
    coursId?: SortOrder
    classeId?: SortOrder
    professeurId?: SortOrder
    salleId?: SortOrder
  }

  export type PaiementCountOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    montant?: SortOrder
    datePaiement?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrder
    typeFrais?: SortOrder
    statutPaiement?: SortOrder
  }

  export type PaiementAvgOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    montant?: SortOrder
  }

  export type PaiementMaxOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    montant?: SortOrder
    datePaiement?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrder
    typeFrais?: SortOrder
    statutPaiement?: SortOrder
  }

  export type PaiementMinOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    montant?: SortOrder
    datePaiement?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrder
    typeFrais?: SortOrder
    statutPaiement?: SortOrder
  }

  export type PaiementSumOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    montant?: SortOrder
  }

  export type AccountCreaterolesInput = {
    set: $Enums.Role[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdaterolesInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UtilisateurCreaterolesInput = {
    set: $Enums.Role[]
  }

  export type ContactCreateNestedOneWithoutUtilisateursInput = {
    create?: XOR<ContactCreateWithoutUtilisateursInput, ContactUncheckedCreateWithoutUtilisateursInput>
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateursInput
    connect?: ContactWhereUniqueInput
  }

  export type AdresseCreateNestedOneWithoutUtilisateursInput = {
    create?: XOR<AdresseCreateWithoutUtilisateursInput, AdresseUncheckedCreateWithoutUtilisateursInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutUtilisateursInput
    connect?: AdresseWhereUniqueInput
  }

  export type EtablissementCreateNestedOneWithoutUtilisateursInput = {
    create?: XOR<EtablissementCreateWithoutUtilisateursInput, EtablissementUncheckedCreateWithoutUtilisateursInput>
    connectOrCreate?: EtablissementCreateOrConnectWithoutUtilisateursInput
    connect?: EtablissementWhereUniqueInput
  }

  export type EtudiantCreateNestedOneWithoutProfileInput = {
    create?: XOR<EtudiantCreateWithoutProfileInput, EtudiantUncheckedCreateWithoutProfileInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutProfileInput
    connect?: EtudiantWhereUniqueInput
  }

  export type PermissionCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<PermissionCreateWithoutUtilisateursInput, PermissionUncheckedCreateWithoutUtilisateursInput> | PermissionCreateWithoutUtilisateursInput[] | PermissionUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutUtilisateursInput | PermissionCreateOrConnectWithoutUtilisateursInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type ProfesseurCreateNestedOneWithoutProfileInput = {
    create?: XOR<ProfesseurCreateWithoutProfileInput, ProfesseurUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfesseurCreateOrConnectWithoutProfileInput
    connect?: ProfesseurWhereUniqueInput
  }

  export type EtudiantUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<EtudiantCreateWithoutProfileInput, EtudiantUncheckedCreateWithoutProfileInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutProfileInput
    connect?: EtudiantWhereUniqueInput
  }

  export type PermissionUncheckedCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<PermissionCreateWithoutUtilisateursInput, PermissionUncheckedCreateWithoutUtilisateursInput> | PermissionCreateWithoutUtilisateursInput[] | PermissionUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutUtilisateursInput | PermissionCreateOrConnectWithoutUtilisateursInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type ProfesseurUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<ProfesseurCreateWithoutProfileInput, ProfesseurUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfesseurCreateOrConnectWithoutProfileInput
    connect?: ProfesseurWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumGenreFieldUpdateOperationsInput = {
    set?: $Enums.Genre
  }

  export type NullableEnumGroupeSanguinFieldUpdateOperationsInput = {
    set?: $Enums.GroupeSanguin | null
  }

  export type UtilisateurUpdaterolesInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContactUpdateOneWithoutUtilisateursNestedInput = {
    create?: XOR<ContactCreateWithoutUtilisateursInput, ContactUncheckedCreateWithoutUtilisateursInput>
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateursInput
    upsert?: ContactUpsertWithoutUtilisateursInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutUtilisateursInput, ContactUpdateWithoutUtilisateursInput>, ContactUncheckedUpdateWithoutUtilisateursInput>
  }

  export type AdresseUpdateOneWithoutUtilisateursNestedInput = {
    create?: XOR<AdresseCreateWithoutUtilisateursInput, AdresseUncheckedCreateWithoutUtilisateursInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutUtilisateursInput
    upsert?: AdresseUpsertWithoutUtilisateursInput
    disconnect?: AdresseWhereInput | boolean
    delete?: AdresseWhereInput | boolean
    connect?: AdresseWhereUniqueInput
    update?: XOR<XOR<AdresseUpdateToOneWithWhereWithoutUtilisateursInput, AdresseUpdateWithoutUtilisateursInput>, AdresseUncheckedUpdateWithoutUtilisateursInput>
  }

  export type EtablissementUpdateOneWithoutUtilisateursNestedInput = {
    create?: XOR<EtablissementCreateWithoutUtilisateursInput, EtablissementUncheckedCreateWithoutUtilisateursInput>
    connectOrCreate?: EtablissementCreateOrConnectWithoutUtilisateursInput
    upsert?: EtablissementUpsertWithoutUtilisateursInput
    disconnect?: EtablissementWhereInput | boolean
    delete?: EtablissementWhereInput | boolean
    connect?: EtablissementWhereUniqueInput
    update?: XOR<XOR<EtablissementUpdateToOneWithWhereWithoutUtilisateursInput, EtablissementUpdateWithoutUtilisateursInput>, EtablissementUncheckedUpdateWithoutUtilisateursInput>
  }

  export type EtudiantUpdateOneWithoutProfileNestedInput = {
    create?: XOR<EtudiantCreateWithoutProfileInput, EtudiantUncheckedCreateWithoutProfileInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutProfileInput
    upsert?: EtudiantUpsertWithoutProfileInput
    disconnect?: EtudiantWhereInput | boolean
    delete?: EtudiantWhereInput | boolean
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutProfileInput, EtudiantUpdateWithoutProfileInput>, EtudiantUncheckedUpdateWithoutProfileInput>
  }

  export type PermissionUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<PermissionCreateWithoutUtilisateursInput, PermissionUncheckedCreateWithoutUtilisateursInput> | PermissionCreateWithoutUtilisateursInput[] | PermissionUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutUtilisateursInput | PermissionCreateOrConnectWithoutUtilisateursInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutUtilisateursInput | PermissionUpsertWithWhereUniqueWithoutUtilisateursInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutUtilisateursInput | PermissionUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutUtilisateursInput | PermissionUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type ProfesseurUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ProfesseurCreateWithoutProfileInput, ProfesseurUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfesseurCreateOrConnectWithoutProfileInput
    upsert?: ProfesseurUpsertWithoutProfileInput
    disconnect?: ProfesseurWhereInput | boolean
    delete?: ProfesseurWhereInput | boolean
    connect?: ProfesseurWhereUniqueInput
    update?: XOR<XOR<ProfesseurUpdateToOneWithWhereWithoutProfileInput, ProfesseurUpdateWithoutProfileInput>, ProfesseurUncheckedUpdateWithoutProfileInput>
  }

  export type EtudiantUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<EtudiantCreateWithoutProfileInput, EtudiantUncheckedCreateWithoutProfileInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutProfileInput
    upsert?: EtudiantUpsertWithoutProfileInput
    disconnect?: EtudiantWhereInput | boolean
    delete?: EtudiantWhereInput | boolean
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutProfileInput, EtudiantUpdateWithoutProfileInput>, EtudiantUncheckedUpdateWithoutProfileInput>
  }

  export type PermissionUncheckedUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<PermissionCreateWithoutUtilisateursInput, PermissionUncheckedCreateWithoutUtilisateursInput> | PermissionCreateWithoutUtilisateursInput[] | PermissionUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutUtilisateursInput | PermissionCreateOrConnectWithoutUtilisateursInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutUtilisateursInput | PermissionUpsertWithWhereUniqueWithoutUtilisateursInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutUtilisateursInput | PermissionUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutUtilisateursInput | PermissionUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type ProfesseurUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ProfesseurCreateWithoutProfileInput, ProfesseurUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfesseurCreateOrConnectWithoutProfileInput
    upsert?: ProfesseurUpsertWithoutProfileInput
    disconnect?: ProfesseurWhereInput | boolean
    delete?: ProfesseurWhereInput | boolean
    connect?: ProfesseurWhereUniqueInput
    update?: XOR<XOR<ProfesseurUpdateToOneWithWhereWithoutProfileInput, ProfesseurUpdateWithoutProfileInput>, ProfesseurUncheckedUpdateWithoutProfileInput>
  }

  export type PermissionCreateroleInput = {
    set: $Enums.Role[]
  }

  export type UtilisateurCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<UtilisateurCreateWithoutPermissionsInput, UtilisateurUncheckedCreateWithoutPermissionsInput> | UtilisateurCreateWithoutPermissionsInput[] | UtilisateurUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutPermissionsInput | UtilisateurCreateOrConnectWithoutPermissionsInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
  }

  export type UtilisateurUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<UtilisateurCreateWithoutPermissionsInput, UtilisateurUncheckedCreateWithoutPermissionsInput> | UtilisateurCreateWithoutPermissionsInput[] | UtilisateurUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutPermissionsInput | UtilisateurCreateOrConnectWithoutPermissionsInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
  }

  export type PermissionUpdateroleInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type UtilisateurUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<UtilisateurCreateWithoutPermissionsInput, UtilisateurUncheckedCreateWithoutPermissionsInput> | UtilisateurCreateWithoutPermissionsInput[] | UtilisateurUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutPermissionsInput | UtilisateurCreateOrConnectWithoutPermissionsInput[]
    upsert?: UtilisateurUpsertWithWhereUniqueWithoutPermissionsInput | UtilisateurUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    disconnect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    delete?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    update?: UtilisateurUpdateWithWhereUniqueWithoutPermissionsInput | UtilisateurUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: UtilisateurUpdateManyWithWhereWithoutPermissionsInput | UtilisateurUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
  }

  export type UtilisateurUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<UtilisateurCreateWithoutPermissionsInput, UtilisateurUncheckedCreateWithoutPermissionsInput> | UtilisateurCreateWithoutPermissionsInput[] | UtilisateurUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutPermissionsInput | UtilisateurCreateOrConnectWithoutPermissionsInput[]
    upsert?: UtilisateurUpsertWithWhereUniqueWithoutPermissionsInput | UtilisateurUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    disconnect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    delete?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    update?: UtilisateurUpdateWithWhereUniqueWithoutPermissionsInput | UtilisateurUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: UtilisateurUpdateManyWithWhereWithoutPermissionsInput | UtilisateurUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
  }

  export type UtilisateurCreateNestedManyWithoutAdresseInput = {
    create?: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput> | UtilisateurCreateWithoutAdresseInput[] | UtilisateurUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAdresseInput | UtilisateurCreateOrConnectWithoutAdresseInput[]
    createMany?: UtilisateurCreateManyAdresseInputEnvelope
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
  }

  export type EtablissementCreateNestedManyWithoutAdresseInput = {
    create?: XOR<EtablissementCreateWithoutAdresseInput, EtablissementUncheckedCreateWithoutAdresseInput> | EtablissementCreateWithoutAdresseInput[] | EtablissementUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutAdresseInput | EtablissementCreateOrConnectWithoutAdresseInput[]
    createMany?: EtablissementCreateManyAdresseInputEnvelope
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
  }

  export type UtilisateurUncheckedCreateNestedManyWithoutAdresseInput = {
    create?: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput> | UtilisateurCreateWithoutAdresseInput[] | UtilisateurUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAdresseInput | UtilisateurCreateOrConnectWithoutAdresseInput[]
    createMany?: UtilisateurCreateManyAdresseInputEnvelope
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
  }

  export type EtablissementUncheckedCreateNestedManyWithoutAdresseInput = {
    create?: XOR<EtablissementCreateWithoutAdresseInput, EtablissementUncheckedCreateWithoutAdresseInput> | EtablissementCreateWithoutAdresseInput[] | EtablissementUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutAdresseInput | EtablissementCreateOrConnectWithoutAdresseInput[]
    createMany?: EtablissementCreateManyAdresseInputEnvelope
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
  }

  export type UtilisateurUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput> | UtilisateurCreateWithoutAdresseInput[] | UtilisateurUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAdresseInput | UtilisateurCreateOrConnectWithoutAdresseInput[]
    upsert?: UtilisateurUpsertWithWhereUniqueWithoutAdresseInput | UtilisateurUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: UtilisateurCreateManyAdresseInputEnvelope
    set?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    disconnect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    delete?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    update?: UtilisateurUpdateWithWhereUniqueWithoutAdresseInput | UtilisateurUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: UtilisateurUpdateManyWithWhereWithoutAdresseInput | UtilisateurUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
  }

  export type EtablissementUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<EtablissementCreateWithoutAdresseInput, EtablissementUncheckedCreateWithoutAdresseInput> | EtablissementCreateWithoutAdresseInput[] | EtablissementUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutAdresseInput | EtablissementCreateOrConnectWithoutAdresseInput[]
    upsert?: EtablissementUpsertWithWhereUniqueWithoutAdresseInput | EtablissementUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: EtablissementCreateManyAdresseInputEnvelope
    set?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    disconnect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    delete?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    update?: EtablissementUpdateWithWhereUniqueWithoutAdresseInput | EtablissementUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: EtablissementUpdateManyWithWhereWithoutAdresseInput | EtablissementUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: EtablissementScalarWhereInput | EtablissementScalarWhereInput[]
  }

  export type UtilisateurUncheckedUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput> | UtilisateurCreateWithoutAdresseInput[] | UtilisateurUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAdresseInput | UtilisateurCreateOrConnectWithoutAdresseInput[]
    upsert?: UtilisateurUpsertWithWhereUniqueWithoutAdresseInput | UtilisateurUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: UtilisateurCreateManyAdresseInputEnvelope
    set?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    disconnect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    delete?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    update?: UtilisateurUpdateWithWhereUniqueWithoutAdresseInput | UtilisateurUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: UtilisateurUpdateManyWithWhereWithoutAdresseInput | UtilisateurUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
  }

  export type EtablissementUncheckedUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<EtablissementCreateWithoutAdresseInput, EtablissementUncheckedCreateWithoutAdresseInput> | EtablissementCreateWithoutAdresseInput[] | EtablissementUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutAdresseInput | EtablissementCreateOrConnectWithoutAdresseInput[]
    upsert?: EtablissementUpsertWithWhereUniqueWithoutAdresseInput | EtablissementUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: EtablissementCreateManyAdresseInputEnvelope
    set?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    disconnect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    delete?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    update?: EtablissementUpdateWithWhereUniqueWithoutAdresseInput | EtablissementUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: EtablissementUpdateManyWithWhereWithoutAdresseInput | EtablissementUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: EtablissementScalarWhereInput | EtablissementScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutReseauxSociauxInput = {
    create?: XOR<ContactCreateWithoutReseauxSociauxInput, ContactUncheckedCreateWithoutReseauxSociauxInput>
    connectOrCreate?: ContactCreateOrConnectWithoutReseauxSociauxInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactUpdateOneWithoutReseauxSociauxNestedInput = {
    create?: XOR<ContactCreateWithoutReseauxSociauxInput, ContactUncheckedCreateWithoutReseauxSociauxInput>
    connectOrCreate?: ContactCreateOrConnectWithoutReseauxSociauxInput
    upsert?: ContactUpsertWithoutReseauxSociauxInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutReseauxSociauxInput, ContactUpdateWithoutReseauxSociauxInput>, ContactUncheckedUpdateWithoutReseauxSociauxInput>
  }

  export type ReseauSocialCreateNestedManyWithoutContactInput = {
    create?: XOR<ReseauSocialCreateWithoutContactInput, ReseauSocialUncheckedCreateWithoutContactInput> | ReseauSocialCreateWithoutContactInput[] | ReseauSocialUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReseauSocialCreateOrConnectWithoutContactInput | ReseauSocialCreateOrConnectWithoutContactInput[]
    createMany?: ReseauSocialCreateManyContactInputEnvelope
    connect?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
  }

  export type UtilisateurCreateNestedManyWithoutContactInput = {
    create?: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput> | UtilisateurCreateWithoutContactInput[] | UtilisateurUncheckedCreateWithoutContactInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutContactInput | UtilisateurCreateOrConnectWithoutContactInput[]
    createMany?: UtilisateurCreateManyContactInputEnvelope
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
  }

  export type EtablissementCreateNestedManyWithoutContactInput = {
    create?: XOR<EtablissementCreateWithoutContactInput, EtablissementUncheckedCreateWithoutContactInput> | EtablissementCreateWithoutContactInput[] | EtablissementUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutContactInput | EtablissementCreateOrConnectWithoutContactInput[]
    createMany?: EtablissementCreateManyContactInputEnvelope
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
  }

  export type ReseauSocialUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ReseauSocialCreateWithoutContactInput, ReseauSocialUncheckedCreateWithoutContactInput> | ReseauSocialCreateWithoutContactInput[] | ReseauSocialUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReseauSocialCreateOrConnectWithoutContactInput | ReseauSocialCreateOrConnectWithoutContactInput[]
    createMany?: ReseauSocialCreateManyContactInputEnvelope
    connect?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
  }

  export type UtilisateurUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput> | UtilisateurCreateWithoutContactInput[] | UtilisateurUncheckedCreateWithoutContactInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutContactInput | UtilisateurCreateOrConnectWithoutContactInput[]
    createMany?: UtilisateurCreateManyContactInputEnvelope
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
  }

  export type EtablissementUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<EtablissementCreateWithoutContactInput, EtablissementUncheckedCreateWithoutContactInput> | EtablissementCreateWithoutContactInput[] | EtablissementUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutContactInput | EtablissementCreateOrConnectWithoutContactInput[]
    createMany?: EtablissementCreateManyContactInputEnvelope
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
  }

  export type ReseauSocialUpdateManyWithoutContactNestedInput = {
    create?: XOR<ReseauSocialCreateWithoutContactInput, ReseauSocialUncheckedCreateWithoutContactInput> | ReseauSocialCreateWithoutContactInput[] | ReseauSocialUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReseauSocialCreateOrConnectWithoutContactInput | ReseauSocialCreateOrConnectWithoutContactInput[]
    upsert?: ReseauSocialUpsertWithWhereUniqueWithoutContactInput | ReseauSocialUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ReseauSocialCreateManyContactInputEnvelope
    set?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
    disconnect?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
    delete?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
    connect?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
    update?: ReseauSocialUpdateWithWhereUniqueWithoutContactInput | ReseauSocialUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ReseauSocialUpdateManyWithWhereWithoutContactInput | ReseauSocialUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ReseauSocialScalarWhereInput | ReseauSocialScalarWhereInput[]
  }

  export type UtilisateurUpdateManyWithoutContactNestedInput = {
    create?: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput> | UtilisateurCreateWithoutContactInput[] | UtilisateurUncheckedCreateWithoutContactInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutContactInput | UtilisateurCreateOrConnectWithoutContactInput[]
    upsert?: UtilisateurUpsertWithWhereUniqueWithoutContactInput | UtilisateurUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: UtilisateurCreateManyContactInputEnvelope
    set?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    disconnect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    delete?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    update?: UtilisateurUpdateWithWhereUniqueWithoutContactInput | UtilisateurUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: UtilisateurUpdateManyWithWhereWithoutContactInput | UtilisateurUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
  }

  export type EtablissementUpdateManyWithoutContactNestedInput = {
    create?: XOR<EtablissementCreateWithoutContactInput, EtablissementUncheckedCreateWithoutContactInput> | EtablissementCreateWithoutContactInput[] | EtablissementUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutContactInput | EtablissementCreateOrConnectWithoutContactInput[]
    upsert?: EtablissementUpsertWithWhereUniqueWithoutContactInput | EtablissementUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EtablissementCreateManyContactInputEnvelope
    set?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    disconnect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    delete?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    update?: EtablissementUpdateWithWhereUniqueWithoutContactInput | EtablissementUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EtablissementUpdateManyWithWhereWithoutContactInput | EtablissementUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EtablissementScalarWhereInput | EtablissementScalarWhereInput[]
  }

  export type ReseauSocialUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ReseauSocialCreateWithoutContactInput, ReseauSocialUncheckedCreateWithoutContactInput> | ReseauSocialCreateWithoutContactInput[] | ReseauSocialUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReseauSocialCreateOrConnectWithoutContactInput | ReseauSocialCreateOrConnectWithoutContactInput[]
    upsert?: ReseauSocialUpsertWithWhereUniqueWithoutContactInput | ReseauSocialUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ReseauSocialCreateManyContactInputEnvelope
    set?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
    disconnect?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
    delete?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
    connect?: ReseauSocialWhereUniqueInput | ReseauSocialWhereUniqueInput[]
    update?: ReseauSocialUpdateWithWhereUniqueWithoutContactInput | ReseauSocialUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ReseauSocialUpdateManyWithWhereWithoutContactInput | ReseauSocialUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ReseauSocialScalarWhereInput | ReseauSocialScalarWhereInput[]
  }

  export type UtilisateurUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput> | UtilisateurCreateWithoutContactInput[] | UtilisateurUncheckedCreateWithoutContactInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutContactInput | UtilisateurCreateOrConnectWithoutContactInput[]
    upsert?: UtilisateurUpsertWithWhereUniqueWithoutContactInput | UtilisateurUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: UtilisateurCreateManyContactInputEnvelope
    set?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    disconnect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    delete?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    update?: UtilisateurUpdateWithWhereUniqueWithoutContactInput | UtilisateurUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: UtilisateurUpdateManyWithWhereWithoutContactInput | UtilisateurUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
  }

  export type EtablissementUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<EtablissementCreateWithoutContactInput, EtablissementUncheckedCreateWithoutContactInput> | EtablissementCreateWithoutContactInput[] | EtablissementUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutContactInput | EtablissementCreateOrConnectWithoutContactInput[]
    upsert?: EtablissementUpsertWithWhereUniqueWithoutContactInput | EtablissementUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EtablissementCreateManyContactInputEnvelope
    set?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    disconnect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    delete?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    update?: EtablissementUpdateWithWhereUniqueWithoutContactInput | EtablissementUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EtablissementUpdateManyWithWhereWithoutContactInput | EtablissementUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EtablissementScalarWhereInput | EtablissementScalarWhereInput[]
  }

  export type UtilisateurCreateNestedOneWithoutEtudiantInput = {
    create?: XOR<UtilisateurCreateWithoutEtudiantInput, UtilisateurUncheckedCreateWithoutEtudiantInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutEtudiantInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type InscriptionCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<InscriptionCreateWithoutEtudiantInput, InscriptionUncheckedCreateWithoutEtudiantInput> | InscriptionCreateWithoutEtudiantInput[] | InscriptionUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutEtudiantInput | InscriptionCreateOrConnectWithoutEtudiantInput[]
    createMany?: InscriptionCreateManyEtudiantInputEnvelope
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
  }

  export type NoteEtudiantCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<NoteEtudiantCreateWithoutEtudiantInput, NoteEtudiantUncheckedCreateWithoutEtudiantInput> | NoteEtudiantCreateWithoutEtudiantInput[] | NoteEtudiantUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: NoteEtudiantCreateOrConnectWithoutEtudiantInput | NoteEtudiantCreateOrConnectWithoutEtudiantInput[]
    createMany?: NoteEtudiantCreateManyEtudiantInputEnvelope
    connect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
  }

  export type FeuillePresenceCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<FeuillePresenceCreateWithoutEtudiantInput, FeuillePresenceUncheckedCreateWithoutEtudiantInput> | FeuillePresenceCreateWithoutEtudiantInput[] | FeuillePresenceUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: FeuillePresenceCreateOrConnectWithoutEtudiantInput | FeuillePresenceCreateOrConnectWithoutEtudiantInput[]
    createMany?: FeuillePresenceCreateManyEtudiantInputEnvelope
    connect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
  }

  export type PaiementCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<PaiementCreateWithoutEtudiantInput, PaiementUncheckedCreateWithoutEtudiantInput> | PaiementCreateWithoutEtudiantInput[] | PaiementUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutEtudiantInput | PaiementCreateOrConnectWithoutEtudiantInput[]
    createMany?: PaiementCreateManyEtudiantInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type InscriptionUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<InscriptionCreateWithoutEtudiantInput, InscriptionUncheckedCreateWithoutEtudiantInput> | InscriptionCreateWithoutEtudiantInput[] | InscriptionUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutEtudiantInput | InscriptionCreateOrConnectWithoutEtudiantInput[]
    createMany?: InscriptionCreateManyEtudiantInputEnvelope
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
  }

  export type NoteEtudiantUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<NoteEtudiantCreateWithoutEtudiantInput, NoteEtudiantUncheckedCreateWithoutEtudiantInput> | NoteEtudiantCreateWithoutEtudiantInput[] | NoteEtudiantUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: NoteEtudiantCreateOrConnectWithoutEtudiantInput | NoteEtudiantCreateOrConnectWithoutEtudiantInput[]
    createMany?: NoteEtudiantCreateManyEtudiantInputEnvelope
    connect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
  }

  export type FeuillePresenceUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<FeuillePresenceCreateWithoutEtudiantInput, FeuillePresenceUncheckedCreateWithoutEtudiantInput> | FeuillePresenceCreateWithoutEtudiantInput[] | FeuillePresenceUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: FeuillePresenceCreateOrConnectWithoutEtudiantInput | FeuillePresenceCreateOrConnectWithoutEtudiantInput[]
    createMany?: FeuillePresenceCreateManyEtudiantInputEnvelope
    connect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<PaiementCreateWithoutEtudiantInput, PaiementUncheckedCreateWithoutEtudiantInput> | PaiementCreateWithoutEtudiantInput[] | PaiementUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutEtudiantInput | PaiementCreateOrConnectWithoutEtudiantInput[]
    createMany?: PaiementCreateManyEtudiantInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type UtilisateurUpdateOneRequiredWithoutEtudiantNestedInput = {
    create?: XOR<UtilisateurCreateWithoutEtudiantInput, UtilisateurUncheckedCreateWithoutEtudiantInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutEtudiantInput
    upsert?: UtilisateurUpsertWithoutEtudiantInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutEtudiantInput, UtilisateurUpdateWithoutEtudiantInput>, UtilisateurUncheckedUpdateWithoutEtudiantInput>
  }

  export type InscriptionUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<InscriptionCreateWithoutEtudiantInput, InscriptionUncheckedCreateWithoutEtudiantInput> | InscriptionCreateWithoutEtudiantInput[] | InscriptionUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutEtudiantInput | InscriptionCreateOrConnectWithoutEtudiantInput[]
    upsert?: InscriptionUpsertWithWhereUniqueWithoutEtudiantInput | InscriptionUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: InscriptionCreateManyEtudiantInputEnvelope
    set?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    disconnect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    delete?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    update?: InscriptionUpdateWithWhereUniqueWithoutEtudiantInput | InscriptionUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: InscriptionUpdateManyWithWhereWithoutEtudiantInput | InscriptionUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: InscriptionScalarWhereInput | InscriptionScalarWhereInput[]
  }

  export type NoteEtudiantUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<NoteEtudiantCreateWithoutEtudiantInput, NoteEtudiantUncheckedCreateWithoutEtudiantInput> | NoteEtudiantCreateWithoutEtudiantInput[] | NoteEtudiantUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: NoteEtudiantCreateOrConnectWithoutEtudiantInput | NoteEtudiantCreateOrConnectWithoutEtudiantInput[]
    upsert?: NoteEtudiantUpsertWithWhereUniqueWithoutEtudiantInput | NoteEtudiantUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: NoteEtudiantCreateManyEtudiantInputEnvelope
    set?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    disconnect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    delete?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    connect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    update?: NoteEtudiantUpdateWithWhereUniqueWithoutEtudiantInput | NoteEtudiantUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: NoteEtudiantUpdateManyWithWhereWithoutEtudiantInput | NoteEtudiantUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: NoteEtudiantScalarWhereInput | NoteEtudiantScalarWhereInput[]
  }

  export type FeuillePresenceUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<FeuillePresenceCreateWithoutEtudiantInput, FeuillePresenceUncheckedCreateWithoutEtudiantInput> | FeuillePresenceCreateWithoutEtudiantInput[] | FeuillePresenceUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: FeuillePresenceCreateOrConnectWithoutEtudiantInput | FeuillePresenceCreateOrConnectWithoutEtudiantInput[]
    upsert?: FeuillePresenceUpsertWithWhereUniqueWithoutEtudiantInput | FeuillePresenceUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: FeuillePresenceCreateManyEtudiantInputEnvelope
    set?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    disconnect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    delete?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    connect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    update?: FeuillePresenceUpdateWithWhereUniqueWithoutEtudiantInput | FeuillePresenceUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: FeuillePresenceUpdateManyWithWhereWithoutEtudiantInput | FeuillePresenceUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: FeuillePresenceScalarWhereInput | FeuillePresenceScalarWhereInput[]
  }

  export type PaiementUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<PaiementCreateWithoutEtudiantInput, PaiementUncheckedCreateWithoutEtudiantInput> | PaiementCreateWithoutEtudiantInput[] | PaiementUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutEtudiantInput | PaiementCreateOrConnectWithoutEtudiantInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutEtudiantInput | PaiementUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: PaiementCreateManyEtudiantInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutEtudiantInput | PaiementUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutEtudiantInput | PaiementUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type InscriptionUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<InscriptionCreateWithoutEtudiantInput, InscriptionUncheckedCreateWithoutEtudiantInput> | InscriptionCreateWithoutEtudiantInput[] | InscriptionUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutEtudiantInput | InscriptionCreateOrConnectWithoutEtudiantInput[]
    upsert?: InscriptionUpsertWithWhereUniqueWithoutEtudiantInput | InscriptionUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: InscriptionCreateManyEtudiantInputEnvelope
    set?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    disconnect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    delete?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    update?: InscriptionUpdateWithWhereUniqueWithoutEtudiantInput | InscriptionUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: InscriptionUpdateManyWithWhereWithoutEtudiantInput | InscriptionUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: InscriptionScalarWhereInput | InscriptionScalarWhereInput[]
  }

  export type NoteEtudiantUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<NoteEtudiantCreateWithoutEtudiantInput, NoteEtudiantUncheckedCreateWithoutEtudiantInput> | NoteEtudiantCreateWithoutEtudiantInput[] | NoteEtudiantUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: NoteEtudiantCreateOrConnectWithoutEtudiantInput | NoteEtudiantCreateOrConnectWithoutEtudiantInput[]
    upsert?: NoteEtudiantUpsertWithWhereUniqueWithoutEtudiantInput | NoteEtudiantUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: NoteEtudiantCreateManyEtudiantInputEnvelope
    set?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    disconnect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    delete?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    connect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    update?: NoteEtudiantUpdateWithWhereUniqueWithoutEtudiantInput | NoteEtudiantUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: NoteEtudiantUpdateManyWithWhereWithoutEtudiantInput | NoteEtudiantUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: NoteEtudiantScalarWhereInput | NoteEtudiantScalarWhereInput[]
  }

  export type FeuillePresenceUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<FeuillePresenceCreateWithoutEtudiantInput, FeuillePresenceUncheckedCreateWithoutEtudiantInput> | FeuillePresenceCreateWithoutEtudiantInput[] | FeuillePresenceUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: FeuillePresenceCreateOrConnectWithoutEtudiantInput | FeuillePresenceCreateOrConnectWithoutEtudiantInput[]
    upsert?: FeuillePresenceUpsertWithWhereUniqueWithoutEtudiantInput | FeuillePresenceUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: FeuillePresenceCreateManyEtudiantInputEnvelope
    set?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    disconnect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    delete?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    connect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    update?: FeuillePresenceUpdateWithWhereUniqueWithoutEtudiantInput | FeuillePresenceUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: FeuillePresenceUpdateManyWithWhereWithoutEtudiantInput | FeuillePresenceUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: FeuillePresenceScalarWhereInput | FeuillePresenceScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<PaiementCreateWithoutEtudiantInput, PaiementUncheckedCreateWithoutEtudiantInput> | PaiementCreateWithoutEtudiantInput[] | PaiementUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutEtudiantInput | PaiementCreateOrConnectWithoutEtudiantInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutEtudiantInput | PaiementUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: PaiementCreateManyEtudiantInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutEtudiantInput | PaiementUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutEtudiantInput | PaiementUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type UtilisateurCreateNestedOneWithoutProfesseurInput = {
    create?: XOR<UtilisateurCreateWithoutProfesseurInput, UtilisateurUncheckedCreateWithoutProfesseurInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutProfesseurInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type CoursCreateNestedManyWithoutProfesseurInput = {
    create?: XOR<CoursCreateWithoutProfesseurInput, CoursUncheckedCreateWithoutProfesseurInput> | CoursCreateWithoutProfesseurInput[] | CoursUncheckedCreateWithoutProfesseurInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutProfesseurInput | CoursCreateOrConnectWithoutProfesseurInput[]
    createMany?: CoursCreateManyProfesseurInputEnvelope
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
  }

  export type EmploiDuTempsCreateNestedManyWithoutProfesseurInput = {
    create?: XOR<EmploiDuTempsCreateWithoutProfesseurInput, EmploiDuTempsUncheckedCreateWithoutProfesseurInput> | EmploiDuTempsCreateWithoutProfesseurInput[] | EmploiDuTempsUncheckedCreateWithoutProfesseurInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutProfesseurInput | EmploiDuTempsCreateOrConnectWithoutProfesseurInput[]
    createMany?: EmploiDuTempsCreateManyProfesseurInputEnvelope
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
  }

  export type CoursUncheckedCreateNestedManyWithoutProfesseurInput = {
    create?: XOR<CoursCreateWithoutProfesseurInput, CoursUncheckedCreateWithoutProfesseurInput> | CoursCreateWithoutProfesseurInput[] | CoursUncheckedCreateWithoutProfesseurInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutProfesseurInput | CoursCreateOrConnectWithoutProfesseurInput[]
    createMany?: CoursCreateManyProfesseurInputEnvelope
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
  }

  export type EmploiDuTempsUncheckedCreateNestedManyWithoutProfesseurInput = {
    create?: XOR<EmploiDuTempsCreateWithoutProfesseurInput, EmploiDuTempsUncheckedCreateWithoutProfesseurInput> | EmploiDuTempsCreateWithoutProfesseurInput[] | EmploiDuTempsUncheckedCreateWithoutProfesseurInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutProfesseurInput | EmploiDuTempsCreateOrConnectWithoutProfesseurInput[]
    createMany?: EmploiDuTempsCreateManyProfesseurInputEnvelope
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
  }

  export type UtilisateurUpdateOneRequiredWithoutProfesseurNestedInput = {
    create?: XOR<UtilisateurCreateWithoutProfesseurInput, UtilisateurUncheckedCreateWithoutProfesseurInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutProfesseurInput
    upsert?: UtilisateurUpsertWithoutProfesseurInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutProfesseurInput, UtilisateurUpdateWithoutProfesseurInput>, UtilisateurUncheckedUpdateWithoutProfesseurInput>
  }

  export type CoursUpdateManyWithoutProfesseurNestedInput = {
    create?: XOR<CoursCreateWithoutProfesseurInput, CoursUncheckedCreateWithoutProfesseurInput> | CoursCreateWithoutProfesseurInput[] | CoursUncheckedCreateWithoutProfesseurInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutProfesseurInput | CoursCreateOrConnectWithoutProfesseurInput[]
    upsert?: CoursUpsertWithWhereUniqueWithoutProfesseurInput | CoursUpsertWithWhereUniqueWithoutProfesseurInput[]
    createMany?: CoursCreateManyProfesseurInputEnvelope
    set?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    disconnect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    delete?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    update?: CoursUpdateWithWhereUniqueWithoutProfesseurInput | CoursUpdateWithWhereUniqueWithoutProfesseurInput[]
    updateMany?: CoursUpdateManyWithWhereWithoutProfesseurInput | CoursUpdateManyWithWhereWithoutProfesseurInput[]
    deleteMany?: CoursScalarWhereInput | CoursScalarWhereInput[]
  }

  export type EmploiDuTempsUpdateManyWithoutProfesseurNestedInput = {
    create?: XOR<EmploiDuTempsCreateWithoutProfesseurInput, EmploiDuTempsUncheckedCreateWithoutProfesseurInput> | EmploiDuTempsCreateWithoutProfesseurInput[] | EmploiDuTempsUncheckedCreateWithoutProfesseurInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutProfesseurInput | EmploiDuTempsCreateOrConnectWithoutProfesseurInput[]
    upsert?: EmploiDuTempsUpsertWithWhereUniqueWithoutProfesseurInput | EmploiDuTempsUpsertWithWhereUniqueWithoutProfesseurInput[]
    createMany?: EmploiDuTempsCreateManyProfesseurInputEnvelope
    set?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    disconnect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    delete?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    update?: EmploiDuTempsUpdateWithWhereUniqueWithoutProfesseurInput | EmploiDuTempsUpdateWithWhereUniqueWithoutProfesseurInput[]
    updateMany?: EmploiDuTempsUpdateManyWithWhereWithoutProfesseurInput | EmploiDuTempsUpdateManyWithWhereWithoutProfesseurInput[]
    deleteMany?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
  }

  export type CoursUncheckedUpdateManyWithoutProfesseurNestedInput = {
    create?: XOR<CoursCreateWithoutProfesseurInput, CoursUncheckedCreateWithoutProfesseurInput> | CoursCreateWithoutProfesseurInput[] | CoursUncheckedCreateWithoutProfesseurInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutProfesseurInput | CoursCreateOrConnectWithoutProfesseurInput[]
    upsert?: CoursUpsertWithWhereUniqueWithoutProfesseurInput | CoursUpsertWithWhereUniqueWithoutProfesseurInput[]
    createMany?: CoursCreateManyProfesseurInputEnvelope
    set?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    disconnect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    delete?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    update?: CoursUpdateWithWhereUniqueWithoutProfesseurInput | CoursUpdateWithWhereUniqueWithoutProfesseurInput[]
    updateMany?: CoursUpdateManyWithWhereWithoutProfesseurInput | CoursUpdateManyWithWhereWithoutProfesseurInput[]
    deleteMany?: CoursScalarWhereInput | CoursScalarWhereInput[]
  }

  export type EmploiDuTempsUncheckedUpdateManyWithoutProfesseurNestedInput = {
    create?: XOR<EmploiDuTempsCreateWithoutProfesseurInput, EmploiDuTempsUncheckedCreateWithoutProfesseurInput> | EmploiDuTempsCreateWithoutProfesseurInput[] | EmploiDuTempsUncheckedCreateWithoutProfesseurInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutProfesseurInput | EmploiDuTempsCreateOrConnectWithoutProfesseurInput[]
    upsert?: EmploiDuTempsUpsertWithWhereUniqueWithoutProfesseurInput | EmploiDuTempsUpsertWithWhereUniqueWithoutProfesseurInput[]
    createMany?: EmploiDuTempsCreateManyProfesseurInputEnvelope
    set?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    disconnect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    delete?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    update?: EmploiDuTempsUpdateWithWhereUniqueWithoutProfesseurInput | EmploiDuTempsUpdateWithWhereUniqueWithoutProfesseurInput[]
    updateMany?: EmploiDuTempsUpdateManyWithWhereWithoutProfesseurInput | EmploiDuTempsUpdateManyWithWhereWithoutProfesseurInput[]
    deleteMany?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
  }

  export type DiplomeCreateNestedOneWithoutInscriptionsInput = {
    create?: XOR<DiplomeCreateWithoutInscriptionsInput, DiplomeUncheckedCreateWithoutInscriptionsInput>
    connectOrCreate?: DiplomeCreateOrConnectWithoutInscriptionsInput
    connect?: DiplomeWhereUniqueInput
  }

  export type EtudiantCreateNestedOneWithoutInscriptionsInput = {
    create?: XOR<EtudiantCreateWithoutInscriptionsInput, EtudiantUncheckedCreateWithoutInscriptionsInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutInscriptionsInput
    connect?: EtudiantWhereUniqueInput
  }

  export type ClasseCreateNestedOneWithoutInscriptionsInput = {
    create?: XOR<ClasseCreateWithoutInscriptionsInput, ClasseUncheckedCreateWithoutInscriptionsInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutInscriptionsInput
    connect?: ClasseWhereUniqueInput
  }

  export type DiplomeUpdateOneRequiredWithoutInscriptionsNestedInput = {
    create?: XOR<DiplomeCreateWithoutInscriptionsInput, DiplomeUncheckedCreateWithoutInscriptionsInput>
    connectOrCreate?: DiplomeCreateOrConnectWithoutInscriptionsInput
    upsert?: DiplomeUpsertWithoutInscriptionsInput
    connect?: DiplomeWhereUniqueInput
    update?: XOR<XOR<DiplomeUpdateToOneWithWhereWithoutInscriptionsInput, DiplomeUpdateWithoutInscriptionsInput>, DiplomeUncheckedUpdateWithoutInscriptionsInput>
  }

  export type EtudiantUpdateOneRequiredWithoutInscriptionsNestedInput = {
    create?: XOR<EtudiantCreateWithoutInscriptionsInput, EtudiantUncheckedCreateWithoutInscriptionsInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutInscriptionsInput
    upsert?: EtudiantUpsertWithoutInscriptionsInput
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutInscriptionsInput, EtudiantUpdateWithoutInscriptionsInput>, EtudiantUncheckedUpdateWithoutInscriptionsInput>
  }

  export type ClasseUpdateOneRequiredWithoutInscriptionsNestedInput = {
    create?: XOR<ClasseCreateWithoutInscriptionsInput, ClasseUncheckedCreateWithoutInscriptionsInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutInscriptionsInput
    upsert?: ClasseUpsertWithoutInscriptionsInput
    connect?: ClasseWhereUniqueInput
    update?: XOR<XOR<ClasseUpdateToOneWithWhereWithoutInscriptionsInput, ClasseUpdateWithoutInscriptionsInput>, ClasseUncheckedUpdateWithoutInscriptionsInput>
  }

  export type EtablissementCreateNestedManyWithoutDomainesInput = {
    create?: XOR<EtablissementCreateWithoutDomainesInput, EtablissementUncheckedCreateWithoutDomainesInput> | EtablissementCreateWithoutDomainesInput[] | EtablissementUncheckedCreateWithoutDomainesInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutDomainesInput | EtablissementCreateOrConnectWithoutDomainesInput[]
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
  }

  export type MentionCreateNestedManyWithoutDomaineInput = {
    create?: XOR<MentionCreateWithoutDomaineInput, MentionUncheckedCreateWithoutDomaineInput> | MentionCreateWithoutDomaineInput[] | MentionUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutDomaineInput | MentionCreateOrConnectWithoutDomaineInput[]
    createMany?: MentionCreateManyDomaineInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type EtablissementUncheckedCreateNestedManyWithoutDomainesInput = {
    create?: XOR<EtablissementCreateWithoutDomainesInput, EtablissementUncheckedCreateWithoutDomainesInput> | EtablissementCreateWithoutDomainesInput[] | EtablissementUncheckedCreateWithoutDomainesInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutDomainesInput | EtablissementCreateOrConnectWithoutDomainesInput[]
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
  }

  export type MentionUncheckedCreateNestedManyWithoutDomaineInput = {
    create?: XOR<MentionCreateWithoutDomaineInput, MentionUncheckedCreateWithoutDomaineInput> | MentionCreateWithoutDomaineInput[] | MentionUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutDomaineInput | MentionCreateOrConnectWithoutDomaineInput[]
    createMany?: MentionCreateManyDomaineInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type EtablissementUpdateManyWithoutDomainesNestedInput = {
    create?: XOR<EtablissementCreateWithoutDomainesInput, EtablissementUncheckedCreateWithoutDomainesInput> | EtablissementCreateWithoutDomainesInput[] | EtablissementUncheckedCreateWithoutDomainesInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutDomainesInput | EtablissementCreateOrConnectWithoutDomainesInput[]
    upsert?: EtablissementUpsertWithWhereUniqueWithoutDomainesInput | EtablissementUpsertWithWhereUniqueWithoutDomainesInput[]
    set?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    disconnect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    delete?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    update?: EtablissementUpdateWithWhereUniqueWithoutDomainesInput | EtablissementUpdateWithWhereUniqueWithoutDomainesInput[]
    updateMany?: EtablissementUpdateManyWithWhereWithoutDomainesInput | EtablissementUpdateManyWithWhereWithoutDomainesInput[]
    deleteMany?: EtablissementScalarWhereInput | EtablissementScalarWhereInput[]
  }

  export type MentionUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<MentionCreateWithoutDomaineInput, MentionUncheckedCreateWithoutDomaineInput> | MentionCreateWithoutDomaineInput[] | MentionUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutDomaineInput | MentionCreateOrConnectWithoutDomaineInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutDomaineInput | MentionUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: MentionCreateManyDomaineInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutDomaineInput | MentionUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutDomaineInput | MentionUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type EtablissementUncheckedUpdateManyWithoutDomainesNestedInput = {
    create?: XOR<EtablissementCreateWithoutDomainesInput, EtablissementUncheckedCreateWithoutDomainesInput> | EtablissementCreateWithoutDomainesInput[] | EtablissementUncheckedCreateWithoutDomainesInput[]
    connectOrCreate?: EtablissementCreateOrConnectWithoutDomainesInput | EtablissementCreateOrConnectWithoutDomainesInput[]
    upsert?: EtablissementUpsertWithWhereUniqueWithoutDomainesInput | EtablissementUpsertWithWhereUniqueWithoutDomainesInput[]
    set?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    disconnect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    delete?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    connect?: EtablissementWhereUniqueInput | EtablissementWhereUniqueInput[]
    update?: EtablissementUpdateWithWhereUniqueWithoutDomainesInput | EtablissementUpdateWithWhereUniqueWithoutDomainesInput[]
    updateMany?: EtablissementUpdateManyWithWhereWithoutDomainesInput | EtablissementUpdateManyWithWhereWithoutDomainesInput[]
    deleteMany?: EtablissementScalarWhereInput | EtablissementScalarWhereInput[]
  }

  export type MentionUncheckedUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<MentionCreateWithoutDomaineInput, MentionUncheckedCreateWithoutDomaineInput> | MentionCreateWithoutDomaineInput[] | MentionUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutDomaineInput | MentionCreateOrConnectWithoutDomaineInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutDomaineInput | MentionUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: MentionCreateManyDomaineInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutDomaineInput | MentionUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutDomaineInput | MentionUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type DomaineCreateNestedOneWithoutMentionsInput = {
    create?: XOR<DomaineCreateWithoutMentionsInput, DomaineUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutMentionsInput
    connect?: DomaineWhereUniqueInput
  }

  export type SpecialiteCreateNestedManyWithoutMentionInput = {
    create?: XOR<SpecialiteCreateWithoutMentionInput, SpecialiteUncheckedCreateWithoutMentionInput> | SpecialiteCreateWithoutMentionInput[] | SpecialiteUncheckedCreateWithoutMentionInput[]
    connectOrCreate?: SpecialiteCreateOrConnectWithoutMentionInput | SpecialiteCreateOrConnectWithoutMentionInput[]
    createMany?: SpecialiteCreateManyMentionInputEnvelope
    connect?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
  }

  export type SpecialiteUncheckedCreateNestedManyWithoutMentionInput = {
    create?: XOR<SpecialiteCreateWithoutMentionInput, SpecialiteUncheckedCreateWithoutMentionInput> | SpecialiteCreateWithoutMentionInput[] | SpecialiteUncheckedCreateWithoutMentionInput[]
    connectOrCreate?: SpecialiteCreateOrConnectWithoutMentionInput | SpecialiteCreateOrConnectWithoutMentionInput[]
    createMany?: SpecialiteCreateManyMentionInputEnvelope
    connect?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
  }

  export type DomaineUpdateOneWithoutMentionsNestedInput = {
    create?: XOR<DomaineCreateWithoutMentionsInput, DomaineUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutMentionsInput
    upsert?: DomaineUpsertWithoutMentionsInput
    disconnect?: DomaineWhereInput | boolean
    delete?: DomaineWhereInput | boolean
    connect?: DomaineWhereUniqueInput
    update?: XOR<XOR<DomaineUpdateToOneWithWhereWithoutMentionsInput, DomaineUpdateWithoutMentionsInput>, DomaineUncheckedUpdateWithoutMentionsInput>
  }

  export type SpecialiteUpdateManyWithoutMentionNestedInput = {
    create?: XOR<SpecialiteCreateWithoutMentionInput, SpecialiteUncheckedCreateWithoutMentionInput> | SpecialiteCreateWithoutMentionInput[] | SpecialiteUncheckedCreateWithoutMentionInput[]
    connectOrCreate?: SpecialiteCreateOrConnectWithoutMentionInput | SpecialiteCreateOrConnectWithoutMentionInput[]
    upsert?: SpecialiteUpsertWithWhereUniqueWithoutMentionInput | SpecialiteUpsertWithWhereUniqueWithoutMentionInput[]
    createMany?: SpecialiteCreateManyMentionInputEnvelope
    set?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
    disconnect?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
    delete?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
    connect?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
    update?: SpecialiteUpdateWithWhereUniqueWithoutMentionInput | SpecialiteUpdateWithWhereUniqueWithoutMentionInput[]
    updateMany?: SpecialiteUpdateManyWithWhereWithoutMentionInput | SpecialiteUpdateManyWithWhereWithoutMentionInput[]
    deleteMany?: SpecialiteScalarWhereInput | SpecialiteScalarWhereInput[]
  }

  export type SpecialiteUncheckedUpdateManyWithoutMentionNestedInput = {
    create?: XOR<SpecialiteCreateWithoutMentionInput, SpecialiteUncheckedCreateWithoutMentionInput> | SpecialiteCreateWithoutMentionInput[] | SpecialiteUncheckedCreateWithoutMentionInput[]
    connectOrCreate?: SpecialiteCreateOrConnectWithoutMentionInput | SpecialiteCreateOrConnectWithoutMentionInput[]
    upsert?: SpecialiteUpsertWithWhereUniqueWithoutMentionInput | SpecialiteUpsertWithWhereUniqueWithoutMentionInput[]
    createMany?: SpecialiteCreateManyMentionInputEnvelope
    set?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
    disconnect?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
    delete?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
    connect?: SpecialiteWhereUniqueInput | SpecialiteWhereUniqueInput[]
    update?: SpecialiteUpdateWithWhereUniqueWithoutMentionInput | SpecialiteUpdateWithWhereUniqueWithoutMentionInput[]
    updateMany?: SpecialiteUpdateManyWithWhereWithoutMentionInput | SpecialiteUpdateManyWithWhereWithoutMentionInput[]
    deleteMany?: SpecialiteScalarWhereInput | SpecialiteScalarWhereInput[]
  }

  export type MentionCreateNestedOneWithoutSpecialitesInput = {
    create?: XOR<MentionCreateWithoutSpecialitesInput, MentionUncheckedCreateWithoutSpecialitesInput>
    connectOrCreate?: MentionCreateOrConnectWithoutSpecialitesInput
    connect?: MentionWhereUniqueInput
  }

  export type ClasseCreateNestedManyWithoutSpecialiteInput = {
    create?: XOR<ClasseCreateWithoutSpecialiteInput, ClasseUncheckedCreateWithoutSpecialiteInput> | ClasseCreateWithoutSpecialiteInput[] | ClasseUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutSpecialiteInput | ClasseCreateOrConnectWithoutSpecialiteInput[]
    createMany?: ClasseCreateManySpecialiteInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type DiplomeCreateNestedManyWithoutSpecialiteInput = {
    create?: XOR<DiplomeCreateWithoutSpecialiteInput, DiplomeUncheckedCreateWithoutSpecialiteInput> | DiplomeCreateWithoutSpecialiteInput[] | DiplomeUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: DiplomeCreateOrConnectWithoutSpecialiteInput | DiplomeCreateOrConnectWithoutSpecialiteInput[]
    createMany?: DiplomeCreateManySpecialiteInputEnvelope
    connect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
  }

  export type ClasseUncheckedCreateNestedManyWithoutSpecialiteInput = {
    create?: XOR<ClasseCreateWithoutSpecialiteInput, ClasseUncheckedCreateWithoutSpecialiteInput> | ClasseCreateWithoutSpecialiteInput[] | ClasseUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutSpecialiteInput | ClasseCreateOrConnectWithoutSpecialiteInput[]
    createMany?: ClasseCreateManySpecialiteInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type DiplomeUncheckedCreateNestedManyWithoutSpecialiteInput = {
    create?: XOR<DiplomeCreateWithoutSpecialiteInput, DiplomeUncheckedCreateWithoutSpecialiteInput> | DiplomeCreateWithoutSpecialiteInput[] | DiplomeUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: DiplomeCreateOrConnectWithoutSpecialiteInput | DiplomeCreateOrConnectWithoutSpecialiteInput[]
    createMany?: DiplomeCreateManySpecialiteInputEnvelope
    connect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
  }

  export type MentionUpdateOneWithoutSpecialitesNestedInput = {
    create?: XOR<MentionCreateWithoutSpecialitesInput, MentionUncheckedCreateWithoutSpecialitesInput>
    connectOrCreate?: MentionCreateOrConnectWithoutSpecialitesInput
    upsert?: MentionUpsertWithoutSpecialitesInput
    disconnect?: MentionWhereInput | boolean
    delete?: MentionWhereInput | boolean
    connect?: MentionWhereUniqueInput
    update?: XOR<XOR<MentionUpdateToOneWithWhereWithoutSpecialitesInput, MentionUpdateWithoutSpecialitesInput>, MentionUncheckedUpdateWithoutSpecialitesInput>
  }

  export type ClasseUpdateManyWithoutSpecialiteNestedInput = {
    create?: XOR<ClasseCreateWithoutSpecialiteInput, ClasseUncheckedCreateWithoutSpecialiteInput> | ClasseCreateWithoutSpecialiteInput[] | ClasseUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutSpecialiteInput | ClasseCreateOrConnectWithoutSpecialiteInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutSpecialiteInput | ClasseUpsertWithWhereUniqueWithoutSpecialiteInput[]
    createMany?: ClasseCreateManySpecialiteInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutSpecialiteInput | ClasseUpdateWithWhereUniqueWithoutSpecialiteInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutSpecialiteInput | ClasseUpdateManyWithWhereWithoutSpecialiteInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type DiplomeUpdateManyWithoutSpecialiteNestedInput = {
    create?: XOR<DiplomeCreateWithoutSpecialiteInput, DiplomeUncheckedCreateWithoutSpecialiteInput> | DiplomeCreateWithoutSpecialiteInput[] | DiplomeUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: DiplomeCreateOrConnectWithoutSpecialiteInput | DiplomeCreateOrConnectWithoutSpecialiteInput[]
    upsert?: DiplomeUpsertWithWhereUniqueWithoutSpecialiteInput | DiplomeUpsertWithWhereUniqueWithoutSpecialiteInput[]
    createMany?: DiplomeCreateManySpecialiteInputEnvelope
    set?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    disconnect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    delete?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    connect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    update?: DiplomeUpdateWithWhereUniqueWithoutSpecialiteInput | DiplomeUpdateWithWhereUniqueWithoutSpecialiteInput[]
    updateMany?: DiplomeUpdateManyWithWhereWithoutSpecialiteInput | DiplomeUpdateManyWithWhereWithoutSpecialiteInput[]
    deleteMany?: DiplomeScalarWhereInput | DiplomeScalarWhereInput[]
  }

  export type ClasseUncheckedUpdateManyWithoutSpecialiteNestedInput = {
    create?: XOR<ClasseCreateWithoutSpecialiteInput, ClasseUncheckedCreateWithoutSpecialiteInput> | ClasseCreateWithoutSpecialiteInput[] | ClasseUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutSpecialiteInput | ClasseCreateOrConnectWithoutSpecialiteInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutSpecialiteInput | ClasseUpsertWithWhereUniqueWithoutSpecialiteInput[]
    createMany?: ClasseCreateManySpecialiteInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutSpecialiteInput | ClasseUpdateWithWhereUniqueWithoutSpecialiteInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutSpecialiteInput | ClasseUpdateManyWithWhereWithoutSpecialiteInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type DiplomeUncheckedUpdateManyWithoutSpecialiteNestedInput = {
    create?: XOR<DiplomeCreateWithoutSpecialiteInput, DiplomeUncheckedCreateWithoutSpecialiteInput> | DiplomeCreateWithoutSpecialiteInput[] | DiplomeUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: DiplomeCreateOrConnectWithoutSpecialiteInput | DiplomeCreateOrConnectWithoutSpecialiteInput[]
    upsert?: DiplomeUpsertWithWhereUniqueWithoutSpecialiteInput | DiplomeUpsertWithWhereUniqueWithoutSpecialiteInput[]
    createMany?: DiplomeCreateManySpecialiteInputEnvelope
    set?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    disconnect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    delete?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    connect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    update?: DiplomeUpdateWithWhereUniqueWithoutSpecialiteInput | DiplomeUpdateWithWhereUniqueWithoutSpecialiteInput[]
    updateMany?: DiplomeUpdateManyWithWhereWithoutSpecialiteInput | DiplomeUpdateManyWithWhereWithoutSpecialiteInput[]
    deleteMany?: DiplomeScalarWhereInput | DiplomeScalarWhereInput[]
  }

  export type DiplomeCreatepartenairesInput = {
    set: string[]
  }

  export type InscriptionCreateNestedManyWithoutDiplomeInput = {
    create?: XOR<InscriptionCreateWithoutDiplomeInput, InscriptionUncheckedCreateWithoutDiplomeInput> | InscriptionCreateWithoutDiplomeInput[] | InscriptionUncheckedCreateWithoutDiplomeInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutDiplomeInput | InscriptionCreateOrConnectWithoutDiplomeInput[]
    createMany?: InscriptionCreateManyDiplomeInputEnvelope
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
  }

  export type SpecialiteCreateNestedOneWithoutDiplomeInput = {
    create?: XOR<SpecialiteCreateWithoutDiplomeInput, SpecialiteUncheckedCreateWithoutDiplomeInput>
    connectOrCreate?: SpecialiteCreateOrConnectWithoutDiplomeInput
    connect?: SpecialiteWhereUniqueInput
  }

  export type InscriptionUncheckedCreateNestedManyWithoutDiplomeInput = {
    create?: XOR<InscriptionCreateWithoutDiplomeInput, InscriptionUncheckedCreateWithoutDiplomeInput> | InscriptionCreateWithoutDiplomeInput[] | InscriptionUncheckedCreateWithoutDiplomeInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutDiplomeInput | InscriptionCreateOrConnectWithoutDiplomeInput[]
    createMany?: InscriptionCreateManyDiplomeInputEnvelope
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
  }

  export type DiplomeUpdatepartenairesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InscriptionUpdateManyWithoutDiplomeNestedInput = {
    create?: XOR<InscriptionCreateWithoutDiplomeInput, InscriptionUncheckedCreateWithoutDiplomeInput> | InscriptionCreateWithoutDiplomeInput[] | InscriptionUncheckedCreateWithoutDiplomeInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutDiplomeInput | InscriptionCreateOrConnectWithoutDiplomeInput[]
    upsert?: InscriptionUpsertWithWhereUniqueWithoutDiplomeInput | InscriptionUpsertWithWhereUniqueWithoutDiplomeInput[]
    createMany?: InscriptionCreateManyDiplomeInputEnvelope
    set?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    disconnect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    delete?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    update?: InscriptionUpdateWithWhereUniqueWithoutDiplomeInput | InscriptionUpdateWithWhereUniqueWithoutDiplomeInput[]
    updateMany?: InscriptionUpdateManyWithWhereWithoutDiplomeInput | InscriptionUpdateManyWithWhereWithoutDiplomeInput[]
    deleteMany?: InscriptionScalarWhereInput | InscriptionScalarWhereInput[]
  }

  export type SpecialiteUpdateOneWithoutDiplomeNestedInput = {
    create?: XOR<SpecialiteCreateWithoutDiplomeInput, SpecialiteUncheckedCreateWithoutDiplomeInput>
    connectOrCreate?: SpecialiteCreateOrConnectWithoutDiplomeInput
    upsert?: SpecialiteUpsertWithoutDiplomeInput
    disconnect?: SpecialiteWhereInput | boolean
    delete?: SpecialiteWhereInput | boolean
    connect?: SpecialiteWhereUniqueInput
    update?: XOR<XOR<SpecialiteUpdateToOneWithWhereWithoutDiplomeInput, SpecialiteUpdateWithoutDiplomeInput>, SpecialiteUncheckedUpdateWithoutDiplomeInput>
  }

  export type InscriptionUncheckedUpdateManyWithoutDiplomeNestedInput = {
    create?: XOR<InscriptionCreateWithoutDiplomeInput, InscriptionUncheckedCreateWithoutDiplomeInput> | InscriptionCreateWithoutDiplomeInput[] | InscriptionUncheckedCreateWithoutDiplomeInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutDiplomeInput | InscriptionCreateOrConnectWithoutDiplomeInput[]
    upsert?: InscriptionUpsertWithWhereUniqueWithoutDiplomeInput | InscriptionUpsertWithWhereUniqueWithoutDiplomeInput[]
    createMany?: InscriptionCreateManyDiplomeInputEnvelope
    set?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    disconnect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    delete?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    update?: InscriptionUpdateWithWhereUniqueWithoutDiplomeInput | InscriptionUpdateWithWhereUniqueWithoutDiplomeInput[]
    updateMany?: InscriptionUpdateManyWithWhereWithoutDiplomeInput | InscriptionUpdateManyWithWhereWithoutDiplomeInput[]
    deleteMany?: InscriptionScalarWhereInput | InscriptionScalarWhereInput[]
  }

  export type UniteEnseignementCreateNestedManyWithoutSemestreInput = {
    create?: XOR<UniteEnseignementCreateWithoutSemestreInput, UniteEnseignementUncheckedCreateWithoutSemestreInput> | UniteEnseignementCreateWithoutSemestreInput[] | UniteEnseignementUncheckedCreateWithoutSemestreInput[]
    connectOrCreate?: UniteEnseignementCreateOrConnectWithoutSemestreInput | UniteEnseignementCreateOrConnectWithoutSemestreInput[]
    createMany?: UniteEnseignementCreateManySemestreInputEnvelope
    connect?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
  }

  export type ClasseCreateNestedOneWithoutSemestresInput = {
    create?: XOR<ClasseCreateWithoutSemestresInput, ClasseUncheckedCreateWithoutSemestresInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutSemestresInput
    connect?: ClasseWhereUniqueInput
  }

  export type UniteEnseignementUncheckedCreateNestedManyWithoutSemestreInput = {
    create?: XOR<UniteEnseignementCreateWithoutSemestreInput, UniteEnseignementUncheckedCreateWithoutSemestreInput> | UniteEnseignementCreateWithoutSemestreInput[] | UniteEnseignementUncheckedCreateWithoutSemestreInput[]
    connectOrCreate?: UniteEnseignementCreateOrConnectWithoutSemestreInput | UniteEnseignementCreateOrConnectWithoutSemestreInput[]
    createMany?: UniteEnseignementCreateManySemestreInputEnvelope
    connect?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
  }

  export type EnumTypeDiplomeFieldUpdateOperationsInput = {
    set?: $Enums.TypeDiplome
  }

  export type UniteEnseignementUpdateManyWithoutSemestreNestedInput = {
    create?: XOR<UniteEnseignementCreateWithoutSemestreInput, UniteEnseignementUncheckedCreateWithoutSemestreInput> | UniteEnseignementCreateWithoutSemestreInput[] | UniteEnseignementUncheckedCreateWithoutSemestreInput[]
    connectOrCreate?: UniteEnseignementCreateOrConnectWithoutSemestreInput | UniteEnseignementCreateOrConnectWithoutSemestreInput[]
    upsert?: UniteEnseignementUpsertWithWhereUniqueWithoutSemestreInput | UniteEnseignementUpsertWithWhereUniqueWithoutSemestreInput[]
    createMany?: UniteEnseignementCreateManySemestreInputEnvelope
    set?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
    disconnect?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
    delete?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
    connect?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
    update?: UniteEnseignementUpdateWithWhereUniqueWithoutSemestreInput | UniteEnseignementUpdateWithWhereUniqueWithoutSemestreInput[]
    updateMany?: UniteEnseignementUpdateManyWithWhereWithoutSemestreInput | UniteEnseignementUpdateManyWithWhereWithoutSemestreInput[]
    deleteMany?: UniteEnseignementScalarWhereInput | UniteEnseignementScalarWhereInput[]
  }

  export type ClasseUpdateOneWithoutSemestresNestedInput = {
    create?: XOR<ClasseCreateWithoutSemestresInput, ClasseUncheckedCreateWithoutSemestresInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutSemestresInput
    upsert?: ClasseUpsertWithoutSemestresInput
    disconnect?: ClasseWhereInput | boolean
    delete?: ClasseWhereInput | boolean
    connect?: ClasseWhereUniqueInput
    update?: XOR<XOR<ClasseUpdateToOneWithWhereWithoutSemestresInput, ClasseUpdateWithoutSemestresInput>, ClasseUncheckedUpdateWithoutSemestresInput>
  }

  export type UniteEnseignementUncheckedUpdateManyWithoutSemestreNestedInput = {
    create?: XOR<UniteEnseignementCreateWithoutSemestreInput, UniteEnseignementUncheckedCreateWithoutSemestreInput> | UniteEnseignementCreateWithoutSemestreInput[] | UniteEnseignementUncheckedCreateWithoutSemestreInput[]
    connectOrCreate?: UniteEnseignementCreateOrConnectWithoutSemestreInput | UniteEnseignementCreateOrConnectWithoutSemestreInput[]
    upsert?: UniteEnseignementUpsertWithWhereUniqueWithoutSemestreInput | UniteEnseignementUpsertWithWhereUniqueWithoutSemestreInput[]
    createMany?: UniteEnseignementCreateManySemestreInputEnvelope
    set?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
    disconnect?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
    delete?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
    connect?: UniteEnseignementWhereUniqueInput | UniteEnseignementWhereUniqueInput[]
    update?: UniteEnseignementUpdateWithWhereUniqueWithoutSemestreInput | UniteEnseignementUpdateWithWhereUniqueWithoutSemestreInput[]
    updateMany?: UniteEnseignementUpdateManyWithWhereWithoutSemestreInput | UniteEnseignementUpdateManyWithWhereWithoutSemestreInput[]
    deleteMany?: UniteEnseignementScalarWhereInput | UniteEnseignementScalarWhereInput[]
  }

  export type SemestreCreateNestedOneWithoutUniteEnseignementInput = {
    create?: XOR<SemestreCreateWithoutUniteEnseignementInput, SemestreUncheckedCreateWithoutUniteEnseignementInput>
    connectOrCreate?: SemestreCreateOrConnectWithoutUniteEnseignementInput
    connect?: SemestreWhereUniqueInput
  }

  export type MatiereCreateNestedManyWithoutUniteEnseignementInput = {
    create?: XOR<MatiereCreateWithoutUniteEnseignementInput, MatiereUncheckedCreateWithoutUniteEnseignementInput> | MatiereCreateWithoutUniteEnseignementInput[] | MatiereUncheckedCreateWithoutUniteEnseignementInput[]
    connectOrCreate?: MatiereCreateOrConnectWithoutUniteEnseignementInput | MatiereCreateOrConnectWithoutUniteEnseignementInput[]
    createMany?: MatiereCreateManyUniteEnseignementInputEnvelope
    connect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
  }

  export type MatiereUncheckedCreateNestedManyWithoutUniteEnseignementInput = {
    create?: XOR<MatiereCreateWithoutUniteEnseignementInput, MatiereUncheckedCreateWithoutUniteEnseignementInput> | MatiereCreateWithoutUniteEnseignementInput[] | MatiereUncheckedCreateWithoutUniteEnseignementInput[]
    connectOrCreate?: MatiereCreateOrConnectWithoutUniteEnseignementInput | MatiereCreateOrConnectWithoutUniteEnseignementInput[]
    createMany?: MatiereCreateManyUniteEnseignementInputEnvelope
    connect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
  }

  export type SemestreUpdateOneWithoutUniteEnseignementNestedInput = {
    create?: XOR<SemestreCreateWithoutUniteEnseignementInput, SemestreUncheckedCreateWithoutUniteEnseignementInput>
    connectOrCreate?: SemestreCreateOrConnectWithoutUniteEnseignementInput
    upsert?: SemestreUpsertWithoutUniteEnseignementInput
    disconnect?: SemestreWhereInput | boolean
    delete?: SemestreWhereInput | boolean
    connect?: SemestreWhereUniqueInput
    update?: XOR<XOR<SemestreUpdateToOneWithWhereWithoutUniteEnseignementInput, SemestreUpdateWithoutUniteEnseignementInput>, SemestreUncheckedUpdateWithoutUniteEnseignementInput>
  }

  export type MatiereUpdateManyWithoutUniteEnseignementNestedInput = {
    create?: XOR<MatiereCreateWithoutUniteEnseignementInput, MatiereUncheckedCreateWithoutUniteEnseignementInput> | MatiereCreateWithoutUniteEnseignementInput[] | MatiereUncheckedCreateWithoutUniteEnseignementInput[]
    connectOrCreate?: MatiereCreateOrConnectWithoutUniteEnseignementInput | MatiereCreateOrConnectWithoutUniteEnseignementInput[]
    upsert?: MatiereUpsertWithWhereUniqueWithoutUniteEnseignementInput | MatiereUpsertWithWhereUniqueWithoutUniteEnseignementInput[]
    createMany?: MatiereCreateManyUniteEnseignementInputEnvelope
    set?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    disconnect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    delete?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    connect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    update?: MatiereUpdateWithWhereUniqueWithoutUniteEnseignementInput | MatiereUpdateWithWhereUniqueWithoutUniteEnseignementInput[]
    updateMany?: MatiereUpdateManyWithWhereWithoutUniteEnseignementInput | MatiereUpdateManyWithWhereWithoutUniteEnseignementInput[]
    deleteMany?: MatiereScalarWhereInput | MatiereScalarWhereInput[]
  }

  export type MatiereUncheckedUpdateManyWithoutUniteEnseignementNestedInput = {
    create?: XOR<MatiereCreateWithoutUniteEnseignementInput, MatiereUncheckedCreateWithoutUniteEnseignementInput> | MatiereCreateWithoutUniteEnseignementInput[] | MatiereUncheckedCreateWithoutUniteEnseignementInput[]
    connectOrCreate?: MatiereCreateOrConnectWithoutUniteEnseignementInput | MatiereCreateOrConnectWithoutUniteEnseignementInput[]
    upsert?: MatiereUpsertWithWhereUniqueWithoutUniteEnseignementInput | MatiereUpsertWithWhereUniqueWithoutUniteEnseignementInput[]
    createMany?: MatiereCreateManyUniteEnseignementInputEnvelope
    set?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    disconnect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    delete?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    connect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    update?: MatiereUpdateWithWhereUniqueWithoutUniteEnseignementInput | MatiereUpdateWithWhereUniqueWithoutUniteEnseignementInput[]
    updateMany?: MatiereUpdateManyWithWhereWithoutUniteEnseignementInput | MatiereUpdateManyWithWhereWithoutUniteEnseignementInput[]
    deleteMany?: MatiereScalarWhereInput | MatiereScalarWhereInput[]
  }

  export type CoursCreateNestedManyWithoutMatiereInput = {
    create?: XOR<CoursCreateWithoutMatiereInput, CoursUncheckedCreateWithoutMatiereInput> | CoursCreateWithoutMatiereInput[] | CoursUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutMatiereInput | CoursCreateOrConnectWithoutMatiereInput[]
    createMany?: CoursCreateManyMatiereInputEnvelope
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
  }

  export type UniteEnseignementCreateNestedOneWithoutMatieresInput = {
    create?: XOR<UniteEnseignementCreateWithoutMatieresInput, UniteEnseignementUncheckedCreateWithoutMatieresInput>
    connectOrCreate?: UniteEnseignementCreateOrConnectWithoutMatieresInput
    connect?: UniteEnseignementWhereUniqueInput
  }

  export type CoursUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<CoursCreateWithoutMatiereInput, CoursUncheckedCreateWithoutMatiereInput> | CoursCreateWithoutMatiereInput[] | CoursUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutMatiereInput | CoursCreateOrConnectWithoutMatiereInput[]
    createMany?: CoursCreateManyMatiereInputEnvelope
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
  }

  export type CoursUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<CoursCreateWithoutMatiereInput, CoursUncheckedCreateWithoutMatiereInput> | CoursCreateWithoutMatiereInput[] | CoursUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutMatiereInput | CoursCreateOrConnectWithoutMatiereInput[]
    upsert?: CoursUpsertWithWhereUniqueWithoutMatiereInput | CoursUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: CoursCreateManyMatiereInputEnvelope
    set?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    disconnect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    delete?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    update?: CoursUpdateWithWhereUniqueWithoutMatiereInput | CoursUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: CoursUpdateManyWithWhereWithoutMatiereInput | CoursUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: CoursScalarWhereInput | CoursScalarWhereInput[]
  }

  export type UniteEnseignementUpdateOneRequiredWithoutMatieresNestedInput = {
    create?: XOR<UniteEnseignementCreateWithoutMatieresInput, UniteEnseignementUncheckedCreateWithoutMatieresInput>
    connectOrCreate?: UniteEnseignementCreateOrConnectWithoutMatieresInput
    upsert?: UniteEnseignementUpsertWithoutMatieresInput
    connect?: UniteEnseignementWhereUniqueInput
    update?: XOR<XOR<UniteEnseignementUpdateToOneWithWhereWithoutMatieresInput, UniteEnseignementUpdateWithoutMatieresInput>, UniteEnseignementUncheckedUpdateWithoutMatieresInput>
  }

  export type CoursUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<CoursCreateWithoutMatiereInput, CoursUncheckedCreateWithoutMatiereInput> | CoursCreateWithoutMatiereInput[] | CoursUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutMatiereInput | CoursCreateOrConnectWithoutMatiereInput[]
    upsert?: CoursUpsertWithWhereUniqueWithoutMatiereInput | CoursUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: CoursCreateManyMatiereInputEnvelope
    set?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    disconnect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    delete?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    update?: CoursUpdateWithWhereUniqueWithoutMatiereInput | CoursUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: CoursUpdateManyWithWhereWithoutMatiereInput | CoursUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: CoursScalarWhereInput | CoursScalarWhereInput[]
  }

  export type AdresseCreateNestedOneWithoutEtablissementsInput = {
    create?: XOR<AdresseCreateWithoutEtablissementsInput, AdresseUncheckedCreateWithoutEtablissementsInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutEtablissementsInput
    connect?: AdresseWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutEtablissementsInput = {
    create?: XOR<ContactCreateWithoutEtablissementsInput, ContactUncheckedCreateWithoutEtablissementsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEtablissementsInput
    connect?: ContactWhereUniqueInput
  }

  export type UtilisateurCreateNestedManyWithoutEtablissementInput = {
    create?: XOR<UtilisateurCreateWithoutEtablissementInput, UtilisateurUncheckedCreateWithoutEtablissementInput> | UtilisateurCreateWithoutEtablissementInput[] | UtilisateurUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutEtablissementInput | UtilisateurCreateOrConnectWithoutEtablissementInput[]
    createMany?: UtilisateurCreateManyEtablissementInputEnvelope
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
  }

  export type DomaineCreateNestedManyWithoutEtablissementsInput = {
    create?: XOR<DomaineCreateWithoutEtablissementsInput, DomaineUncheckedCreateWithoutEtablissementsInput> | DomaineCreateWithoutEtablissementsInput[] | DomaineUncheckedCreateWithoutEtablissementsInput[]
    connectOrCreate?: DomaineCreateOrConnectWithoutEtablissementsInput | DomaineCreateOrConnectWithoutEtablissementsInput[]
    connect?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
  }

  export type ClasseCreateNestedManyWithoutEtablissementInput = {
    create?: XOR<ClasseCreateWithoutEtablissementInput, ClasseUncheckedCreateWithoutEtablissementInput> | ClasseCreateWithoutEtablissementInput[] | ClasseUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutEtablissementInput | ClasseCreateOrConnectWithoutEtablissementInput[]
    createMany?: ClasseCreateManyEtablissementInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type SalleCreateNestedManyWithoutEtablissementInput = {
    create?: XOR<SalleCreateWithoutEtablissementInput, SalleUncheckedCreateWithoutEtablissementInput> | SalleCreateWithoutEtablissementInput[] | SalleUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: SalleCreateOrConnectWithoutEtablissementInput | SalleCreateOrConnectWithoutEtablissementInput[]
    createMany?: SalleCreateManyEtablissementInputEnvelope
    connect?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
  }

  export type UtilisateurUncheckedCreateNestedManyWithoutEtablissementInput = {
    create?: XOR<UtilisateurCreateWithoutEtablissementInput, UtilisateurUncheckedCreateWithoutEtablissementInput> | UtilisateurCreateWithoutEtablissementInput[] | UtilisateurUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutEtablissementInput | UtilisateurCreateOrConnectWithoutEtablissementInput[]
    createMany?: UtilisateurCreateManyEtablissementInputEnvelope
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
  }

  export type DomaineUncheckedCreateNestedManyWithoutEtablissementsInput = {
    create?: XOR<DomaineCreateWithoutEtablissementsInput, DomaineUncheckedCreateWithoutEtablissementsInput> | DomaineCreateWithoutEtablissementsInput[] | DomaineUncheckedCreateWithoutEtablissementsInput[]
    connectOrCreate?: DomaineCreateOrConnectWithoutEtablissementsInput | DomaineCreateOrConnectWithoutEtablissementsInput[]
    connect?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
  }

  export type ClasseUncheckedCreateNestedManyWithoutEtablissementInput = {
    create?: XOR<ClasseCreateWithoutEtablissementInput, ClasseUncheckedCreateWithoutEtablissementInput> | ClasseCreateWithoutEtablissementInput[] | ClasseUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutEtablissementInput | ClasseCreateOrConnectWithoutEtablissementInput[]
    createMany?: ClasseCreateManyEtablissementInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type SalleUncheckedCreateNestedManyWithoutEtablissementInput = {
    create?: XOR<SalleCreateWithoutEtablissementInput, SalleUncheckedCreateWithoutEtablissementInput> | SalleCreateWithoutEtablissementInput[] | SalleUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: SalleCreateOrConnectWithoutEtablissementInput | SalleCreateOrConnectWithoutEtablissementInput[]
    createMany?: SalleCreateManyEtablissementInputEnvelope
    connect?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
  }

  export type AdresseUpdateOneWithoutEtablissementsNestedInput = {
    create?: XOR<AdresseCreateWithoutEtablissementsInput, AdresseUncheckedCreateWithoutEtablissementsInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutEtablissementsInput
    upsert?: AdresseUpsertWithoutEtablissementsInput
    disconnect?: AdresseWhereInput | boolean
    delete?: AdresseWhereInput | boolean
    connect?: AdresseWhereUniqueInput
    update?: XOR<XOR<AdresseUpdateToOneWithWhereWithoutEtablissementsInput, AdresseUpdateWithoutEtablissementsInput>, AdresseUncheckedUpdateWithoutEtablissementsInput>
  }

  export type ContactUpdateOneWithoutEtablissementsNestedInput = {
    create?: XOR<ContactCreateWithoutEtablissementsInput, ContactUncheckedCreateWithoutEtablissementsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEtablissementsInput
    upsert?: ContactUpsertWithoutEtablissementsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutEtablissementsInput, ContactUpdateWithoutEtablissementsInput>, ContactUncheckedUpdateWithoutEtablissementsInput>
  }

  export type UtilisateurUpdateManyWithoutEtablissementNestedInput = {
    create?: XOR<UtilisateurCreateWithoutEtablissementInput, UtilisateurUncheckedCreateWithoutEtablissementInput> | UtilisateurCreateWithoutEtablissementInput[] | UtilisateurUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutEtablissementInput | UtilisateurCreateOrConnectWithoutEtablissementInput[]
    upsert?: UtilisateurUpsertWithWhereUniqueWithoutEtablissementInput | UtilisateurUpsertWithWhereUniqueWithoutEtablissementInput[]
    createMany?: UtilisateurCreateManyEtablissementInputEnvelope
    set?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    disconnect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    delete?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    update?: UtilisateurUpdateWithWhereUniqueWithoutEtablissementInput | UtilisateurUpdateWithWhereUniqueWithoutEtablissementInput[]
    updateMany?: UtilisateurUpdateManyWithWhereWithoutEtablissementInput | UtilisateurUpdateManyWithWhereWithoutEtablissementInput[]
    deleteMany?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
  }

  export type DomaineUpdateManyWithoutEtablissementsNestedInput = {
    create?: XOR<DomaineCreateWithoutEtablissementsInput, DomaineUncheckedCreateWithoutEtablissementsInput> | DomaineCreateWithoutEtablissementsInput[] | DomaineUncheckedCreateWithoutEtablissementsInput[]
    connectOrCreate?: DomaineCreateOrConnectWithoutEtablissementsInput | DomaineCreateOrConnectWithoutEtablissementsInput[]
    upsert?: DomaineUpsertWithWhereUniqueWithoutEtablissementsInput | DomaineUpsertWithWhereUniqueWithoutEtablissementsInput[]
    set?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
    disconnect?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
    delete?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
    connect?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
    update?: DomaineUpdateWithWhereUniqueWithoutEtablissementsInput | DomaineUpdateWithWhereUniqueWithoutEtablissementsInput[]
    updateMany?: DomaineUpdateManyWithWhereWithoutEtablissementsInput | DomaineUpdateManyWithWhereWithoutEtablissementsInput[]
    deleteMany?: DomaineScalarWhereInput | DomaineScalarWhereInput[]
  }

  export type ClasseUpdateManyWithoutEtablissementNestedInput = {
    create?: XOR<ClasseCreateWithoutEtablissementInput, ClasseUncheckedCreateWithoutEtablissementInput> | ClasseCreateWithoutEtablissementInput[] | ClasseUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutEtablissementInput | ClasseCreateOrConnectWithoutEtablissementInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutEtablissementInput | ClasseUpsertWithWhereUniqueWithoutEtablissementInput[]
    createMany?: ClasseCreateManyEtablissementInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutEtablissementInput | ClasseUpdateWithWhereUniqueWithoutEtablissementInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutEtablissementInput | ClasseUpdateManyWithWhereWithoutEtablissementInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type SalleUpdateManyWithoutEtablissementNestedInput = {
    create?: XOR<SalleCreateWithoutEtablissementInput, SalleUncheckedCreateWithoutEtablissementInput> | SalleCreateWithoutEtablissementInput[] | SalleUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: SalleCreateOrConnectWithoutEtablissementInput | SalleCreateOrConnectWithoutEtablissementInput[]
    upsert?: SalleUpsertWithWhereUniqueWithoutEtablissementInput | SalleUpsertWithWhereUniqueWithoutEtablissementInput[]
    createMany?: SalleCreateManyEtablissementInputEnvelope
    set?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
    disconnect?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
    delete?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
    connect?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
    update?: SalleUpdateWithWhereUniqueWithoutEtablissementInput | SalleUpdateWithWhereUniqueWithoutEtablissementInput[]
    updateMany?: SalleUpdateManyWithWhereWithoutEtablissementInput | SalleUpdateManyWithWhereWithoutEtablissementInput[]
    deleteMany?: SalleScalarWhereInput | SalleScalarWhereInput[]
  }

  export type UtilisateurUncheckedUpdateManyWithoutEtablissementNestedInput = {
    create?: XOR<UtilisateurCreateWithoutEtablissementInput, UtilisateurUncheckedCreateWithoutEtablissementInput> | UtilisateurCreateWithoutEtablissementInput[] | UtilisateurUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: UtilisateurCreateOrConnectWithoutEtablissementInput | UtilisateurCreateOrConnectWithoutEtablissementInput[]
    upsert?: UtilisateurUpsertWithWhereUniqueWithoutEtablissementInput | UtilisateurUpsertWithWhereUniqueWithoutEtablissementInput[]
    createMany?: UtilisateurCreateManyEtablissementInputEnvelope
    set?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    disconnect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    delete?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    connect?: UtilisateurWhereUniqueInput | UtilisateurWhereUniqueInput[]
    update?: UtilisateurUpdateWithWhereUniqueWithoutEtablissementInput | UtilisateurUpdateWithWhereUniqueWithoutEtablissementInput[]
    updateMany?: UtilisateurUpdateManyWithWhereWithoutEtablissementInput | UtilisateurUpdateManyWithWhereWithoutEtablissementInput[]
    deleteMany?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
  }

  export type DomaineUncheckedUpdateManyWithoutEtablissementsNestedInput = {
    create?: XOR<DomaineCreateWithoutEtablissementsInput, DomaineUncheckedCreateWithoutEtablissementsInput> | DomaineCreateWithoutEtablissementsInput[] | DomaineUncheckedCreateWithoutEtablissementsInput[]
    connectOrCreate?: DomaineCreateOrConnectWithoutEtablissementsInput | DomaineCreateOrConnectWithoutEtablissementsInput[]
    upsert?: DomaineUpsertWithWhereUniqueWithoutEtablissementsInput | DomaineUpsertWithWhereUniqueWithoutEtablissementsInput[]
    set?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
    disconnect?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
    delete?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
    connect?: DomaineWhereUniqueInput | DomaineWhereUniqueInput[]
    update?: DomaineUpdateWithWhereUniqueWithoutEtablissementsInput | DomaineUpdateWithWhereUniqueWithoutEtablissementsInput[]
    updateMany?: DomaineUpdateManyWithWhereWithoutEtablissementsInput | DomaineUpdateManyWithWhereWithoutEtablissementsInput[]
    deleteMany?: DomaineScalarWhereInput | DomaineScalarWhereInput[]
  }

  export type ClasseUncheckedUpdateManyWithoutEtablissementNestedInput = {
    create?: XOR<ClasseCreateWithoutEtablissementInput, ClasseUncheckedCreateWithoutEtablissementInput> | ClasseCreateWithoutEtablissementInput[] | ClasseUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutEtablissementInput | ClasseCreateOrConnectWithoutEtablissementInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutEtablissementInput | ClasseUpsertWithWhereUniqueWithoutEtablissementInput[]
    createMany?: ClasseCreateManyEtablissementInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutEtablissementInput | ClasseUpdateWithWhereUniqueWithoutEtablissementInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutEtablissementInput | ClasseUpdateManyWithWhereWithoutEtablissementInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type SalleUncheckedUpdateManyWithoutEtablissementNestedInput = {
    create?: XOR<SalleCreateWithoutEtablissementInput, SalleUncheckedCreateWithoutEtablissementInput> | SalleCreateWithoutEtablissementInput[] | SalleUncheckedCreateWithoutEtablissementInput[]
    connectOrCreate?: SalleCreateOrConnectWithoutEtablissementInput | SalleCreateOrConnectWithoutEtablissementInput[]
    upsert?: SalleUpsertWithWhereUniqueWithoutEtablissementInput | SalleUpsertWithWhereUniqueWithoutEtablissementInput[]
    createMany?: SalleCreateManyEtablissementInputEnvelope
    set?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
    disconnect?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
    delete?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
    connect?: SalleWhereUniqueInput | SalleWhereUniqueInput[]
    update?: SalleUpdateWithWhereUniqueWithoutEtablissementInput | SalleUpdateWithWhereUniqueWithoutEtablissementInput[]
    updateMany?: SalleUpdateManyWithWhereWithoutEtablissementInput | SalleUpdateManyWithWhereWithoutEtablissementInput[]
    deleteMany?: SalleScalarWhereInput | SalleScalarWhereInput[]
  }

  export type EtablissementCreateNestedOneWithoutClassesInput = {
    create?: XOR<EtablissementCreateWithoutClassesInput, EtablissementUncheckedCreateWithoutClassesInput>
    connectOrCreate?: EtablissementCreateOrConnectWithoutClassesInput
    connect?: EtablissementWhereUniqueInput
  }

  export type SemestreCreateNestedManyWithoutClasseInput = {
    create?: XOR<SemestreCreateWithoutClasseInput, SemestreUncheckedCreateWithoutClasseInput> | SemestreCreateWithoutClasseInput[] | SemestreUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: SemestreCreateOrConnectWithoutClasseInput | SemestreCreateOrConnectWithoutClasseInput[]
    createMany?: SemestreCreateManyClasseInputEnvelope
    connect?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
  }

  export type InscriptionCreateNestedManyWithoutClasseInput = {
    create?: XOR<InscriptionCreateWithoutClasseInput, InscriptionUncheckedCreateWithoutClasseInput> | InscriptionCreateWithoutClasseInput[] | InscriptionUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutClasseInput | InscriptionCreateOrConnectWithoutClasseInput[]
    createMany?: InscriptionCreateManyClasseInputEnvelope
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
  }

  export type SpecialiteCreateNestedOneWithoutClasseInput = {
    create?: XOR<SpecialiteCreateWithoutClasseInput, SpecialiteUncheckedCreateWithoutClasseInput>
    connectOrCreate?: SpecialiteCreateOrConnectWithoutClasseInput
    connect?: SpecialiteWhereUniqueInput
  }

  export type CoursCreateNestedManyWithoutClasseInput = {
    create?: XOR<CoursCreateWithoutClasseInput, CoursUncheckedCreateWithoutClasseInput> | CoursCreateWithoutClasseInput[] | CoursUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutClasseInput | CoursCreateOrConnectWithoutClasseInput[]
    createMany?: CoursCreateManyClasseInputEnvelope
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
  }

  export type EmploiDuTempsCreateNestedManyWithoutClasseInput = {
    create?: XOR<EmploiDuTempsCreateWithoutClasseInput, EmploiDuTempsUncheckedCreateWithoutClasseInput> | EmploiDuTempsCreateWithoutClasseInput[] | EmploiDuTempsUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutClasseInput | EmploiDuTempsCreateOrConnectWithoutClasseInput[]
    createMany?: EmploiDuTempsCreateManyClasseInputEnvelope
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
  }

  export type AnneeScolaireCreateNestedOneWithoutClassesInput = {
    create?: XOR<AnneeScolaireCreateWithoutClassesInput, AnneeScolaireUncheckedCreateWithoutClassesInput>
    connectOrCreate?: AnneeScolaireCreateOrConnectWithoutClassesInput
    connect?: AnneeScolaireWhereUniqueInput
  }

  export type SemestreUncheckedCreateNestedManyWithoutClasseInput = {
    create?: XOR<SemestreCreateWithoutClasseInput, SemestreUncheckedCreateWithoutClasseInput> | SemestreCreateWithoutClasseInput[] | SemestreUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: SemestreCreateOrConnectWithoutClasseInput | SemestreCreateOrConnectWithoutClasseInput[]
    createMany?: SemestreCreateManyClasseInputEnvelope
    connect?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
  }

  export type InscriptionUncheckedCreateNestedManyWithoutClasseInput = {
    create?: XOR<InscriptionCreateWithoutClasseInput, InscriptionUncheckedCreateWithoutClasseInput> | InscriptionCreateWithoutClasseInput[] | InscriptionUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutClasseInput | InscriptionCreateOrConnectWithoutClasseInput[]
    createMany?: InscriptionCreateManyClasseInputEnvelope
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
  }

  export type CoursUncheckedCreateNestedManyWithoutClasseInput = {
    create?: XOR<CoursCreateWithoutClasseInput, CoursUncheckedCreateWithoutClasseInput> | CoursCreateWithoutClasseInput[] | CoursUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutClasseInput | CoursCreateOrConnectWithoutClasseInput[]
    createMany?: CoursCreateManyClasseInputEnvelope
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
  }

  export type EmploiDuTempsUncheckedCreateNestedManyWithoutClasseInput = {
    create?: XOR<EmploiDuTempsCreateWithoutClasseInput, EmploiDuTempsUncheckedCreateWithoutClasseInput> | EmploiDuTempsCreateWithoutClasseInput[] | EmploiDuTempsUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutClasseInput | EmploiDuTempsCreateOrConnectWithoutClasseInput[]
    createMany?: EmploiDuTempsCreateManyClasseInputEnvelope
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
  }

  export type EtablissementUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<EtablissementCreateWithoutClassesInput, EtablissementUncheckedCreateWithoutClassesInput>
    connectOrCreate?: EtablissementCreateOrConnectWithoutClassesInput
    upsert?: EtablissementUpsertWithoutClassesInput
    connect?: EtablissementWhereUniqueInput
    update?: XOR<XOR<EtablissementUpdateToOneWithWhereWithoutClassesInput, EtablissementUpdateWithoutClassesInput>, EtablissementUncheckedUpdateWithoutClassesInput>
  }

  export type SemestreUpdateManyWithoutClasseNestedInput = {
    create?: XOR<SemestreCreateWithoutClasseInput, SemestreUncheckedCreateWithoutClasseInput> | SemestreCreateWithoutClasseInput[] | SemestreUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: SemestreCreateOrConnectWithoutClasseInput | SemestreCreateOrConnectWithoutClasseInput[]
    upsert?: SemestreUpsertWithWhereUniqueWithoutClasseInput | SemestreUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: SemestreCreateManyClasseInputEnvelope
    set?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
    disconnect?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
    delete?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
    connect?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
    update?: SemestreUpdateWithWhereUniqueWithoutClasseInput | SemestreUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: SemestreUpdateManyWithWhereWithoutClasseInput | SemestreUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: SemestreScalarWhereInput | SemestreScalarWhereInput[]
  }

  export type InscriptionUpdateManyWithoutClasseNestedInput = {
    create?: XOR<InscriptionCreateWithoutClasseInput, InscriptionUncheckedCreateWithoutClasseInput> | InscriptionCreateWithoutClasseInput[] | InscriptionUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutClasseInput | InscriptionCreateOrConnectWithoutClasseInput[]
    upsert?: InscriptionUpsertWithWhereUniqueWithoutClasseInput | InscriptionUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: InscriptionCreateManyClasseInputEnvelope
    set?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    disconnect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    delete?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    update?: InscriptionUpdateWithWhereUniqueWithoutClasseInput | InscriptionUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: InscriptionUpdateManyWithWhereWithoutClasseInput | InscriptionUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: InscriptionScalarWhereInput | InscriptionScalarWhereInput[]
  }

  export type SpecialiteUpdateOneRequiredWithoutClasseNestedInput = {
    create?: XOR<SpecialiteCreateWithoutClasseInput, SpecialiteUncheckedCreateWithoutClasseInput>
    connectOrCreate?: SpecialiteCreateOrConnectWithoutClasseInput
    upsert?: SpecialiteUpsertWithoutClasseInput
    connect?: SpecialiteWhereUniqueInput
    update?: XOR<XOR<SpecialiteUpdateToOneWithWhereWithoutClasseInput, SpecialiteUpdateWithoutClasseInput>, SpecialiteUncheckedUpdateWithoutClasseInput>
  }

  export type CoursUpdateManyWithoutClasseNestedInput = {
    create?: XOR<CoursCreateWithoutClasseInput, CoursUncheckedCreateWithoutClasseInput> | CoursCreateWithoutClasseInput[] | CoursUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutClasseInput | CoursCreateOrConnectWithoutClasseInput[]
    upsert?: CoursUpsertWithWhereUniqueWithoutClasseInput | CoursUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: CoursCreateManyClasseInputEnvelope
    set?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    disconnect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    delete?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    update?: CoursUpdateWithWhereUniqueWithoutClasseInput | CoursUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: CoursUpdateManyWithWhereWithoutClasseInput | CoursUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: CoursScalarWhereInput | CoursScalarWhereInput[]
  }

  export type EmploiDuTempsUpdateManyWithoutClasseNestedInput = {
    create?: XOR<EmploiDuTempsCreateWithoutClasseInput, EmploiDuTempsUncheckedCreateWithoutClasseInput> | EmploiDuTempsCreateWithoutClasseInput[] | EmploiDuTempsUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutClasseInput | EmploiDuTempsCreateOrConnectWithoutClasseInput[]
    upsert?: EmploiDuTempsUpsertWithWhereUniqueWithoutClasseInput | EmploiDuTempsUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: EmploiDuTempsCreateManyClasseInputEnvelope
    set?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    disconnect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    delete?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    update?: EmploiDuTempsUpdateWithWhereUniqueWithoutClasseInput | EmploiDuTempsUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: EmploiDuTempsUpdateManyWithWhereWithoutClasseInput | EmploiDuTempsUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
  }

  export type AnneeScolaireUpdateOneWithoutClassesNestedInput = {
    create?: XOR<AnneeScolaireCreateWithoutClassesInput, AnneeScolaireUncheckedCreateWithoutClassesInput>
    connectOrCreate?: AnneeScolaireCreateOrConnectWithoutClassesInput
    upsert?: AnneeScolaireUpsertWithoutClassesInput
    disconnect?: AnneeScolaireWhereInput | boolean
    delete?: AnneeScolaireWhereInput | boolean
    connect?: AnneeScolaireWhereUniqueInput
    update?: XOR<XOR<AnneeScolaireUpdateToOneWithWhereWithoutClassesInput, AnneeScolaireUpdateWithoutClassesInput>, AnneeScolaireUncheckedUpdateWithoutClassesInput>
  }

  export type SemestreUncheckedUpdateManyWithoutClasseNestedInput = {
    create?: XOR<SemestreCreateWithoutClasseInput, SemestreUncheckedCreateWithoutClasseInput> | SemestreCreateWithoutClasseInput[] | SemestreUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: SemestreCreateOrConnectWithoutClasseInput | SemestreCreateOrConnectWithoutClasseInput[]
    upsert?: SemestreUpsertWithWhereUniqueWithoutClasseInput | SemestreUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: SemestreCreateManyClasseInputEnvelope
    set?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
    disconnect?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
    delete?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
    connect?: SemestreWhereUniqueInput | SemestreWhereUniqueInput[]
    update?: SemestreUpdateWithWhereUniqueWithoutClasseInput | SemestreUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: SemestreUpdateManyWithWhereWithoutClasseInput | SemestreUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: SemestreScalarWhereInput | SemestreScalarWhereInput[]
  }

  export type InscriptionUncheckedUpdateManyWithoutClasseNestedInput = {
    create?: XOR<InscriptionCreateWithoutClasseInput, InscriptionUncheckedCreateWithoutClasseInput> | InscriptionCreateWithoutClasseInput[] | InscriptionUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: InscriptionCreateOrConnectWithoutClasseInput | InscriptionCreateOrConnectWithoutClasseInput[]
    upsert?: InscriptionUpsertWithWhereUniqueWithoutClasseInput | InscriptionUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: InscriptionCreateManyClasseInputEnvelope
    set?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    disconnect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    delete?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    connect?: InscriptionWhereUniqueInput | InscriptionWhereUniqueInput[]
    update?: InscriptionUpdateWithWhereUniqueWithoutClasseInput | InscriptionUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: InscriptionUpdateManyWithWhereWithoutClasseInput | InscriptionUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: InscriptionScalarWhereInput | InscriptionScalarWhereInput[]
  }

  export type CoursUncheckedUpdateManyWithoutClasseNestedInput = {
    create?: XOR<CoursCreateWithoutClasseInput, CoursUncheckedCreateWithoutClasseInput> | CoursCreateWithoutClasseInput[] | CoursUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutClasseInput | CoursCreateOrConnectWithoutClasseInput[]
    upsert?: CoursUpsertWithWhereUniqueWithoutClasseInput | CoursUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: CoursCreateManyClasseInputEnvelope
    set?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    disconnect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    delete?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    update?: CoursUpdateWithWhereUniqueWithoutClasseInput | CoursUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: CoursUpdateManyWithWhereWithoutClasseInput | CoursUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: CoursScalarWhereInput | CoursScalarWhereInput[]
  }

  export type EmploiDuTempsUncheckedUpdateManyWithoutClasseNestedInput = {
    create?: XOR<EmploiDuTempsCreateWithoutClasseInput, EmploiDuTempsUncheckedCreateWithoutClasseInput> | EmploiDuTempsCreateWithoutClasseInput[] | EmploiDuTempsUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutClasseInput | EmploiDuTempsCreateOrConnectWithoutClasseInput[]
    upsert?: EmploiDuTempsUpsertWithWhereUniqueWithoutClasseInput | EmploiDuTempsUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: EmploiDuTempsCreateManyClasseInputEnvelope
    set?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    disconnect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    delete?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    update?: EmploiDuTempsUpdateWithWhereUniqueWithoutClasseInput | EmploiDuTempsUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: EmploiDuTempsUpdateManyWithWhereWithoutClasseInput | EmploiDuTempsUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
  }

  export type ClasseCreateNestedManyWithoutAnneeScolaireInput = {
    create?: XOR<ClasseCreateWithoutAnneeScolaireInput, ClasseUncheckedCreateWithoutAnneeScolaireInput> | ClasseCreateWithoutAnneeScolaireInput[] | ClasseUncheckedCreateWithoutAnneeScolaireInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutAnneeScolaireInput | ClasseCreateOrConnectWithoutAnneeScolaireInput[]
    createMany?: ClasseCreateManyAnneeScolaireInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type ClasseUncheckedCreateNestedManyWithoutAnneeScolaireInput = {
    create?: XOR<ClasseCreateWithoutAnneeScolaireInput, ClasseUncheckedCreateWithoutAnneeScolaireInput> | ClasseCreateWithoutAnneeScolaireInput[] | ClasseUncheckedCreateWithoutAnneeScolaireInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutAnneeScolaireInput | ClasseCreateOrConnectWithoutAnneeScolaireInput[]
    createMany?: ClasseCreateManyAnneeScolaireInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type ClasseUpdateManyWithoutAnneeScolaireNestedInput = {
    create?: XOR<ClasseCreateWithoutAnneeScolaireInput, ClasseUncheckedCreateWithoutAnneeScolaireInput> | ClasseCreateWithoutAnneeScolaireInput[] | ClasseUncheckedCreateWithoutAnneeScolaireInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutAnneeScolaireInput | ClasseCreateOrConnectWithoutAnneeScolaireInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutAnneeScolaireInput | ClasseUpsertWithWhereUniqueWithoutAnneeScolaireInput[]
    createMany?: ClasseCreateManyAnneeScolaireInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutAnneeScolaireInput | ClasseUpdateWithWhereUniqueWithoutAnneeScolaireInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutAnneeScolaireInput | ClasseUpdateManyWithWhereWithoutAnneeScolaireInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type ClasseUncheckedUpdateManyWithoutAnneeScolaireNestedInput = {
    create?: XOR<ClasseCreateWithoutAnneeScolaireInput, ClasseUncheckedCreateWithoutAnneeScolaireInput> | ClasseCreateWithoutAnneeScolaireInput[] | ClasseUncheckedCreateWithoutAnneeScolaireInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutAnneeScolaireInput | ClasseCreateOrConnectWithoutAnneeScolaireInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutAnneeScolaireInput | ClasseUpsertWithWhereUniqueWithoutAnneeScolaireInput[]
    createMany?: ClasseCreateManyAnneeScolaireInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutAnneeScolaireInput | ClasseUpdateWithWhereUniqueWithoutAnneeScolaireInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutAnneeScolaireInput | ClasseUpdateManyWithWhereWithoutAnneeScolaireInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type CoursCreateNestedOneWithoutEvaluationEtudiantInput = {
    create?: XOR<CoursCreateWithoutEvaluationEtudiantInput, CoursUncheckedCreateWithoutEvaluationEtudiantInput>
    connectOrCreate?: CoursCreateOrConnectWithoutEvaluationEtudiantInput
    connect?: CoursWhereUniqueInput
  }

  export type NoteEtudiantCreateNestedManyWithoutEvaluationEtudiantInput = {
    create?: XOR<NoteEtudiantCreateWithoutEvaluationEtudiantInput, NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput> | NoteEtudiantCreateWithoutEvaluationEtudiantInput[] | NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput[]
    connectOrCreate?: NoteEtudiantCreateOrConnectWithoutEvaluationEtudiantInput | NoteEtudiantCreateOrConnectWithoutEvaluationEtudiantInput[]
    createMany?: NoteEtudiantCreateManyEvaluationEtudiantInputEnvelope
    connect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
  }

  export type NoteEtudiantUncheckedCreateNestedManyWithoutEvaluationEtudiantInput = {
    create?: XOR<NoteEtudiantCreateWithoutEvaluationEtudiantInput, NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput> | NoteEtudiantCreateWithoutEvaluationEtudiantInput[] | NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput[]
    connectOrCreate?: NoteEtudiantCreateOrConnectWithoutEvaluationEtudiantInput | NoteEtudiantCreateOrConnectWithoutEvaluationEtudiantInput[]
    createMany?: NoteEtudiantCreateManyEvaluationEtudiantInputEnvelope
    connect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
  }

  export type EnumTypeEvaluationFieldUpdateOperationsInput = {
    set?: $Enums.TypeEvaluation
  }

  export type CoursUpdateOneRequiredWithoutEvaluationEtudiantNestedInput = {
    create?: XOR<CoursCreateWithoutEvaluationEtudiantInput, CoursUncheckedCreateWithoutEvaluationEtudiantInput>
    connectOrCreate?: CoursCreateOrConnectWithoutEvaluationEtudiantInput
    upsert?: CoursUpsertWithoutEvaluationEtudiantInput
    connect?: CoursWhereUniqueInput
    update?: XOR<XOR<CoursUpdateToOneWithWhereWithoutEvaluationEtudiantInput, CoursUpdateWithoutEvaluationEtudiantInput>, CoursUncheckedUpdateWithoutEvaluationEtudiantInput>
  }

  export type NoteEtudiantUpdateManyWithoutEvaluationEtudiantNestedInput = {
    create?: XOR<NoteEtudiantCreateWithoutEvaluationEtudiantInput, NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput> | NoteEtudiantCreateWithoutEvaluationEtudiantInput[] | NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput[]
    connectOrCreate?: NoteEtudiantCreateOrConnectWithoutEvaluationEtudiantInput | NoteEtudiantCreateOrConnectWithoutEvaluationEtudiantInput[]
    upsert?: NoteEtudiantUpsertWithWhereUniqueWithoutEvaluationEtudiantInput | NoteEtudiantUpsertWithWhereUniqueWithoutEvaluationEtudiantInput[]
    createMany?: NoteEtudiantCreateManyEvaluationEtudiantInputEnvelope
    set?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    disconnect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    delete?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    connect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    update?: NoteEtudiantUpdateWithWhereUniqueWithoutEvaluationEtudiantInput | NoteEtudiantUpdateWithWhereUniqueWithoutEvaluationEtudiantInput[]
    updateMany?: NoteEtudiantUpdateManyWithWhereWithoutEvaluationEtudiantInput | NoteEtudiantUpdateManyWithWhereWithoutEvaluationEtudiantInput[]
    deleteMany?: NoteEtudiantScalarWhereInput | NoteEtudiantScalarWhereInput[]
  }

  export type NoteEtudiantUncheckedUpdateManyWithoutEvaluationEtudiantNestedInput = {
    create?: XOR<NoteEtudiantCreateWithoutEvaluationEtudiantInput, NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput> | NoteEtudiantCreateWithoutEvaluationEtudiantInput[] | NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput[]
    connectOrCreate?: NoteEtudiantCreateOrConnectWithoutEvaluationEtudiantInput | NoteEtudiantCreateOrConnectWithoutEvaluationEtudiantInput[]
    upsert?: NoteEtudiantUpsertWithWhereUniqueWithoutEvaluationEtudiantInput | NoteEtudiantUpsertWithWhereUniqueWithoutEvaluationEtudiantInput[]
    createMany?: NoteEtudiantCreateManyEvaluationEtudiantInputEnvelope
    set?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    disconnect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    delete?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    connect?: NoteEtudiantWhereUniqueInput | NoteEtudiantWhereUniqueInput[]
    update?: NoteEtudiantUpdateWithWhereUniqueWithoutEvaluationEtudiantInput | NoteEtudiantUpdateWithWhereUniqueWithoutEvaluationEtudiantInput[]
    updateMany?: NoteEtudiantUpdateManyWithWhereWithoutEvaluationEtudiantInput | NoteEtudiantUpdateManyWithWhereWithoutEvaluationEtudiantInput[]
    deleteMany?: NoteEtudiantScalarWhereInput | NoteEtudiantScalarWhereInput[]
  }

  export type EvaluationEtudiantsCreateNestedOneWithoutNoteEtudiantInput = {
    create?: XOR<EvaluationEtudiantsCreateWithoutNoteEtudiantInput, EvaluationEtudiantsUncheckedCreateWithoutNoteEtudiantInput>
    connectOrCreate?: EvaluationEtudiantsCreateOrConnectWithoutNoteEtudiantInput
    connect?: EvaluationEtudiantsWhereUniqueInput
  }

  export type EtudiantCreateNestedOneWithoutNotesInput = {
    create?: XOR<EtudiantCreateWithoutNotesInput, EtudiantUncheckedCreateWithoutNotesInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutNotesInput
    connect?: EtudiantWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EvaluationEtudiantsUpdateOneWithoutNoteEtudiantNestedInput = {
    create?: XOR<EvaluationEtudiantsCreateWithoutNoteEtudiantInput, EvaluationEtudiantsUncheckedCreateWithoutNoteEtudiantInput>
    connectOrCreate?: EvaluationEtudiantsCreateOrConnectWithoutNoteEtudiantInput
    upsert?: EvaluationEtudiantsUpsertWithoutNoteEtudiantInput
    disconnect?: EvaluationEtudiantsWhereInput | boolean
    delete?: EvaluationEtudiantsWhereInput | boolean
    connect?: EvaluationEtudiantsWhereUniqueInput
    update?: XOR<XOR<EvaluationEtudiantsUpdateToOneWithWhereWithoutNoteEtudiantInput, EvaluationEtudiantsUpdateWithoutNoteEtudiantInput>, EvaluationEtudiantsUncheckedUpdateWithoutNoteEtudiantInput>
  }

  export type EtudiantUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<EtudiantCreateWithoutNotesInput, EtudiantUncheckedCreateWithoutNotesInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutNotesInput
    upsert?: EtudiantUpsertWithoutNotesInput
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutNotesInput, EtudiantUpdateWithoutNotesInput>, EtudiantUncheckedUpdateWithoutNotesInput>
  }

  export type MatiereCreateNestedOneWithoutCoursInput = {
    create?: XOR<MatiereCreateWithoutCoursInput, MatiereUncheckedCreateWithoutCoursInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutCoursInput
    connect?: MatiereWhereUniqueInput
  }

  export type SalleCreateNestedOneWithoutCoursInput = {
    create?: XOR<SalleCreateWithoutCoursInput, SalleUncheckedCreateWithoutCoursInput>
    connectOrCreate?: SalleCreateOrConnectWithoutCoursInput
    connect?: SalleWhereUniqueInput
  }

  export type ClasseCreateNestedOneWithoutCoursInput = {
    create?: XOR<ClasseCreateWithoutCoursInput, ClasseUncheckedCreateWithoutCoursInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutCoursInput
    connect?: ClasseWhereUniqueInput
  }

  export type ProfesseurCreateNestedOneWithoutCoursInput = {
    create?: XOR<ProfesseurCreateWithoutCoursInput, ProfesseurUncheckedCreateWithoutCoursInput>
    connectOrCreate?: ProfesseurCreateOrConnectWithoutCoursInput
    connect?: ProfesseurWhereUniqueInput
  }

  export type EvaluationEtudiantsCreateNestedManyWithoutCoursInput = {
    create?: XOR<EvaluationEtudiantsCreateWithoutCoursInput, EvaluationEtudiantsUncheckedCreateWithoutCoursInput> | EvaluationEtudiantsCreateWithoutCoursInput[] | EvaluationEtudiantsUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: EvaluationEtudiantsCreateOrConnectWithoutCoursInput | EvaluationEtudiantsCreateOrConnectWithoutCoursInput[]
    createMany?: EvaluationEtudiantsCreateManyCoursInputEnvelope
    connect?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
  }

  export type FeuillePresenceCreateNestedManyWithoutCoursInput = {
    create?: XOR<FeuillePresenceCreateWithoutCoursInput, FeuillePresenceUncheckedCreateWithoutCoursInput> | FeuillePresenceCreateWithoutCoursInput[] | FeuillePresenceUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: FeuillePresenceCreateOrConnectWithoutCoursInput | FeuillePresenceCreateOrConnectWithoutCoursInput[]
    createMany?: FeuillePresenceCreateManyCoursInputEnvelope
    connect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
  }

  export type EmploiDuTempsCreateNestedManyWithoutCoursInput = {
    create?: XOR<EmploiDuTempsCreateWithoutCoursInput, EmploiDuTempsUncheckedCreateWithoutCoursInput> | EmploiDuTempsCreateWithoutCoursInput[] | EmploiDuTempsUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutCoursInput | EmploiDuTempsCreateOrConnectWithoutCoursInput[]
    createMany?: EmploiDuTempsCreateManyCoursInputEnvelope
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
  }

  export type EvaluationEtudiantsUncheckedCreateNestedManyWithoutCoursInput = {
    create?: XOR<EvaluationEtudiantsCreateWithoutCoursInput, EvaluationEtudiantsUncheckedCreateWithoutCoursInput> | EvaluationEtudiantsCreateWithoutCoursInput[] | EvaluationEtudiantsUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: EvaluationEtudiantsCreateOrConnectWithoutCoursInput | EvaluationEtudiantsCreateOrConnectWithoutCoursInput[]
    createMany?: EvaluationEtudiantsCreateManyCoursInputEnvelope
    connect?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
  }

  export type FeuillePresenceUncheckedCreateNestedManyWithoutCoursInput = {
    create?: XOR<FeuillePresenceCreateWithoutCoursInput, FeuillePresenceUncheckedCreateWithoutCoursInput> | FeuillePresenceCreateWithoutCoursInput[] | FeuillePresenceUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: FeuillePresenceCreateOrConnectWithoutCoursInput | FeuillePresenceCreateOrConnectWithoutCoursInput[]
    createMany?: FeuillePresenceCreateManyCoursInputEnvelope
    connect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
  }

  export type EmploiDuTempsUncheckedCreateNestedManyWithoutCoursInput = {
    create?: XOR<EmploiDuTempsCreateWithoutCoursInput, EmploiDuTempsUncheckedCreateWithoutCoursInput> | EmploiDuTempsCreateWithoutCoursInput[] | EmploiDuTempsUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutCoursInput | EmploiDuTempsCreateOrConnectWithoutCoursInput[]
    createMany?: EmploiDuTempsCreateManyCoursInputEnvelope
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
  }

  export type MatiereUpdateOneWithoutCoursNestedInput = {
    create?: XOR<MatiereCreateWithoutCoursInput, MatiereUncheckedCreateWithoutCoursInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutCoursInput
    upsert?: MatiereUpsertWithoutCoursInput
    disconnect?: MatiereWhereInput | boolean
    delete?: MatiereWhereInput | boolean
    connect?: MatiereWhereUniqueInput
    update?: XOR<XOR<MatiereUpdateToOneWithWhereWithoutCoursInput, MatiereUpdateWithoutCoursInput>, MatiereUncheckedUpdateWithoutCoursInput>
  }

  export type SalleUpdateOneWithoutCoursNestedInput = {
    create?: XOR<SalleCreateWithoutCoursInput, SalleUncheckedCreateWithoutCoursInput>
    connectOrCreate?: SalleCreateOrConnectWithoutCoursInput
    upsert?: SalleUpsertWithoutCoursInput
    disconnect?: SalleWhereInput | boolean
    delete?: SalleWhereInput | boolean
    connect?: SalleWhereUniqueInput
    update?: XOR<XOR<SalleUpdateToOneWithWhereWithoutCoursInput, SalleUpdateWithoutCoursInput>, SalleUncheckedUpdateWithoutCoursInput>
  }

  export type ClasseUpdateOneWithoutCoursNestedInput = {
    create?: XOR<ClasseCreateWithoutCoursInput, ClasseUncheckedCreateWithoutCoursInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutCoursInput
    upsert?: ClasseUpsertWithoutCoursInput
    disconnect?: ClasseWhereInput | boolean
    delete?: ClasseWhereInput | boolean
    connect?: ClasseWhereUniqueInput
    update?: XOR<XOR<ClasseUpdateToOneWithWhereWithoutCoursInput, ClasseUpdateWithoutCoursInput>, ClasseUncheckedUpdateWithoutCoursInput>
  }

  export type ProfesseurUpdateOneWithoutCoursNestedInput = {
    create?: XOR<ProfesseurCreateWithoutCoursInput, ProfesseurUncheckedCreateWithoutCoursInput>
    connectOrCreate?: ProfesseurCreateOrConnectWithoutCoursInput
    upsert?: ProfesseurUpsertWithoutCoursInput
    disconnect?: ProfesseurWhereInput | boolean
    delete?: ProfesseurWhereInput | boolean
    connect?: ProfesseurWhereUniqueInput
    update?: XOR<XOR<ProfesseurUpdateToOneWithWhereWithoutCoursInput, ProfesseurUpdateWithoutCoursInput>, ProfesseurUncheckedUpdateWithoutCoursInput>
  }

  export type EvaluationEtudiantsUpdateManyWithoutCoursNestedInput = {
    create?: XOR<EvaluationEtudiantsCreateWithoutCoursInput, EvaluationEtudiantsUncheckedCreateWithoutCoursInput> | EvaluationEtudiantsCreateWithoutCoursInput[] | EvaluationEtudiantsUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: EvaluationEtudiantsCreateOrConnectWithoutCoursInput | EvaluationEtudiantsCreateOrConnectWithoutCoursInput[]
    upsert?: EvaluationEtudiantsUpsertWithWhereUniqueWithoutCoursInput | EvaluationEtudiantsUpsertWithWhereUniqueWithoutCoursInput[]
    createMany?: EvaluationEtudiantsCreateManyCoursInputEnvelope
    set?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
    disconnect?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
    delete?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
    connect?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
    update?: EvaluationEtudiantsUpdateWithWhereUniqueWithoutCoursInput | EvaluationEtudiantsUpdateWithWhereUniqueWithoutCoursInput[]
    updateMany?: EvaluationEtudiantsUpdateManyWithWhereWithoutCoursInput | EvaluationEtudiantsUpdateManyWithWhereWithoutCoursInput[]
    deleteMany?: EvaluationEtudiantsScalarWhereInput | EvaluationEtudiantsScalarWhereInput[]
  }

  export type FeuillePresenceUpdateManyWithoutCoursNestedInput = {
    create?: XOR<FeuillePresenceCreateWithoutCoursInput, FeuillePresenceUncheckedCreateWithoutCoursInput> | FeuillePresenceCreateWithoutCoursInput[] | FeuillePresenceUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: FeuillePresenceCreateOrConnectWithoutCoursInput | FeuillePresenceCreateOrConnectWithoutCoursInput[]
    upsert?: FeuillePresenceUpsertWithWhereUniqueWithoutCoursInput | FeuillePresenceUpsertWithWhereUniqueWithoutCoursInput[]
    createMany?: FeuillePresenceCreateManyCoursInputEnvelope
    set?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    disconnect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    delete?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    connect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    update?: FeuillePresenceUpdateWithWhereUniqueWithoutCoursInput | FeuillePresenceUpdateWithWhereUniqueWithoutCoursInput[]
    updateMany?: FeuillePresenceUpdateManyWithWhereWithoutCoursInput | FeuillePresenceUpdateManyWithWhereWithoutCoursInput[]
    deleteMany?: FeuillePresenceScalarWhereInput | FeuillePresenceScalarWhereInput[]
  }

  export type EmploiDuTempsUpdateManyWithoutCoursNestedInput = {
    create?: XOR<EmploiDuTempsCreateWithoutCoursInput, EmploiDuTempsUncheckedCreateWithoutCoursInput> | EmploiDuTempsCreateWithoutCoursInput[] | EmploiDuTempsUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutCoursInput | EmploiDuTempsCreateOrConnectWithoutCoursInput[]
    upsert?: EmploiDuTempsUpsertWithWhereUniqueWithoutCoursInput | EmploiDuTempsUpsertWithWhereUniqueWithoutCoursInput[]
    createMany?: EmploiDuTempsCreateManyCoursInputEnvelope
    set?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    disconnect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    delete?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    update?: EmploiDuTempsUpdateWithWhereUniqueWithoutCoursInput | EmploiDuTempsUpdateWithWhereUniqueWithoutCoursInput[]
    updateMany?: EmploiDuTempsUpdateManyWithWhereWithoutCoursInput | EmploiDuTempsUpdateManyWithWhereWithoutCoursInput[]
    deleteMany?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
  }

  export type EvaluationEtudiantsUncheckedUpdateManyWithoutCoursNestedInput = {
    create?: XOR<EvaluationEtudiantsCreateWithoutCoursInput, EvaluationEtudiantsUncheckedCreateWithoutCoursInput> | EvaluationEtudiantsCreateWithoutCoursInput[] | EvaluationEtudiantsUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: EvaluationEtudiantsCreateOrConnectWithoutCoursInput | EvaluationEtudiantsCreateOrConnectWithoutCoursInput[]
    upsert?: EvaluationEtudiantsUpsertWithWhereUniqueWithoutCoursInput | EvaluationEtudiantsUpsertWithWhereUniqueWithoutCoursInput[]
    createMany?: EvaluationEtudiantsCreateManyCoursInputEnvelope
    set?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
    disconnect?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
    delete?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
    connect?: EvaluationEtudiantsWhereUniqueInput | EvaluationEtudiantsWhereUniqueInput[]
    update?: EvaluationEtudiantsUpdateWithWhereUniqueWithoutCoursInput | EvaluationEtudiantsUpdateWithWhereUniqueWithoutCoursInput[]
    updateMany?: EvaluationEtudiantsUpdateManyWithWhereWithoutCoursInput | EvaluationEtudiantsUpdateManyWithWhereWithoutCoursInput[]
    deleteMany?: EvaluationEtudiantsScalarWhereInput | EvaluationEtudiantsScalarWhereInput[]
  }

  export type FeuillePresenceUncheckedUpdateManyWithoutCoursNestedInput = {
    create?: XOR<FeuillePresenceCreateWithoutCoursInput, FeuillePresenceUncheckedCreateWithoutCoursInput> | FeuillePresenceCreateWithoutCoursInput[] | FeuillePresenceUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: FeuillePresenceCreateOrConnectWithoutCoursInput | FeuillePresenceCreateOrConnectWithoutCoursInput[]
    upsert?: FeuillePresenceUpsertWithWhereUniqueWithoutCoursInput | FeuillePresenceUpsertWithWhereUniqueWithoutCoursInput[]
    createMany?: FeuillePresenceCreateManyCoursInputEnvelope
    set?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    disconnect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    delete?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    connect?: FeuillePresenceWhereUniqueInput | FeuillePresenceWhereUniqueInput[]
    update?: FeuillePresenceUpdateWithWhereUniqueWithoutCoursInput | FeuillePresenceUpdateWithWhereUniqueWithoutCoursInput[]
    updateMany?: FeuillePresenceUpdateManyWithWhereWithoutCoursInput | FeuillePresenceUpdateManyWithWhereWithoutCoursInput[]
    deleteMany?: FeuillePresenceScalarWhereInput | FeuillePresenceScalarWhereInput[]
  }

  export type EmploiDuTempsUncheckedUpdateManyWithoutCoursNestedInput = {
    create?: XOR<EmploiDuTempsCreateWithoutCoursInput, EmploiDuTempsUncheckedCreateWithoutCoursInput> | EmploiDuTempsCreateWithoutCoursInput[] | EmploiDuTempsUncheckedCreateWithoutCoursInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutCoursInput | EmploiDuTempsCreateOrConnectWithoutCoursInput[]
    upsert?: EmploiDuTempsUpsertWithWhereUniqueWithoutCoursInput | EmploiDuTempsUpsertWithWhereUniqueWithoutCoursInput[]
    createMany?: EmploiDuTempsCreateManyCoursInputEnvelope
    set?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    disconnect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    delete?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    update?: EmploiDuTempsUpdateWithWhereUniqueWithoutCoursInput | EmploiDuTempsUpdateWithWhereUniqueWithoutCoursInput[]
    updateMany?: EmploiDuTempsUpdateManyWithWhereWithoutCoursInput | EmploiDuTempsUpdateManyWithWhereWithoutCoursInput[]
    deleteMany?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
  }

  export type EtablissementCreateNestedOneWithoutSalleInput = {
    create?: XOR<EtablissementCreateWithoutSalleInput, EtablissementUncheckedCreateWithoutSalleInput>
    connectOrCreate?: EtablissementCreateOrConnectWithoutSalleInput
    connect?: EtablissementWhereUniqueInput
  }

  export type CoursCreateNestedManyWithoutSalleInput = {
    create?: XOR<CoursCreateWithoutSalleInput, CoursUncheckedCreateWithoutSalleInput> | CoursCreateWithoutSalleInput[] | CoursUncheckedCreateWithoutSalleInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutSalleInput | CoursCreateOrConnectWithoutSalleInput[]
    createMany?: CoursCreateManySalleInputEnvelope
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
  }

  export type EmploiDuTempsCreateNestedManyWithoutSalleInput = {
    create?: XOR<EmploiDuTempsCreateWithoutSalleInput, EmploiDuTempsUncheckedCreateWithoutSalleInput> | EmploiDuTempsCreateWithoutSalleInput[] | EmploiDuTempsUncheckedCreateWithoutSalleInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutSalleInput | EmploiDuTempsCreateOrConnectWithoutSalleInput[]
    createMany?: EmploiDuTempsCreateManySalleInputEnvelope
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
  }

  export type CoursUncheckedCreateNestedManyWithoutSalleInput = {
    create?: XOR<CoursCreateWithoutSalleInput, CoursUncheckedCreateWithoutSalleInput> | CoursCreateWithoutSalleInput[] | CoursUncheckedCreateWithoutSalleInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutSalleInput | CoursCreateOrConnectWithoutSalleInput[]
    createMany?: CoursCreateManySalleInputEnvelope
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
  }

  export type EmploiDuTempsUncheckedCreateNestedManyWithoutSalleInput = {
    create?: XOR<EmploiDuTempsCreateWithoutSalleInput, EmploiDuTempsUncheckedCreateWithoutSalleInput> | EmploiDuTempsCreateWithoutSalleInput[] | EmploiDuTempsUncheckedCreateWithoutSalleInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutSalleInput | EmploiDuTempsCreateOrConnectWithoutSalleInput[]
    createMany?: EmploiDuTempsCreateManySalleInputEnvelope
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
  }

  export type EtablissementUpdateOneRequiredWithoutSalleNestedInput = {
    create?: XOR<EtablissementCreateWithoutSalleInput, EtablissementUncheckedCreateWithoutSalleInput>
    connectOrCreate?: EtablissementCreateOrConnectWithoutSalleInput
    upsert?: EtablissementUpsertWithoutSalleInput
    connect?: EtablissementWhereUniqueInput
    update?: XOR<XOR<EtablissementUpdateToOneWithWhereWithoutSalleInput, EtablissementUpdateWithoutSalleInput>, EtablissementUncheckedUpdateWithoutSalleInput>
  }

  export type CoursUpdateManyWithoutSalleNestedInput = {
    create?: XOR<CoursCreateWithoutSalleInput, CoursUncheckedCreateWithoutSalleInput> | CoursCreateWithoutSalleInput[] | CoursUncheckedCreateWithoutSalleInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutSalleInput | CoursCreateOrConnectWithoutSalleInput[]
    upsert?: CoursUpsertWithWhereUniqueWithoutSalleInput | CoursUpsertWithWhereUniqueWithoutSalleInput[]
    createMany?: CoursCreateManySalleInputEnvelope
    set?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    disconnect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    delete?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    update?: CoursUpdateWithWhereUniqueWithoutSalleInput | CoursUpdateWithWhereUniqueWithoutSalleInput[]
    updateMany?: CoursUpdateManyWithWhereWithoutSalleInput | CoursUpdateManyWithWhereWithoutSalleInput[]
    deleteMany?: CoursScalarWhereInput | CoursScalarWhereInput[]
  }

  export type EmploiDuTempsUpdateManyWithoutSalleNestedInput = {
    create?: XOR<EmploiDuTempsCreateWithoutSalleInput, EmploiDuTempsUncheckedCreateWithoutSalleInput> | EmploiDuTempsCreateWithoutSalleInput[] | EmploiDuTempsUncheckedCreateWithoutSalleInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutSalleInput | EmploiDuTempsCreateOrConnectWithoutSalleInput[]
    upsert?: EmploiDuTempsUpsertWithWhereUniqueWithoutSalleInput | EmploiDuTempsUpsertWithWhereUniqueWithoutSalleInput[]
    createMany?: EmploiDuTempsCreateManySalleInputEnvelope
    set?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    disconnect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    delete?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    update?: EmploiDuTempsUpdateWithWhereUniqueWithoutSalleInput | EmploiDuTempsUpdateWithWhereUniqueWithoutSalleInput[]
    updateMany?: EmploiDuTempsUpdateManyWithWhereWithoutSalleInput | EmploiDuTempsUpdateManyWithWhereWithoutSalleInput[]
    deleteMany?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
  }

  export type CoursUncheckedUpdateManyWithoutSalleNestedInput = {
    create?: XOR<CoursCreateWithoutSalleInput, CoursUncheckedCreateWithoutSalleInput> | CoursCreateWithoutSalleInput[] | CoursUncheckedCreateWithoutSalleInput[]
    connectOrCreate?: CoursCreateOrConnectWithoutSalleInput | CoursCreateOrConnectWithoutSalleInput[]
    upsert?: CoursUpsertWithWhereUniqueWithoutSalleInput | CoursUpsertWithWhereUniqueWithoutSalleInput[]
    createMany?: CoursCreateManySalleInputEnvelope
    set?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    disconnect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    delete?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    connect?: CoursWhereUniqueInput | CoursWhereUniqueInput[]
    update?: CoursUpdateWithWhereUniqueWithoutSalleInput | CoursUpdateWithWhereUniqueWithoutSalleInput[]
    updateMany?: CoursUpdateManyWithWhereWithoutSalleInput | CoursUpdateManyWithWhereWithoutSalleInput[]
    deleteMany?: CoursScalarWhereInput | CoursScalarWhereInput[]
  }

  export type EmploiDuTempsUncheckedUpdateManyWithoutSalleNestedInput = {
    create?: XOR<EmploiDuTempsCreateWithoutSalleInput, EmploiDuTempsUncheckedCreateWithoutSalleInput> | EmploiDuTempsCreateWithoutSalleInput[] | EmploiDuTempsUncheckedCreateWithoutSalleInput[]
    connectOrCreate?: EmploiDuTempsCreateOrConnectWithoutSalleInput | EmploiDuTempsCreateOrConnectWithoutSalleInput[]
    upsert?: EmploiDuTempsUpsertWithWhereUniqueWithoutSalleInput | EmploiDuTempsUpsertWithWhereUniqueWithoutSalleInput[]
    createMany?: EmploiDuTempsCreateManySalleInputEnvelope
    set?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    disconnect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    delete?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    connect?: EmploiDuTempsWhereUniqueInput | EmploiDuTempsWhereUniqueInput[]
    update?: EmploiDuTempsUpdateWithWhereUniqueWithoutSalleInput | EmploiDuTempsUpdateWithWhereUniqueWithoutSalleInput[]
    updateMany?: EmploiDuTempsUpdateManyWithWhereWithoutSalleInput | EmploiDuTempsUpdateManyWithWhereWithoutSalleInput[]
    deleteMany?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
  }

  export type CoursCreateNestedOneWithoutFeuillePresencesInput = {
    create?: XOR<CoursCreateWithoutFeuillePresencesInput, CoursUncheckedCreateWithoutFeuillePresencesInput>
    connectOrCreate?: CoursCreateOrConnectWithoutFeuillePresencesInput
    connect?: CoursWhereUniqueInput
  }

  export type EtudiantCreateNestedOneWithoutFeuillePresencesInput = {
    create?: XOR<EtudiantCreateWithoutFeuillePresencesInput, EtudiantUncheckedCreateWithoutFeuillePresencesInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutFeuillePresencesInput
    connect?: EtudiantWhereUniqueInput
  }

  export type CoursUpdateOneRequiredWithoutFeuillePresencesNestedInput = {
    create?: XOR<CoursCreateWithoutFeuillePresencesInput, CoursUncheckedCreateWithoutFeuillePresencesInput>
    connectOrCreate?: CoursCreateOrConnectWithoutFeuillePresencesInput
    upsert?: CoursUpsertWithoutFeuillePresencesInput
    connect?: CoursWhereUniqueInput
    update?: XOR<XOR<CoursUpdateToOneWithWhereWithoutFeuillePresencesInput, CoursUpdateWithoutFeuillePresencesInput>, CoursUncheckedUpdateWithoutFeuillePresencesInput>
  }

  export type EtudiantUpdateOneWithoutFeuillePresencesNestedInput = {
    create?: XOR<EtudiantCreateWithoutFeuillePresencesInput, EtudiantUncheckedCreateWithoutFeuillePresencesInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutFeuillePresencesInput
    upsert?: EtudiantUpsertWithoutFeuillePresencesInput
    disconnect?: EtudiantWhereInput | boolean
    delete?: EtudiantWhereInput | boolean
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutFeuillePresencesInput, EtudiantUpdateWithoutFeuillePresencesInput>, EtudiantUncheckedUpdateWithoutFeuillePresencesInput>
  }

  export type CoursCreateNestedOneWithoutEmploiDuTempsInput = {
    create?: XOR<CoursCreateWithoutEmploiDuTempsInput, CoursUncheckedCreateWithoutEmploiDuTempsInput>
    connectOrCreate?: CoursCreateOrConnectWithoutEmploiDuTempsInput
    connect?: CoursWhereUniqueInput
  }

  export type ClasseCreateNestedOneWithoutEmploiDuTempsInput = {
    create?: XOR<ClasseCreateWithoutEmploiDuTempsInput, ClasseUncheckedCreateWithoutEmploiDuTempsInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutEmploiDuTempsInput
    connect?: ClasseWhereUniqueInput
  }

  export type ProfesseurCreateNestedOneWithoutEmploiDuTempsInput = {
    create?: XOR<ProfesseurCreateWithoutEmploiDuTempsInput, ProfesseurUncheckedCreateWithoutEmploiDuTempsInput>
    connectOrCreate?: ProfesseurCreateOrConnectWithoutEmploiDuTempsInput
    connect?: ProfesseurWhereUniqueInput
  }

  export type SalleCreateNestedOneWithoutEmploiDuTempsInput = {
    create?: XOR<SalleCreateWithoutEmploiDuTempsInput, SalleUncheckedCreateWithoutEmploiDuTempsInput>
    connectOrCreate?: SalleCreateOrConnectWithoutEmploiDuTempsInput
    connect?: SalleWhereUniqueInput
  }

  export type CoursUpdateOneRequiredWithoutEmploiDuTempsNestedInput = {
    create?: XOR<CoursCreateWithoutEmploiDuTempsInput, CoursUncheckedCreateWithoutEmploiDuTempsInput>
    connectOrCreate?: CoursCreateOrConnectWithoutEmploiDuTempsInput
    upsert?: CoursUpsertWithoutEmploiDuTempsInput
    connect?: CoursWhereUniqueInput
    update?: XOR<XOR<CoursUpdateToOneWithWhereWithoutEmploiDuTempsInput, CoursUpdateWithoutEmploiDuTempsInput>, CoursUncheckedUpdateWithoutEmploiDuTempsInput>
  }

  export type ClasseUpdateOneRequiredWithoutEmploiDuTempsNestedInput = {
    create?: XOR<ClasseCreateWithoutEmploiDuTempsInput, ClasseUncheckedCreateWithoutEmploiDuTempsInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutEmploiDuTempsInput
    upsert?: ClasseUpsertWithoutEmploiDuTempsInput
    connect?: ClasseWhereUniqueInput
    update?: XOR<XOR<ClasseUpdateToOneWithWhereWithoutEmploiDuTempsInput, ClasseUpdateWithoutEmploiDuTempsInput>, ClasseUncheckedUpdateWithoutEmploiDuTempsInput>
  }

  export type ProfesseurUpdateOneWithoutEmploiDuTempsNestedInput = {
    create?: XOR<ProfesseurCreateWithoutEmploiDuTempsInput, ProfesseurUncheckedCreateWithoutEmploiDuTempsInput>
    connectOrCreate?: ProfesseurCreateOrConnectWithoutEmploiDuTempsInput
    upsert?: ProfesseurUpsertWithoutEmploiDuTempsInput
    disconnect?: ProfesseurWhereInput | boolean
    delete?: ProfesseurWhereInput | boolean
    connect?: ProfesseurWhereUniqueInput
    update?: XOR<XOR<ProfesseurUpdateToOneWithWhereWithoutEmploiDuTempsInput, ProfesseurUpdateWithoutEmploiDuTempsInput>, ProfesseurUncheckedUpdateWithoutEmploiDuTempsInput>
  }

  export type SalleUpdateOneRequiredWithoutEmploiDuTempsNestedInput = {
    create?: XOR<SalleCreateWithoutEmploiDuTempsInput, SalleUncheckedCreateWithoutEmploiDuTempsInput>
    connectOrCreate?: SalleCreateOrConnectWithoutEmploiDuTempsInput
    upsert?: SalleUpsertWithoutEmploiDuTempsInput
    connect?: SalleWhereUniqueInput
    update?: XOR<XOR<SalleUpdateToOneWithWhereWithoutEmploiDuTempsInput, SalleUpdateWithoutEmploiDuTempsInput>, SalleUncheckedUpdateWithoutEmploiDuTempsInput>
  }

  export type EtudiantCreateNestedOneWithoutPaiementInput = {
    create?: XOR<EtudiantCreateWithoutPaiementInput, EtudiantUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutPaiementInput
    connect?: EtudiantWhereUniqueInput
  }

  export type EtudiantUpdateOneRequiredWithoutPaiementNestedInput = {
    create?: XOR<EtudiantCreateWithoutPaiementInput, EtudiantUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutPaiementInput
    upsert?: EtudiantUpsertWithoutPaiementInput
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutPaiementInput, EtudiantUpdateWithoutPaiementInput>, EtudiantUncheckedUpdateWithoutPaiementInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGenreFilter<$PrismaModel = never> = {
    equals?: $Enums.Genre | EnumGenreFieldRefInput<$PrismaModel>
    in?: $Enums.Genre[] | ListEnumGenreFieldRefInput<$PrismaModel>
    notIn?: $Enums.Genre[] | ListEnumGenreFieldRefInput<$PrismaModel>
    not?: NestedEnumGenreFilter<$PrismaModel> | $Enums.Genre
  }

  export type NestedEnumGroupeSanguinNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupeSanguin | EnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    in?: $Enums.GroupeSanguin[] | ListEnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GroupeSanguin[] | ListEnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel> | $Enums.GroupeSanguin | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenreWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Genre | EnumGenreFieldRefInput<$PrismaModel>
    in?: $Enums.Genre[] | ListEnumGenreFieldRefInput<$PrismaModel>
    notIn?: $Enums.Genre[] | ListEnumGenreFieldRefInput<$PrismaModel>
    not?: NestedEnumGenreWithAggregatesFilter<$PrismaModel> | $Enums.Genre
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenreFilter<$PrismaModel>
    _max?: NestedEnumGenreFilter<$PrismaModel>
  }

  export type NestedEnumGroupeSanguinNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupeSanguin | EnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    in?: $Enums.GroupeSanguin[] | ListEnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GroupeSanguin[] | ListEnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGroupeSanguinNullableWithAggregatesFilter<$PrismaModel> | $Enums.GroupeSanguin | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel>
    _max?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTypeDiplomeFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeDiplome | EnumTypeDiplomeFieldRefInput<$PrismaModel>
    in?: $Enums.TypeDiplome[] | ListEnumTypeDiplomeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeDiplome[] | ListEnumTypeDiplomeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeDiplomeFilter<$PrismaModel> | $Enums.TypeDiplome
  }

  export type NestedEnumTypeDiplomeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeDiplome | EnumTypeDiplomeFieldRefInput<$PrismaModel>
    in?: $Enums.TypeDiplome[] | ListEnumTypeDiplomeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeDiplome[] | ListEnumTypeDiplomeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeDiplomeWithAggregatesFilter<$PrismaModel> | $Enums.TypeDiplome
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeDiplomeFilter<$PrismaModel>
    _max?: NestedEnumTypeDiplomeFilter<$PrismaModel>
  }

  export type NestedEnumTypeEvaluationFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeEvaluation | EnumTypeEvaluationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeEvaluation[] | ListEnumTypeEvaluationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeEvaluation[] | ListEnumTypeEvaluationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeEvaluationFilter<$PrismaModel> | $Enums.TypeEvaluation
  }

  export type NestedEnumTypeEvaluationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeEvaluation | EnumTypeEvaluationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeEvaluation[] | ListEnumTypeEvaluationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeEvaluation[] | ListEnumTypeEvaluationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeEvaluationWithAggregatesFilter<$PrismaModel> | $Enums.TypeEvaluation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeEvaluationFilter<$PrismaModel>
    _max?: NestedEnumTypeEvaluationFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ContactCreateWithoutUtilisateursInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    telephone: string
    fix?: string | null
    fax?: string | null
    email: string
    siteWeb?: string | null
    reseauxSociaux?: ReseauSocialCreateNestedManyWithoutContactInput
    etablissements?: EtablissementCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutUtilisateursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    telephone: string
    fix?: string | null
    fax?: string | null
    email: string
    siteWeb?: string | null
    reseauxSociaux?: ReseauSocialUncheckedCreateNestedManyWithoutContactInput
    etablissements?: EtablissementUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutUtilisateursInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutUtilisateursInput, ContactUncheckedCreateWithoutUtilisateursInput>
  }

  export type AdresseCreateWithoutUtilisateursInput = {
    pays: string
    region: string
    ville: string
    codePostal?: string | null
    geolocalisation?: string | null
    etablissements?: EtablissementCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutUtilisateursInput = {
    id?: number
    pays: string
    region: string
    ville: string
    codePostal?: string | null
    geolocalisation?: string | null
    etablissements?: EtablissementUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutUtilisateursInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutUtilisateursInput, AdresseUncheckedCreateWithoutUtilisateursInput>
  }

  export type EtablissementCreateWithoutUtilisateursInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresse?: AdresseCreateNestedOneWithoutEtablissementsInput
    contact?: ContactCreateNestedOneWithoutEtablissementsInput
    domaines?: DomaineCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseCreateNestedManyWithoutEtablissementInput
    salle?: SalleCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementUncheckedCreateWithoutUtilisateursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresseId?: number | null
    contactId?: number | null
    domaines?: DomaineUncheckedCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseUncheckedCreateNestedManyWithoutEtablissementInput
    salle?: SalleUncheckedCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementCreateOrConnectWithoutUtilisateursInput = {
    where: EtablissementWhereUniqueInput
    create: XOR<EtablissementCreateWithoutUtilisateursInput, EtablissementUncheckedCreateWithoutUtilisateursInput>
  }

  export type EtudiantCreateWithoutProfileInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    feuillePresencesId?: number | null
    inscriptions?: InscriptionCreateNestedManyWithoutEtudiantInput
    notes?: NoteEtudiantCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutProfileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    feuillePresencesId?: number | null
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutEtudiantInput
    notes?: NoteEtudiantUncheckedCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutProfileInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutProfileInput, EtudiantUncheckedCreateWithoutProfileInput>
  }

  export type PermissionCreateWithoutUtilisateursInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: PermissionCreateroleInput | $Enums.Role[]
    label: string
    slug?: string | null
  }

  export type PermissionUncheckedCreateWithoutUtilisateursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: PermissionCreateroleInput | $Enums.Role[]
    label: string
    slug?: string | null
  }

  export type PermissionCreateOrConnectWithoutUtilisateursInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutUtilisateursInput, PermissionUncheckedCreateWithoutUtilisateursInput>
  }

  export type ProfesseurCreateWithoutProfileInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cours?: CoursCreateNestedManyWithoutProfesseurInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutProfesseurInput
  }

  export type ProfesseurUncheckedCreateWithoutProfileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cours?: CoursUncheckedCreateNestedManyWithoutProfesseurInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutProfesseurInput
  }

  export type ProfesseurCreateOrConnectWithoutProfileInput = {
    where: ProfesseurWhereUniqueInput
    create: XOR<ProfesseurCreateWithoutProfileInput, ProfesseurUncheckedCreateWithoutProfileInput>
  }

  export type ContactUpsertWithoutUtilisateursInput = {
    update: XOR<ContactUpdateWithoutUtilisateursInput, ContactUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<ContactCreateWithoutUtilisateursInput, ContactUncheckedCreateWithoutUtilisateursInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutUtilisateursInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutUtilisateursInput, ContactUncheckedUpdateWithoutUtilisateursInput>
  }

  export type ContactUpdateWithoutUtilisateursInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    reseauxSociaux?: ReseauSocialUpdateManyWithoutContactNestedInput
    etablissements?: EtablissementUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    reseauxSociaux?: ReseauSocialUncheckedUpdateManyWithoutContactNestedInput
    etablissements?: EtablissementUncheckedUpdateManyWithoutContactNestedInput
  }

  export type AdresseUpsertWithoutUtilisateursInput = {
    update: XOR<AdresseUpdateWithoutUtilisateursInput, AdresseUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<AdresseCreateWithoutUtilisateursInput, AdresseUncheckedCreateWithoutUtilisateursInput>
    where?: AdresseWhereInput
  }

  export type AdresseUpdateToOneWithWhereWithoutUtilisateursInput = {
    where?: AdresseWhereInput
    data: XOR<AdresseUpdateWithoutUtilisateursInput, AdresseUncheckedUpdateWithoutUtilisateursInput>
  }

  export type AdresseUpdateWithoutUtilisateursInput = {
    pays?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    geolocalisation?: NullableStringFieldUpdateOperationsInput | string | null
    etablissements?: EtablissementUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    pays?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    geolocalisation?: NullableStringFieldUpdateOperationsInput | string | null
    etablissements?: EtablissementUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type EtablissementUpsertWithoutUtilisateursInput = {
    update: XOR<EtablissementUpdateWithoutUtilisateursInput, EtablissementUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<EtablissementCreateWithoutUtilisateursInput, EtablissementUncheckedCreateWithoutUtilisateursInput>
    where?: EtablissementWhereInput
  }

  export type EtablissementUpdateToOneWithWhereWithoutUtilisateursInput = {
    where?: EtablissementWhereInput
    data: XOR<EtablissementUpdateWithoutUtilisateursInput, EtablissementUncheckedUpdateWithoutUtilisateursInput>
  }

  export type EtablissementUpdateWithoutUtilisateursInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: AdresseUpdateOneWithoutEtablissementsNestedInput
    contact?: ContactUpdateOneWithoutEtablissementsNestedInput
    domaines?: DomaineUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    domaines?: DomaineUncheckedUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUncheckedUpdateManyWithoutEtablissementNestedInput
  }

  export type EtudiantUpsertWithoutProfileInput = {
    update: XOR<EtudiantUpdateWithoutProfileInput, EtudiantUncheckedUpdateWithoutProfileInput>
    create: XOR<EtudiantCreateWithoutProfileInput, EtudiantUncheckedCreateWithoutProfileInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutProfileInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutProfileInput, EtudiantUncheckedUpdateWithoutProfileInput>
  }

  export type EtudiantUpdateWithoutProfileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    inscriptions?: InscriptionUpdateManyWithoutEtudiantNestedInput
    notes?: NoteEtudiantUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    inscriptions?: InscriptionUncheckedUpdateManyWithoutEtudiantNestedInput
    notes?: NoteEtudiantUncheckedUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type PermissionUpsertWithWhereUniqueWithoutUtilisateursInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutUtilisateursInput, PermissionUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<PermissionCreateWithoutUtilisateursInput, PermissionUncheckedCreateWithoutUtilisateursInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutUtilisateursInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutUtilisateursInput, PermissionUncheckedUpdateWithoutUtilisateursInput>
  }

  export type PermissionUpdateManyWithWhereWithoutUtilisateursInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutUtilisateursInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: IntFilter<"Permission"> | number
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    role?: EnumRoleNullableListFilter<"Permission">
    label?: StringFilter<"Permission"> | string
    slug?: StringNullableFilter<"Permission"> | string | null
  }

  export type ProfesseurUpsertWithoutProfileInput = {
    update: XOR<ProfesseurUpdateWithoutProfileInput, ProfesseurUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfesseurCreateWithoutProfileInput, ProfesseurUncheckedCreateWithoutProfileInput>
    where?: ProfesseurWhereInput
  }

  export type ProfesseurUpdateToOneWithWhereWithoutProfileInput = {
    where?: ProfesseurWhereInput
    data: XOR<ProfesseurUpdateWithoutProfileInput, ProfesseurUncheckedUpdateWithoutProfileInput>
  }

  export type ProfesseurUpdateWithoutProfileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cours?: CoursUpdateManyWithoutProfesseurNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutProfesseurNestedInput
  }

  export type ProfesseurUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cours?: CoursUncheckedUpdateManyWithoutProfesseurNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutProfesseurNestedInput
  }

  export type UtilisateurCreateWithoutPermissionsInput = {
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    accountId?: number | null
    contact?: ContactCreateNestedOneWithoutUtilisateursInput
    adresse?: AdresseCreateNestedOneWithoutUtilisateursInput
    etablissement?: EtablissementCreateNestedOneWithoutUtilisateursInput
    etudiant?: EtudiantCreateNestedOneWithoutProfileInput
    Professeur?: ProfesseurCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurUncheckedCreateWithoutPermissionsInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    etablissementId?: number | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    contactId?: number | null
    adresseId?: number | null
    accountId?: number | null
    etudiant?: EtudiantUncheckedCreateNestedOneWithoutProfileInput
    Professeur?: ProfesseurUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurCreateOrConnectWithoutPermissionsInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutPermissionsInput, UtilisateurUncheckedCreateWithoutPermissionsInput>
  }

  export type UtilisateurUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: UtilisateurWhereUniqueInput
    update: XOR<UtilisateurUpdateWithoutPermissionsInput, UtilisateurUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UtilisateurCreateWithoutPermissionsInput, UtilisateurUncheckedCreateWithoutPermissionsInput>
  }

  export type UtilisateurUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: UtilisateurWhereUniqueInput
    data: XOR<UtilisateurUpdateWithoutPermissionsInput, UtilisateurUncheckedUpdateWithoutPermissionsInput>
  }

  export type UtilisateurUpdateManyWithWhereWithoutPermissionsInput = {
    where: UtilisateurScalarWhereInput
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type UtilisateurScalarWhereInput = {
    AND?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
    OR?: UtilisateurScalarWhereInput[]
    NOT?: UtilisateurScalarWhereInput | UtilisateurScalarWhereInput[]
    id?: IntFilter<"Utilisateur"> | number
    matricule?: StringFilter<"Utilisateur"> | string
    createdAt?: DateTimeFilter<"Utilisateur"> | Date | string
    updatedAt?: DateTimeFilter<"Utilisateur"> | Date | string
    prenom?: StringFilter<"Utilisateur"> | string
    nom?: StringFilter<"Utilisateur"> | string
    dateNaissance?: DateTimeNullableFilter<"Utilisateur"> | Date | string | null
    lieuNaissance?: StringNullableFilter<"Utilisateur"> | string | null
    cni?: StringNullableFilter<"Utilisateur"> | string | null
    genre?: EnumGenreFilter<"Utilisateur"> | $Enums.Genre
    nationalite?: StringNullableFilter<"Utilisateur"> | string | null
    groupeSanguin?: EnumGroupeSanguinNullableFilter<"Utilisateur"> | $Enums.GroupeSanguin | null
    etablissementId?: IntNullableFilter<"Utilisateur"> | number | null
    statutCompte?: StringNullableFilter<"Utilisateur"> | string | null
    roles?: EnumRoleNullableListFilter<"Utilisateur">
    contactId?: IntNullableFilter<"Utilisateur"> | number | null
    adresseId?: IntNullableFilter<"Utilisateur"> | number | null
    accountId?: IntNullableFilter<"Utilisateur"> | number | null
  }

  export type UtilisateurCreateWithoutAdresseInput = {
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    accountId?: number | null
    contact?: ContactCreateNestedOneWithoutUtilisateursInput
    etablissement?: EtablissementCreateNestedOneWithoutUtilisateursInput
    etudiant?: EtudiantCreateNestedOneWithoutProfileInput
    permissions?: PermissionCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurUncheckedCreateWithoutAdresseInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    etablissementId?: number | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    contactId?: number | null
    accountId?: number | null
    etudiant?: EtudiantUncheckedCreateNestedOneWithoutProfileInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurCreateOrConnectWithoutAdresseInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput>
  }

  export type UtilisateurCreateManyAdresseInputEnvelope = {
    data: UtilisateurCreateManyAdresseInput | UtilisateurCreateManyAdresseInput[]
    skipDuplicates?: boolean
  }

  export type EtablissementCreateWithoutAdresseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    contact?: ContactCreateNestedOneWithoutEtablissementsInput
    utilisateurs?: UtilisateurCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseCreateNestedManyWithoutEtablissementInput
    salle?: SalleCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementUncheckedCreateWithoutAdresseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    contactId?: number | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineUncheckedCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseUncheckedCreateNestedManyWithoutEtablissementInput
    salle?: SalleUncheckedCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementCreateOrConnectWithoutAdresseInput = {
    where: EtablissementWhereUniqueInput
    create: XOR<EtablissementCreateWithoutAdresseInput, EtablissementUncheckedCreateWithoutAdresseInput>
  }

  export type EtablissementCreateManyAdresseInputEnvelope = {
    data: EtablissementCreateManyAdresseInput | EtablissementCreateManyAdresseInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurUpsertWithWhereUniqueWithoutAdresseInput = {
    where: UtilisateurWhereUniqueInput
    update: XOR<UtilisateurUpdateWithoutAdresseInput, UtilisateurUncheckedUpdateWithoutAdresseInput>
    create: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput>
  }

  export type UtilisateurUpdateWithWhereUniqueWithoutAdresseInput = {
    where: UtilisateurWhereUniqueInput
    data: XOR<UtilisateurUpdateWithoutAdresseInput, UtilisateurUncheckedUpdateWithoutAdresseInput>
  }

  export type UtilisateurUpdateManyWithWhereWithoutAdresseInput = {
    where: UtilisateurScalarWhereInput
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyWithoutAdresseInput>
  }

  export type EtablissementUpsertWithWhereUniqueWithoutAdresseInput = {
    where: EtablissementWhereUniqueInput
    update: XOR<EtablissementUpdateWithoutAdresseInput, EtablissementUncheckedUpdateWithoutAdresseInput>
    create: XOR<EtablissementCreateWithoutAdresseInput, EtablissementUncheckedCreateWithoutAdresseInput>
  }

  export type EtablissementUpdateWithWhereUniqueWithoutAdresseInput = {
    where: EtablissementWhereUniqueInput
    data: XOR<EtablissementUpdateWithoutAdresseInput, EtablissementUncheckedUpdateWithoutAdresseInput>
  }

  export type EtablissementUpdateManyWithWhereWithoutAdresseInput = {
    where: EtablissementScalarWhereInput
    data: XOR<EtablissementUpdateManyMutationInput, EtablissementUncheckedUpdateManyWithoutAdresseInput>
  }

  export type EtablissementScalarWhereInput = {
    AND?: EtablissementScalarWhereInput | EtablissementScalarWhereInput[]
    OR?: EtablissementScalarWhereInput[]
    NOT?: EtablissementScalarWhereInput | EtablissementScalarWhereInput[]
    id?: IntFilter<"Etablissement"> | number
    createdAt?: DateTimeFilter<"Etablissement"> | Date | string
    updatedAt?: DateTimeFilter<"Etablissement"> | Date | string
    nom?: StringFilter<"Etablissement"> | string
    matricule?: StringNullableFilter<"Etablissement"> | string | null
    sigle?: StringNullableFilter<"Etablissement"> | string | null
    dateCreation?: DateTimeNullableFilter<"Etablissement"> | Date | string | null
    logo?: StringNullableFilter<"Etablissement"> | string | null
    anneeEnCours?: StringNullableFilter<"Etablissement"> | string | null
    adresseId?: IntNullableFilter<"Etablissement"> | number | null
    contactId?: IntNullableFilter<"Etablissement"> | number | null
  }

  export type ContactCreateWithoutReseauxSociauxInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    telephone: string
    fix?: string | null
    fax?: string | null
    email: string
    siteWeb?: string | null
    utilisateurs?: UtilisateurCreateNestedManyWithoutContactInput
    etablissements?: EtablissementCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutReseauxSociauxInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    telephone: string
    fix?: string | null
    fax?: string | null
    email: string
    siteWeb?: string | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutContactInput
    etablissements?: EtablissementUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutReseauxSociauxInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutReseauxSociauxInput, ContactUncheckedCreateWithoutReseauxSociauxInput>
  }

  export type ContactUpsertWithoutReseauxSociauxInput = {
    update: XOR<ContactUpdateWithoutReseauxSociauxInput, ContactUncheckedUpdateWithoutReseauxSociauxInput>
    create: XOR<ContactCreateWithoutReseauxSociauxInput, ContactUncheckedCreateWithoutReseauxSociauxInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutReseauxSociauxInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutReseauxSociauxInput, ContactUncheckedUpdateWithoutReseauxSociauxInput>
  }

  export type ContactUpdateWithoutReseauxSociauxInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurs?: UtilisateurUpdateManyWithoutContactNestedInput
    etablissements?: EtablissementUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutReseauxSociauxInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutContactNestedInput
    etablissements?: EtablissementUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ReseauSocialCreateWithoutContactInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    username: string
    url: string
  }

  export type ReseauSocialUncheckedCreateWithoutContactInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    username: string
    url: string
  }

  export type ReseauSocialCreateOrConnectWithoutContactInput = {
    where: ReseauSocialWhereUniqueInput
    create: XOR<ReseauSocialCreateWithoutContactInput, ReseauSocialUncheckedCreateWithoutContactInput>
  }

  export type ReseauSocialCreateManyContactInputEnvelope = {
    data: ReseauSocialCreateManyContactInput | ReseauSocialCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurCreateWithoutContactInput = {
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    accountId?: number | null
    adresse?: AdresseCreateNestedOneWithoutUtilisateursInput
    etablissement?: EtablissementCreateNestedOneWithoutUtilisateursInput
    etudiant?: EtudiantCreateNestedOneWithoutProfileInput
    permissions?: PermissionCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurUncheckedCreateWithoutContactInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    etablissementId?: number | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    adresseId?: number | null
    accountId?: number | null
    etudiant?: EtudiantUncheckedCreateNestedOneWithoutProfileInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurCreateOrConnectWithoutContactInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput>
  }

  export type UtilisateurCreateManyContactInputEnvelope = {
    data: UtilisateurCreateManyContactInput | UtilisateurCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type EtablissementCreateWithoutContactInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresse?: AdresseCreateNestedOneWithoutEtablissementsInput
    utilisateurs?: UtilisateurCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseCreateNestedManyWithoutEtablissementInput
    salle?: SalleCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementUncheckedCreateWithoutContactInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresseId?: number | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineUncheckedCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseUncheckedCreateNestedManyWithoutEtablissementInput
    salle?: SalleUncheckedCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementCreateOrConnectWithoutContactInput = {
    where: EtablissementWhereUniqueInput
    create: XOR<EtablissementCreateWithoutContactInput, EtablissementUncheckedCreateWithoutContactInput>
  }

  export type EtablissementCreateManyContactInputEnvelope = {
    data: EtablissementCreateManyContactInput | EtablissementCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ReseauSocialUpsertWithWhereUniqueWithoutContactInput = {
    where: ReseauSocialWhereUniqueInput
    update: XOR<ReseauSocialUpdateWithoutContactInput, ReseauSocialUncheckedUpdateWithoutContactInput>
    create: XOR<ReseauSocialCreateWithoutContactInput, ReseauSocialUncheckedCreateWithoutContactInput>
  }

  export type ReseauSocialUpdateWithWhereUniqueWithoutContactInput = {
    where: ReseauSocialWhereUniqueInput
    data: XOR<ReseauSocialUpdateWithoutContactInput, ReseauSocialUncheckedUpdateWithoutContactInput>
  }

  export type ReseauSocialUpdateManyWithWhereWithoutContactInput = {
    where: ReseauSocialScalarWhereInput
    data: XOR<ReseauSocialUpdateManyMutationInput, ReseauSocialUncheckedUpdateManyWithoutContactInput>
  }

  export type ReseauSocialScalarWhereInput = {
    AND?: ReseauSocialScalarWhereInput | ReseauSocialScalarWhereInput[]
    OR?: ReseauSocialScalarWhereInput[]
    NOT?: ReseauSocialScalarWhereInput | ReseauSocialScalarWhereInput[]
    id?: IntFilter<"ReseauSocial"> | number
    createdAt?: DateTimeFilter<"ReseauSocial"> | Date | string
    updatedAt?: DateTimeFilter<"ReseauSocial"> | Date | string
    nom?: StringFilter<"ReseauSocial"> | string
    username?: StringFilter<"ReseauSocial"> | string
    url?: StringFilter<"ReseauSocial"> | string
    contactId?: IntNullableFilter<"ReseauSocial"> | number | null
  }

  export type UtilisateurUpsertWithWhereUniqueWithoutContactInput = {
    where: UtilisateurWhereUniqueInput
    update: XOR<UtilisateurUpdateWithoutContactInput, UtilisateurUncheckedUpdateWithoutContactInput>
    create: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput>
  }

  export type UtilisateurUpdateWithWhereUniqueWithoutContactInput = {
    where: UtilisateurWhereUniqueInput
    data: XOR<UtilisateurUpdateWithoutContactInput, UtilisateurUncheckedUpdateWithoutContactInput>
  }

  export type UtilisateurUpdateManyWithWhereWithoutContactInput = {
    where: UtilisateurScalarWhereInput
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyWithoutContactInput>
  }

  export type EtablissementUpsertWithWhereUniqueWithoutContactInput = {
    where: EtablissementWhereUniqueInput
    update: XOR<EtablissementUpdateWithoutContactInput, EtablissementUncheckedUpdateWithoutContactInput>
    create: XOR<EtablissementCreateWithoutContactInput, EtablissementUncheckedCreateWithoutContactInput>
  }

  export type EtablissementUpdateWithWhereUniqueWithoutContactInput = {
    where: EtablissementWhereUniqueInput
    data: XOR<EtablissementUpdateWithoutContactInput, EtablissementUncheckedUpdateWithoutContactInput>
  }

  export type EtablissementUpdateManyWithWhereWithoutContactInput = {
    where: EtablissementScalarWhereInput
    data: XOR<EtablissementUpdateManyMutationInput, EtablissementUncheckedUpdateManyWithoutContactInput>
  }

  export type UtilisateurCreateWithoutEtudiantInput = {
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    accountId?: number | null
    contact?: ContactCreateNestedOneWithoutUtilisateursInput
    adresse?: AdresseCreateNestedOneWithoutUtilisateursInput
    etablissement?: EtablissementCreateNestedOneWithoutUtilisateursInput
    permissions?: PermissionCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurUncheckedCreateWithoutEtudiantInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    etablissementId?: number | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    contactId?: number | null
    adresseId?: number | null
    accountId?: number | null
    permissions?: PermissionUncheckedCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurCreateOrConnectWithoutEtudiantInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutEtudiantInput, UtilisateurUncheckedCreateWithoutEtudiantInput>
  }

  export type InscriptionCreateWithoutEtudiantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    diplome: DiplomeCreateNestedOneWithoutInscriptionsInput
    classe: ClasseCreateNestedOneWithoutInscriptionsInput
  }

  export type InscriptionUncheckedCreateWithoutEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    diplomeId: number
    classeId: number
  }

  export type InscriptionCreateOrConnectWithoutEtudiantInput = {
    where: InscriptionWhereUniqueInput
    create: XOR<InscriptionCreateWithoutEtudiantInput, InscriptionUncheckedCreateWithoutEtudiantInput>
  }

  export type InscriptionCreateManyEtudiantInputEnvelope = {
    data: InscriptionCreateManyEtudiantInput | InscriptionCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type NoteEtudiantCreateWithoutEtudiantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    note: number
    evaluationEtudiant?: EvaluationEtudiantsCreateNestedOneWithoutNoteEtudiantInput
  }

  export type NoteEtudiantUncheckedCreateWithoutEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note: number
    evaluationEtudiantId?: number | null
  }

  export type NoteEtudiantCreateOrConnectWithoutEtudiantInput = {
    where: NoteEtudiantWhereUniqueInput
    create: XOR<NoteEtudiantCreateWithoutEtudiantInput, NoteEtudiantUncheckedCreateWithoutEtudiantInput>
  }

  export type NoteEtudiantCreateManyEtudiantInputEnvelope = {
    data: NoteEtudiantCreateManyEtudiantInput | NoteEtudiantCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type FeuillePresenceCreateWithoutEtudiantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    cours: CoursCreateNestedOneWithoutFeuillePresencesInput
  }

  export type FeuillePresenceUncheckedCreateWithoutEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    coursId: number
  }

  export type FeuillePresenceCreateOrConnectWithoutEtudiantInput = {
    where: FeuillePresenceWhereUniqueInput
    create: XOR<FeuillePresenceCreateWithoutEtudiantInput, FeuillePresenceUncheckedCreateWithoutEtudiantInput>
  }

  export type FeuillePresenceCreateManyEtudiantInputEnvelope = {
    data: FeuillePresenceCreateManyEtudiantInput | FeuillePresenceCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type PaiementCreateWithoutEtudiantInput = {
    montant: number
    datePaiement: Date | string
    methodePaiement: string
    referencePaiement: string
    typeFrais: string
    statutPaiement: string
  }

  export type PaiementUncheckedCreateWithoutEtudiantInput = {
    id?: number
    montant: number
    datePaiement: Date | string
    methodePaiement: string
    referencePaiement: string
    typeFrais: string
    statutPaiement: string
  }

  export type PaiementCreateOrConnectWithoutEtudiantInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutEtudiantInput, PaiementUncheckedCreateWithoutEtudiantInput>
  }

  export type PaiementCreateManyEtudiantInputEnvelope = {
    data: PaiementCreateManyEtudiantInput | PaiementCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurUpsertWithoutEtudiantInput = {
    update: XOR<UtilisateurUpdateWithoutEtudiantInput, UtilisateurUncheckedUpdateWithoutEtudiantInput>
    create: XOR<UtilisateurCreateWithoutEtudiantInput, UtilisateurUncheckedCreateWithoutEtudiantInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutEtudiantInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutEtudiantInput, UtilisateurUncheckedUpdateWithoutEtudiantInput>
  }

  export type UtilisateurUpdateWithoutEtudiantInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: ContactUpdateOneWithoutUtilisateursNestedInput
    adresse?: AdresseUpdateOneWithoutUtilisateursNestedInput
    etablissement?: EtablissementUpdateOneWithoutUtilisateursNestedInput
    permissions?: PermissionUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    permissions?: PermissionUncheckedUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type InscriptionUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: InscriptionWhereUniqueInput
    update: XOR<InscriptionUpdateWithoutEtudiantInput, InscriptionUncheckedUpdateWithoutEtudiantInput>
    create: XOR<InscriptionCreateWithoutEtudiantInput, InscriptionUncheckedCreateWithoutEtudiantInput>
  }

  export type InscriptionUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: InscriptionWhereUniqueInput
    data: XOR<InscriptionUpdateWithoutEtudiantInput, InscriptionUncheckedUpdateWithoutEtudiantInput>
  }

  export type InscriptionUpdateManyWithWhereWithoutEtudiantInput = {
    where: InscriptionScalarWhereInput
    data: XOR<InscriptionUpdateManyMutationInput, InscriptionUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type InscriptionScalarWhereInput = {
    AND?: InscriptionScalarWhereInput | InscriptionScalarWhereInput[]
    OR?: InscriptionScalarWhereInput[]
    NOT?: InscriptionScalarWhereInput | InscriptionScalarWhereInput[]
    id?: IntFilter<"Inscription"> | number
    createdAt?: DateTimeFilter<"Inscription"> | Date | string
    updatedAt?: DateTimeFilter<"Inscription"> | Date | string
    reference?: StringFilter<"Inscription"> | string
    premiereInscription?: BoolFilter<"Inscription"> | boolean
    dernierDiplome?: StringNullableFilter<"Inscription"> | string | null
    autreEtablissement?: StringNullableFilter<"Inscription"> | string | null
    activiteProfessionnel?: StringNullableFilter<"Inscription"> | string | null
    niveau?: StringNullableFilter<"Inscription"> | string | null
    statut?: StringNullableFilter<"Inscription"> | string | null
    diplomeId?: IntFilter<"Inscription"> | number
    etudiantId?: IntFilter<"Inscription"> | number
    classeId?: IntFilter<"Inscription"> | number
  }

  export type NoteEtudiantUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: NoteEtudiantWhereUniqueInput
    update: XOR<NoteEtudiantUpdateWithoutEtudiantInput, NoteEtudiantUncheckedUpdateWithoutEtudiantInput>
    create: XOR<NoteEtudiantCreateWithoutEtudiantInput, NoteEtudiantUncheckedCreateWithoutEtudiantInput>
  }

  export type NoteEtudiantUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: NoteEtudiantWhereUniqueInput
    data: XOR<NoteEtudiantUpdateWithoutEtudiantInput, NoteEtudiantUncheckedUpdateWithoutEtudiantInput>
  }

  export type NoteEtudiantUpdateManyWithWhereWithoutEtudiantInput = {
    where: NoteEtudiantScalarWhereInput
    data: XOR<NoteEtudiantUpdateManyMutationInput, NoteEtudiantUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type NoteEtudiantScalarWhereInput = {
    AND?: NoteEtudiantScalarWhereInput | NoteEtudiantScalarWhereInput[]
    OR?: NoteEtudiantScalarWhereInput[]
    NOT?: NoteEtudiantScalarWhereInput | NoteEtudiantScalarWhereInput[]
    id?: IntFilter<"NoteEtudiant"> | number
    createdAt?: DateTimeFilter<"NoteEtudiant"> | Date | string
    updatedAt?: DateTimeFilter<"NoteEtudiant"> | Date | string
    note?: FloatFilter<"NoteEtudiant"> | number
    evaluationEtudiantId?: IntNullableFilter<"NoteEtudiant"> | number | null
    etudiantId?: IntFilter<"NoteEtudiant"> | number
  }

  export type FeuillePresenceUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: FeuillePresenceWhereUniqueInput
    update: XOR<FeuillePresenceUpdateWithoutEtudiantInput, FeuillePresenceUncheckedUpdateWithoutEtudiantInput>
    create: XOR<FeuillePresenceCreateWithoutEtudiantInput, FeuillePresenceUncheckedCreateWithoutEtudiantInput>
  }

  export type FeuillePresenceUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: FeuillePresenceWhereUniqueInput
    data: XOR<FeuillePresenceUpdateWithoutEtudiantInput, FeuillePresenceUncheckedUpdateWithoutEtudiantInput>
  }

  export type FeuillePresenceUpdateManyWithWhereWithoutEtudiantInput = {
    where: FeuillePresenceScalarWhereInput
    data: XOR<FeuillePresenceUpdateManyMutationInput, FeuillePresenceUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type FeuillePresenceScalarWhereInput = {
    AND?: FeuillePresenceScalarWhereInput | FeuillePresenceScalarWhereInput[]
    OR?: FeuillePresenceScalarWhereInput[]
    NOT?: FeuillePresenceScalarWhereInput | FeuillePresenceScalarWhereInput[]
    id?: IntFilter<"FeuillePresence"> | number
    createdAt?: DateTimeFilter<"FeuillePresence"> | Date | string
    updatedAt?: DateTimeFilter<"FeuillePresence"> | Date | string
    date?: DateTimeFilter<"FeuillePresence"> | Date | string
    heureDebut?: DateTimeFilter<"FeuillePresence"> | Date | string
    heureFin?: DateTimeFilter<"FeuillePresence"> | Date | string
    coursId?: IntFilter<"FeuillePresence"> | number
    etudiantId?: IntNullableFilter<"FeuillePresence"> | number | null
  }

  export type PaiementUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutEtudiantInput, PaiementUncheckedUpdateWithoutEtudiantInput>
    create: XOR<PaiementCreateWithoutEtudiantInput, PaiementUncheckedCreateWithoutEtudiantInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutEtudiantInput, PaiementUncheckedUpdateWithoutEtudiantInput>
  }

  export type PaiementUpdateManyWithWhereWithoutEtudiantInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type PaiementScalarWhereInput = {
    AND?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    OR?: PaiementScalarWhereInput[]
    NOT?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    id?: IntFilter<"Paiement"> | number
    etudiantId?: IntFilter<"Paiement"> | number
    montant?: FloatFilter<"Paiement"> | number
    datePaiement?: DateTimeFilter<"Paiement"> | Date | string
    methodePaiement?: StringFilter<"Paiement"> | string
    referencePaiement?: StringFilter<"Paiement"> | string
    typeFrais?: StringFilter<"Paiement"> | string
    statutPaiement?: StringFilter<"Paiement"> | string
  }

  export type UtilisateurCreateWithoutProfesseurInput = {
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    accountId?: number | null
    contact?: ContactCreateNestedOneWithoutUtilisateursInput
    adresse?: AdresseCreateNestedOneWithoutUtilisateursInput
    etablissement?: EtablissementCreateNestedOneWithoutUtilisateursInput
    etudiant?: EtudiantCreateNestedOneWithoutProfileInput
    permissions?: PermissionCreateNestedManyWithoutUtilisateursInput
  }

  export type UtilisateurUncheckedCreateWithoutProfesseurInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    etablissementId?: number | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    contactId?: number | null
    adresseId?: number | null
    accountId?: number | null
    etudiant?: EtudiantUncheckedCreateNestedOneWithoutProfileInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutUtilisateursInput
  }

  export type UtilisateurCreateOrConnectWithoutProfesseurInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutProfesseurInput, UtilisateurUncheckedCreateWithoutProfesseurInput>
  }

  export type CoursCreateWithoutProfesseurInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiere?: MatiereCreateNestedOneWithoutCoursInput
    salle?: SalleCreateNestedOneWithoutCoursInput
    classe?: ClasseCreateNestedOneWithoutCoursInput
    evaluationEtudiant?: EvaluationEtudiantsCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutCoursInput
  }

  export type CoursUncheckedCreateWithoutProfesseurInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    salleId?: number | null
    classeId?: number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutCoursInput
  }

  export type CoursCreateOrConnectWithoutProfesseurInput = {
    where: CoursWhereUniqueInput
    create: XOR<CoursCreateWithoutProfesseurInput, CoursUncheckedCreateWithoutProfesseurInput>
  }

  export type CoursCreateManyProfesseurInputEnvelope = {
    data: CoursCreateManyProfesseurInput | CoursCreateManyProfesseurInput[]
    skipDuplicates?: boolean
  }

  export type EmploiDuTempsCreateWithoutProfesseurInput = {
    dateDebut: Date | string
    dateFin: Date | string
    cours: CoursCreateNestedOneWithoutEmploiDuTempsInput
    classe: ClasseCreateNestedOneWithoutEmploiDuTempsInput
    salle: SalleCreateNestedOneWithoutEmploiDuTempsInput
  }

  export type EmploiDuTempsUncheckedCreateWithoutProfesseurInput = {
    id?: number
    coursId: number
    classeId: number
    salleId: number
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type EmploiDuTempsCreateOrConnectWithoutProfesseurInput = {
    where: EmploiDuTempsWhereUniqueInput
    create: XOR<EmploiDuTempsCreateWithoutProfesseurInput, EmploiDuTempsUncheckedCreateWithoutProfesseurInput>
  }

  export type EmploiDuTempsCreateManyProfesseurInputEnvelope = {
    data: EmploiDuTempsCreateManyProfesseurInput | EmploiDuTempsCreateManyProfesseurInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurUpsertWithoutProfesseurInput = {
    update: XOR<UtilisateurUpdateWithoutProfesseurInput, UtilisateurUncheckedUpdateWithoutProfesseurInput>
    create: XOR<UtilisateurCreateWithoutProfesseurInput, UtilisateurUncheckedCreateWithoutProfesseurInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutProfesseurInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutProfesseurInput, UtilisateurUncheckedUpdateWithoutProfesseurInput>
  }

  export type UtilisateurUpdateWithoutProfesseurInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: ContactUpdateOneWithoutUtilisateursNestedInput
    adresse?: AdresseUpdateOneWithoutUtilisateursNestedInput
    etablissement?: EtablissementUpdateOneWithoutUtilisateursNestedInput
    etudiant?: EtudiantUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUpdateManyWithoutUtilisateursNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutProfesseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    etudiant?: EtudiantUncheckedUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutUtilisateursNestedInput
  }

  export type CoursUpsertWithWhereUniqueWithoutProfesseurInput = {
    where: CoursWhereUniqueInput
    update: XOR<CoursUpdateWithoutProfesseurInput, CoursUncheckedUpdateWithoutProfesseurInput>
    create: XOR<CoursCreateWithoutProfesseurInput, CoursUncheckedCreateWithoutProfesseurInput>
  }

  export type CoursUpdateWithWhereUniqueWithoutProfesseurInput = {
    where: CoursWhereUniqueInput
    data: XOR<CoursUpdateWithoutProfesseurInput, CoursUncheckedUpdateWithoutProfesseurInput>
  }

  export type CoursUpdateManyWithWhereWithoutProfesseurInput = {
    where: CoursScalarWhereInput
    data: XOR<CoursUpdateManyMutationInput, CoursUncheckedUpdateManyWithoutProfesseurInput>
  }

  export type CoursScalarWhereInput = {
    AND?: CoursScalarWhereInput | CoursScalarWhereInput[]
    OR?: CoursScalarWhereInput[]
    NOT?: CoursScalarWhereInput | CoursScalarWhereInput[]
    id?: IntFilter<"Cours"> | number
    createdAt?: DateTimeFilter<"Cours"> | Date | string
    updatedAt?: DateTimeFilter<"Cours"> | Date | string
    nom?: StringFilter<"Cours"> | string
    description?: StringNullableFilter<"Cours"> | string | null
    dateDebut?: DateTimeFilter<"Cours"> | Date | string
    dateFin?: DateTimeFilter<"Cours"> | Date | string
    heureDebut?: DateTimeFilter<"Cours"> | Date | string
    heureFin?: DateTimeFilter<"Cours"> | Date | string
    matiereId?: IntNullableFilter<"Cours"> | number | null
    salleId?: IntNullableFilter<"Cours"> | number | null
    classeId?: IntNullableFilter<"Cours"> | number | null
    professeurId?: IntNullableFilter<"Cours"> | number | null
  }

  export type EmploiDuTempsUpsertWithWhereUniqueWithoutProfesseurInput = {
    where: EmploiDuTempsWhereUniqueInput
    update: XOR<EmploiDuTempsUpdateWithoutProfesseurInput, EmploiDuTempsUncheckedUpdateWithoutProfesseurInput>
    create: XOR<EmploiDuTempsCreateWithoutProfesseurInput, EmploiDuTempsUncheckedCreateWithoutProfesseurInput>
  }

  export type EmploiDuTempsUpdateWithWhereUniqueWithoutProfesseurInput = {
    where: EmploiDuTempsWhereUniqueInput
    data: XOR<EmploiDuTempsUpdateWithoutProfesseurInput, EmploiDuTempsUncheckedUpdateWithoutProfesseurInput>
  }

  export type EmploiDuTempsUpdateManyWithWhereWithoutProfesseurInput = {
    where: EmploiDuTempsScalarWhereInput
    data: XOR<EmploiDuTempsUpdateManyMutationInput, EmploiDuTempsUncheckedUpdateManyWithoutProfesseurInput>
  }

  export type EmploiDuTempsScalarWhereInput = {
    AND?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
    OR?: EmploiDuTempsScalarWhereInput[]
    NOT?: EmploiDuTempsScalarWhereInput | EmploiDuTempsScalarWhereInput[]
    id?: IntFilter<"EmploiDuTemps"> | number
    coursId?: IntFilter<"EmploiDuTemps"> | number
    classeId?: IntFilter<"EmploiDuTemps"> | number
    professeurId?: IntNullableFilter<"EmploiDuTemps"> | number | null
    salleId?: IntFilter<"EmploiDuTemps"> | number
    dateDebut?: DateTimeFilter<"EmploiDuTemps"> | Date | string
    dateFin?: DateTimeFilter<"EmploiDuTemps"> | Date | string
  }

  export type DiplomeCreateWithoutInscriptionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    finalite: string
    entite: string
    habilitation: string
    partenaires?: DiplomeCreatepartenairesInput | string[]
    dateCreation: Date | string
    dateHabilitation: Date | string
    dateEcheance: Date | string
    duree: number
    specialite?: SpecialiteCreateNestedOneWithoutDiplomeInput
  }

  export type DiplomeUncheckedCreateWithoutInscriptionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    finalite: string
    entite: string
    habilitation: string
    partenaires?: DiplomeCreatepartenairesInput | string[]
    dateCreation: Date | string
    dateHabilitation: Date | string
    dateEcheance: Date | string
    duree: number
    specialiteId?: number | null
  }

  export type DiplomeCreateOrConnectWithoutInscriptionsInput = {
    where: DiplomeWhereUniqueInput
    create: XOR<DiplomeCreateWithoutInscriptionsInput, DiplomeUncheckedCreateWithoutInscriptionsInput>
  }

  export type EtudiantCreateWithoutInscriptionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    feuillePresencesId?: number | null
    profile: UtilisateurCreateNestedOneWithoutEtudiantInput
    notes?: NoteEtudiantCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutInscriptionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    profileId: number
    feuillePresencesId?: number | null
    notes?: NoteEtudiantUncheckedCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutInscriptionsInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutInscriptionsInput, EtudiantUncheckedCreateWithoutInscriptionsInput>
  }

  export type ClasseCreateWithoutInscriptionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissement: EtablissementCreateNestedOneWithoutClassesInput
    semestres?: SemestreCreateNestedManyWithoutClasseInput
    specialite: SpecialiteCreateNestedOneWithoutClasseInput
    Cours?: CoursCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutClasseInput
    AnneeScolaire?: AnneeScolaireCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateWithoutInscriptionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    specialiteId: number
    anneeScolaireId?: number | null
    semestres?: SemestreUncheckedCreateNestedManyWithoutClasseInput
    Cours?: CoursUncheckedCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutInscriptionsInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutInscriptionsInput, ClasseUncheckedCreateWithoutInscriptionsInput>
  }

  export type DiplomeUpsertWithoutInscriptionsInput = {
    update: XOR<DiplomeUpdateWithoutInscriptionsInput, DiplomeUncheckedUpdateWithoutInscriptionsInput>
    create: XOR<DiplomeCreateWithoutInscriptionsInput, DiplomeUncheckedCreateWithoutInscriptionsInput>
    where?: DiplomeWhereInput
  }

  export type DiplomeUpdateToOneWithWhereWithoutInscriptionsInput = {
    where?: DiplomeWhereInput
    data: XOR<DiplomeUpdateWithoutInscriptionsInput, DiplomeUncheckedUpdateWithoutInscriptionsInput>
  }

  export type DiplomeUpdateWithoutInscriptionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    finalite?: StringFieldUpdateOperationsInput | string
    entite?: StringFieldUpdateOperationsInput | string
    habilitation?: StringFieldUpdateOperationsInput | string
    partenaires?: DiplomeUpdatepartenairesInput | string[]
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHabilitation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    specialite?: SpecialiteUpdateOneWithoutDiplomeNestedInput
  }

  export type DiplomeUncheckedUpdateWithoutInscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    finalite?: StringFieldUpdateOperationsInput | string
    entite?: StringFieldUpdateOperationsInput | string
    habilitation?: StringFieldUpdateOperationsInput | string
    partenaires?: DiplomeUpdatepartenairesInput | string[]
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHabilitation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    specialiteId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EtudiantUpsertWithoutInscriptionsInput = {
    update: XOR<EtudiantUpdateWithoutInscriptionsInput, EtudiantUncheckedUpdateWithoutInscriptionsInput>
    create: XOR<EtudiantCreateWithoutInscriptionsInput, EtudiantUncheckedCreateWithoutInscriptionsInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutInscriptionsInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutInscriptionsInput, EtudiantUncheckedUpdateWithoutInscriptionsInput>
  }

  export type EtudiantUpdateWithoutInscriptionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: UtilisateurUpdateOneRequiredWithoutEtudiantNestedInput
    notes?: NoteEtudiantUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutInscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    profileId?: IntFieldUpdateOperationsInput | number
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NoteEtudiantUncheckedUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type ClasseUpsertWithoutInscriptionsInput = {
    update: XOR<ClasseUpdateWithoutInscriptionsInput, ClasseUncheckedUpdateWithoutInscriptionsInput>
    create: XOR<ClasseCreateWithoutInscriptionsInput, ClasseUncheckedCreateWithoutInscriptionsInput>
    where?: ClasseWhereInput
  }

  export type ClasseUpdateToOneWithWhereWithoutInscriptionsInput = {
    where?: ClasseWhereInput
    data: XOR<ClasseUpdateWithoutInscriptionsInput, ClasseUncheckedUpdateWithoutInscriptionsInput>
  }

  export type ClasseUpdateWithoutInscriptionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissement?: EtablissementUpdateOneRequiredWithoutClassesNestedInput
    semestres?: SemestreUpdateManyWithoutClasseNestedInput
    specialite?: SpecialiteUpdateOneRequiredWithoutClasseNestedInput
    Cours?: CoursUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutClasseNestedInput
    AnneeScolaire?: AnneeScolaireUpdateOneWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateWithoutInscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
    semestres?: SemestreUncheckedUpdateManyWithoutClasseNestedInput
    Cours?: CoursUncheckedUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type EtablissementCreateWithoutDomainesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresse?: AdresseCreateNestedOneWithoutEtablissementsInput
    contact?: ContactCreateNestedOneWithoutEtablissementsInput
    utilisateurs?: UtilisateurCreateNestedManyWithoutEtablissementInput
    classes?: ClasseCreateNestedManyWithoutEtablissementInput
    salle?: SalleCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementUncheckedCreateWithoutDomainesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresseId?: number | null
    contactId?: number | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutEtablissementInput
    classes?: ClasseUncheckedCreateNestedManyWithoutEtablissementInput
    salle?: SalleUncheckedCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementCreateOrConnectWithoutDomainesInput = {
    where: EtablissementWhereUniqueInput
    create: XOR<EtablissementCreateWithoutDomainesInput, EtablissementUncheckedCreateWithoutDomainesInput>
  }

  export type MentionCreateWithoutDomaineInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    specialites?: SpecialiteCreateNestedManyWithoutMentionInput
  }

  export type MentionUncheckedCreateWithoutDomaineInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    specialites?: SpecialiteUncheckedCreateNestedManyWithoutMentionInput
  }

  export type MentionCreateOrConnectWithoutDomaineInput = {
    where: MentionWhereUniqueInput
    create: XOR<MentionCreateWithoutDomaineInput, MentionUncheckedCreateWithoutDomaineInput>
  }

  export type MentionCreateManyDomaineInputEnvelope = {
    data: MentionCreateManyDomaineInput | MentionCreateManyDomaineInput[]
    skipDuplicates?: boolean
  }

  export type EtablissementUpsertWithWhereUniqueWithoutDomainesInput = {
    where: EtablissementWhereUniqueInput
    update: XOR<EtablissementUpdateWithoutDomainesInput, EtablissementUncheckedUpdateWithoutDomainesInput>
    create: XOR<EtablissementCreateWithoutDomainesInput, EtablissementUncheckedCreateWithoutDomainesInput>
  }

  export type EtablissementUpdateWithWhereUniqueWithoutDomainesInput = {
    where: EtablissementWhereUniqueInput
    data: XOR<EtablissementUpdateWithoutDomainesInput, EtablissementUncheckedUpdateWithoutDomainesInput>
  }

  export type EtablissementUpdateManyWithWhereWithoutDomainesInput = {
    where: EtablissementScalarWhereInput
    data: XOR<EtablissementUpdateManyMutationInput, EtablissementUncheckedUpdateManyWithoutDomainesInput>
  }

  export type MentionUpsertWithWhereUniqueWithoutDomaineInput = {
    where: MentionWhereUniqueInput
    update: XOR<MentionUpdateWithoutDomaineInput, MentionUncheckedUpdateWithoutDomaineInput>
    create: XOR<MentionCreateWithoutDomaineInput, MentionUncheckedCreateWithoutDomaineInput>
  }

  export type MentionUpdateWithWhereUniqueWithoutDomaineInput = {
    where: MentionWhereUniqueInput
    data: XOR<MentionUpdateWithoutDomaineInput, MentionUncheckedUpdateWithoutDomaineInput>
  }

  export type MentionUpdateManyWithWhereWithoutDomaineInput = {
    where: MentionScalarWhereInput
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyWithoutDomaineInput>
  }

  export type MentionScalarWhereInput = {
    AND?: MentionScalarWhereInput | MentionScalarWhereInput[]
    OR?: MentionScalarWhereInput[]
    NOT?: MentionScalarWhereInput | MentionScalarWhereInput[]
    id?: IntFilter<"Mention"> | number
    createdAt?: DateTimeFilter<"Mention"> | Date | string
    updatedAt?: DateTimeFilter<"Mention"> | Date | string
    nom?: StringFilter<"Mention"> | string
    slug?: StringNullableFilter<"Mention"> | string | null
    domaineId?: IntNullableFilter<"Mention"> | number | null
  }

  export type DomaineCreateWithoutMentionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    etablissements?: EtablissementCreateNestedManyWithoutDomainesInput
  }

  export type DomaineUncheckedCreateWithoutMentionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    etablissements?: EtablissementUncheckedCreateNestedManyWithoutDomainesInput
  }

  export type DomaineCreateOrConnectWithoutMentionsInput = {
    where: DomaineWhereUniqueInput
    create: XOR<DomaineCreateWithoutMentionsInput, DomaineUncheckedCreateWithoutMentionsInput>
  }

  export type SpecialiteCreateWithoutMentionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    Classe?: ClasseCreateNestedManyWithoutSpecialiteInput
    Diplome?: DiplomeCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteUncheckedCreateWithoutMentionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    Classe?: ClasseUncheckedCreateNestedManyWithoutSpecialiteInput
    Diplome?: DiplomeUncheckedCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteCreateOrConnectWithoutMentionInput = {
    where: SpecialiteWhereUniqueInput
    create: XOR<SpecialiteCreateWithoutMentionInput, SpecialiteUncheckedCreateWithoutMentionInput>
  }

  export type SpecialiteCreateManyMentionInputEnvelope = {
    data: SpecialiteCreateManyMentionInput | SpecialiteCreateManyMentionInput[]
    skipDuplicates?: boolean
  }

  export type DomaineUpsertWithoutMentionsInput = {
    update: XOR<DomaineUpdateWithoutMentionsInput, DomaineUncheckedUpdateWithoutMentionsInput>
    create: XOR<DomaineCreateWithoutMentionsInput, DomaineUncheckedCreateWithoutMentionsInput>
    where?: DomaineWhereInput
  }

  export type DomaineUpdateToOneWithWhereWithoutMentionsInput = {
    where?: DomaineWhereInput
    data: XOR<DomaineUpdateWithoutMentionsInput, DomaineUncheckedUpdateWithoutMentionsInput>
  }

  export type DomaineUpdateWithoutMentionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    etablissements?: EtablissementUpdateManyWithoutDomainesNestedInput
  }

  export type DomaineUncheckedUpdateWithoutMentionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    etablissements?: EtablissementUncheckedUpdateManyWithoutDomainesNestedInput
  }

  export type SpecialiteUpsertWithWhereUniqueWithoutMentionInput = {
    where: SpecialiteWhereUniqueInput
    update: XOR<SpecialiteUpdateWithoutMentionInput, SpecialiteUncheckedUpdateWithoutMentionInput>
    create: XOR<SpecialiteCreateWithoutMentionInput, SpecialiteUncheckedCreateWithoutMentionInput>
  }

  export type SpecialiteUpdateWithWhereUniqueWithoutMentionInput = {
    where: SpecialiteWhereUniqueInput
    data: XOR<SpecialiteUpdateWithoutMentionInput, SpecialiteUncheckedUpdateWithoutMentionInput>
  }

  export type SpecialiteUpdateManyWithWhereWithoutMentionInput = {
    where: SpecialiteScalarWhereInput
    data: XOR<SpecialiteUpdateManyMutationInput, SpecialiteUncheckedUpdateManyWithoutMentionInput>
  }

  export type SpecialiteScalarWhereInput = {
    AND?: SpecialiteScalarWhereInput | SpecialiteScalarWhereInput[]
    OR?: SpecialiteScalarWhereInput[]
    NOT?: SpecialiteScalarWhereInput | SpecialiteScalarWhereInput[]
    id?: IntFilter<"Specialite"> | number
    createdAt?: DateTimeFilter<"Specialite"> | Date | string
    updatedAt?: DateTimeFilter<"Specialite"> | Date | string
    nom?: StringFilter<"Specialite"> | string
    slug?: StringNullableFilter<"Specialite"> | string | null
    mentionId?: IntNullableFilter<"Specialite"> | number | null
  }

  export type MentionCreateWithoutSpecialitesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    domaine?: DomaineCreateNestedOneWithoutMentionsInput
  }

  export type MentionUncheckedCreateWithoutSpecialitesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    domaineId?: number | null
  }

  export type MentionCreateOrConnectWithoutSpecialitesInput = {
    where: MentionWhereUniqueInput
    create: XOR<MentionCreateWithoutSpecialitesInput, MentionUncheckedCreateWithoutSpecialitesInput>
  }

  export type ClasseCreateWithoutSpecialiteInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissement: EtablissementCreateNestedOneWithoutClassesInput
    semestres?: SemestreCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionCreateNestedManyWithoutClasseInput
    Cours?: CoursCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutClasseInput
    AnneeScolaire?: AnneeScolaireCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateWithoutSpecialiteInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    anneeScolaireId?: number | null
    semestres?: SemestreUncheckedCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutClasseInput
    Cours?: CoursUncheckedCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutSpecialiteInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutSpecialiteInput, ClasseUncheckedCreateWithoutSpecialiteInput>
  }

  export type ClasseCreateManySpecialiteInputEnvelope = {
    data: ClasseCreateManySpecialiteInput | ClasseCreateManySpecialiteInput[]
    skipDuplicates?: boolean
  }

  export type DiplomeCreateWithoutSpecialiteInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    finalite: string
    entite: string
    habilitation: string
    partenaires?: DiplomeCreatepartenairesInput | string[]
    dateCreation: Date | string
    dateHabilitation: Date | string
    dateEcheance: Date | string
    duree: number
    inscriptions?: InscriptionCreateNestedManyWithoutDiplomeInput
  }

  export type DiplomeUncheckedCreateWithoutSpecialiteInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    finalite: string
    entite: string
    habilitation: string
    partenaires?: DiplomeCreatepartenairesInput | string[]
    dateCreation: Date | string
    dateHabilitation: Date | string
    dateEcheance: Date | string
    duree: number
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutDiplomeInput
  }

  export type DiplomeCreateOrConnectWithoutSpecialiteInput = {
    where: DiplomeWhereUniqueInput
    create: XOR<DiplomeCreateWithoutSpecialiteInput, DiplomeUncheckedCreateWithoutSpecialiteInput>
  }

  export type DiplomeCreateManySpecialiteInputEnvelope = {
    data: DiplomeCreateManySpecialiteInput | DiplomeCreateManySpecialiteInput[]
    skipDuplicates?: boolean
  }

  export type MentionUpsertWithoutSpecialitesInput = {
    update: XOR<MentionUpdateWithoutSpecialitesInput, MentionUncheckedUpdateWithoutSpecialitesInput>
    create: XOR<MentionCreateWithoutSpecialitesInput, MentionUncheckedCreateWithoutSpecialitesInput>
    where?: MentionWhereInput
  }

  export type MentionUpdateToOneWithWhereWithoutSpecialitesInput = {
    where?: MentionWhereInput
    data: XOR<MentionUpdateWithoutSpecialitesInput, MentionUncheckedUpdateWithoutSpecialitesInput>
  }

  export type MentionUpdateWithoutSpecialitesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    domaine?: DomaineUpdateOneWithoutMentionsNestedInput
  }

  export type MentionUncheckedUpdateWithoutSpecialitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClasseUpsertWithWhereUniqueWithoutSpecialiteInput = {
    where: ClasseWhereUniqueInput
    update: XOR<ClasseUpdateWithoutSpecialiteInput, ClasseUncheckedUpdateWithoutSpecialiteInput>
    create: XOR<ClasseCreateWithoutSpecialiteInput, ClasseUncheckedCreateWithoutSpecialiteInput>
  }

  export type ClasseUpdateWithWhereUniqueWithoutSpecialiteInput = {
    where: ClasseWhereUniqueInput
    data: XOR<ClasseUpdateWithoutSpecialiteInput, ClasseUncheckedUpdateWithoutSpecialiteInput>
  }

  export type ClasseUpdateManyWithWhereWithoutSpecialiteInput = {
    where: ClasseScalarWhereInput
    data: XOR<ClasseUpdateManyMutationInput, ClasseUncheckedUpdateManyWithoutSpecialiteInput>
  }

  export type ClasseScalarWhereInput = {
    AND?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
    OR?: ClasseScalarWhereInput[]
    NOT?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
    id?: IntFilter<"Classe"> | number
    createdAt?: DateTimeFilter<"Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Classe"> | Date | string
    nom?: StringFilter<"Classe"> | string
    code?: StringFilter<"Classe"> | string
    niveau?: StringFilter<"Classe"> | string
    etablissementId?: IntFilter<"Classe"> | number
    specialiteId?: IntFilter<"Classe"> | number
    anneeScolaireId?: IntNullableFilter<"Classe"> | number | null
  }

  export type DiplomeUpsertWithWhereUniqueWithoutSpecialiteInput = {
    where: DiplomeWhereUniqueInput
    update: XOR<DiplomeUpdateWithoutSpecialiteInput, DiplomeUncheckedUpdateWithoutSpecialiteInput>
    create: XOR<DiplomeCreateWithoutSpecialiteInput, DiplomeUncheckedCreateWithoutSpecialiteInput>
  }

  export type DiplomeUpdateWithWhereUniqueWithoutSpecialiteInput = {
    where: DiplomeWhereUniqueInput
    data: XOR<DiplomeUpdateWithoutSpecialiteInput, DiplomeUncheckedUpdateWithoutSpecialiteInput>
  }

  export type DiplomeUpdateManyWithWhereWithoutSpecialiteInput = {
    where: DiplomeScalarWhereInput
    data: XOR<DiplomeUpdateManyMutationInput, DiplomeUncheckedUpdateManyWithoutSpecialiteInput>
  }

  export type DiplomeScalarWhereInput = {
    AND?: DiplomeScalarWhereInput | DiplomeScalarWhereInput[]
    OR?: DiplomeScalarWhereInput[]
    NOT?: DiplomeScalarWhereInput | DiplomeScalarWhereInput[]
    id?: IntFilter<"Diplome"> | number
    createdAt?: DateTimeFilter<"Diplome"> | Date | string
    updatedAt?: DateTimeFilter<"Diplome"> | Date | string
    nom?: StringFilter<"Diplome"> | string
    finalite?: StringFilter<"Diplome"> | string
    entite?: StringFilter<"Diplome"> | string
    habilitation?: StringFilter<"Diplome"> | string
    partenaires?: StringNullableListFilter<"Diplome">
    dateCreation?: DateTimeFilter<"Diplome"> | Date | string
    dateHabilitation?: DateTimeFilter<"Diplome"> | Date | string
    dateEcheance?: DateTimeFilter<"Diplome"> | Date | string
    duree?: IntFilter<"Diplome"> | number
    specialiteId?: IntNullableFilter<"Diplome"> | number | null
  }

  export type InscriptionCreateWithoutDiplomeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    etudiant: EtudiantCreateNestedOneWithoutInscriptionsInput
    classe: ClasseCreateNestedOneWithoutInscriptionsInput
  }

  export type InscriptionUncheckedCreateWithoutDiplomeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    etudiantId: number
    classeId: number
  }

  export type InscriptionCreateOrConnectWithoutDiplomeInput = {
    where: InscriptionWhereUniqueInput
    create: XOR<InscriptionCreateWithoutDiplomeInput, InscriptionUncheckedCreateWithoutDiplomeInput>
  }

  export type InscriptionCreateManyDiplomeInputEnvelope = {
    data: InscriptionCreateManyDiplomeInput | InscriptionCreateManyDiplomeInput[]
    skipDuplicates?: boolean
  }

  export type SpecialiteCreateWithoutDiplomeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    mention?: MentionCreateNestedOneWithoutSpecialitesInput
    Classe?: ClasseCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteUncheckedCreateWithoutDiplomeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    mentionId?: number | null
    Classe?: ClasseUncheckedCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteCreateOrConnectWithoutDiplomeInput = {
    where: SpecialiteWhereUniqueInput
    create: XOR<SpecialiteCreateWithoutDiplomeInput, SpecialiteUncheckedCreateWithoutDiplomeInput>
  }

  export type InscriptionUpsertWithWhereUniqueWithoutDiplomeInput = {
    where: InscriptionWhereUniqueInput
    update: XOR<InscriptionUpdateWithoutDiplomeInput, InscriptionUncheckedUpdateWithoutDiplomeInput>
    create: XOR<InscriptionCreateWithoutDiplomeInput, InscriptionUncheckedCreateWithoutDiplomeInput>
  }

  export type InscriptionUpdateWithWhereUniqueWithoutDiplomeInput = {
    where: InscriptionWhereUniqueInput
    data: XOR<InscriptionUpdateWithoutDiplomeInput, InscriptionUncheckedUpdateWithoutDiplomeInput>
  }

  export type InscriptionUpdateManyWithWhereWithoutDiplomeInput = {
    where: InscriptionScalarWhereInput
    data: XOR<InscriptionUpdateManyMutationInput, InscriptionUncheckedUpdateManyWithoutDiplomeInput>
  }

  export type SpecialiteUpsertWithoutDiplomeInput = {
    update: XOR<SpecialiteUpdateWithoutDiplomeInput, SpecialiteUncheckedUpdateWithoutDiplomeInput>
    create: XOR<SpecialiteCreateWithoutDiplomeInput, SpecialiteUncheckedCreateWithoutDiplomeInput>
    where?: SpecialiteWhereInput
  }

  export type SpecialiteUpdateToOneWithWhereWithoutDiplomeInput = {
    where?: SpecialiteWhereInput
    data: XOR<SpecialiteUpdateWithoutDiplomeInput, SpecialiteUncheckedUpdateWithoutDiplomeInput>
  }

  export type SpecialiteUpdateWithoutDiplomeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    mention?: MentionUpdateOneWithoutSpecialitesNestedInput
    Classe?: ClasseUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteUncheckedUpdateWithoutDiplomeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    mentionId?: NullableIntFieldUpdateOperationsInput | number | null
    Classe?: ClasseUncheckedUpdateManyWithoutSpecialiteNestedInput
  }

  export type UniteEnseignementCreateWithoutSemestreInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    numero?: number
    credit: number
    matieres?: MatiereCreateNestedManyWithoutUniteEnseignementInput
  }

  export type UniteEnseignementUncheckedCreateWithoutSemestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    numero?: number
    credit: number
    matieres?: MatiereUncheckedCreateNestedManyWithoutUniteEnseignementInput
  }

  export type UniteEnseignementCreateOrConnectWithoutSemestreInput = {
    where: UniteEnseignementWhereUniqueInput
    create: XOR<UniteEnseignementCreateWithoutSemestreInput, UniteEnseignementUncheckedCreateWithoutSemestreInput>
  }

  export type UniteEnseignementCreateManySemestreInputEnvelope = {
    data: UniteEnseignementCreateManySemestreInput | UniteEnseignementCreateManySemestreInput[]
    skipDuplicates?: boolean
  }

  export type ClasseCreateWithoutSemestresInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissement: EtablissementCreateNestedOneWithoutClassesInput
    inscriptions?: InscriptionCreateNestedManyWithoutClasseInput
    specialite: SpecialiteCreateNestedOneWithoutClasseInput
    Cours?: CoursCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutClasseInput
    AnneeScolaire?: AnneeScolaireCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateWithoutSemestresInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    specialiteId: number
    anneeScolaireId?: number | null
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutClasseInput
    Cours?: CoursUncheckedCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutSemestresInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutSemestresInput, ClasseUncheckedCreateWithoutSemestresInput>
  }

  export type UniteEnseignementUpsertWithWhereUniqueWithoutSemestreInput = {
    where: UniteEnseignementWhereUniqueInput
    update: XOR<UniteEnseignementUpdateWithoutSemestreInput, UniteEnseignementUncheckedUpdateWithoutSemestreInput>
    create: XOR<UniteEnseignementCreateWithoutSemestreInput, UniteEnseignementUncheckedCreateWithoutSemestreInput>
  }

  export type UniteEnseignementUpdateWithWhereUniqueWithoutSemestreInput = {
    where: UniteEnseignementWhereUniqueInput
    data: XOR<UniteEnseignementUpdateWithoutSemestreInput, UniteEnseignementUncheckedUpdateWithoutSemestreInput>
  }

  export type UniteEnseignementUpdateManyWithWhereWithoutSemestreInput = {
    where: UniteEnseignementScalarWhereInput
    data: XOR<UniteEnseignementUpdateManyMutationInput, UniteEnseignementUncheckedUpdateManyWithoutSemestreInput>
  }

  export type UniteEnseignementScalarWhereInput = {
    AND?: UniteEnseignementScalarWhereInput | UniteEnseignementScalarWhereInput[]
    OR?: UniteEnseignementScalarWhereInput[]
    NOT?: UniteEnseignementScalarWhereInput | UniteEnseignementScalarWhereInput[]
    id?: IntFilter<"UniteEnseignement"> | number
    createdAt?: DateTimeFilter<"UniteEnseignement"> | Date | string
    updatedAt?: DateTimeFilter<"UniteEnseignement"> | Date | string
    code?: StringFilter<"UniteEnseignement"> | string
    nom?: StringFilter<"UniteEnseignement"> | string
    numero?: IntFilter<"UniteEnseignement"> | number
    credit?: IntFilter<"UniteEnseignement"> | number
    semestreId?: IntNullableFilter<"UniteEnseignement"> | number | null
  }

  export type ClasseUpsertWithoutSemestresInput = {
    update: XOR<ClasseUpdateWithoutSemestresInput, ClasseUncheckedUpdateWithoutSemestresInput>
    create: XOR<ClasseCreateWithoutSemestresInput, ClasseUncheckedCreateWithoutSemestresInput>
    where?: ClasseWhereInput
  }

  export type ClasseUpdateToOneWithWhereWithoutSemestresInput = {
    where?: ClasseWhereInput
    data: XOR<ClasseUpdateWithoutSemestresInput, ClasseUncheckedUpdateWithoutSemestresInput>
  }

  export type ClasseUpdateWithoutSemestresInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissement?: EtablissementUpdateOneRequiredWithoutClassesNestedInput
    inscriptions?: InscriptionUpdateManyWithoutClasseNestedInput
    specialite?: SpecialiteUpdateOneRequiredWithoutClasseNestedInput
    Cours?: CoursUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutClasseNestedInput
    AnneeScolaire?: AnneeScolaireUpdateOneWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateWithoutSemestresInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
    inscriptions?: InscriptionUncheckedUpdateManyWithoutClasseNestedInput
    Cours?: CoursUncheckedUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type SemestreCreateWithoutUniteEnseignementInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    numero: number
    grade: $Enums.TypeDiplome
    dateDebut: Date | string
    dateFin: Date | string
    nombreSemaine: number
    Classe?: ClasseCreateNestedOneWithoutSemestresInput
  }

  export type SemestreUncheckedCreateWithoutUniteEnseignementInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    numero: number
    grade: $Enums.TypeDiplome
    dateDebut: Date | string
    dateFin: Date | string
    nombreSemaine: number
    classeId?: number | null
  }

  export type SemestreCreateOrConnectWithoutUniteEnseignementInput = {
    where: SemestreWhereUniqueInput
    create: XOR<SemestreCreateWithoutUniteEnseignementInput, SemestreUncheckedCreateWithoutUniteEnseignementInput>
  }

  export type MatiereCreateWithoutUniteEnseignementInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    credit: number
    coefficient?: number
    nbHeure?: number | null
    cours?: CoursCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutUniteEnseignementInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    credit: number
    coefficient?: number
    nbHeure?: number | null
    cours?: CoursUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutUniteEnseignementInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutUniteEnseignementInput, MatiereUncheckedCreateWithoutUniteEnseignementInput>
  }

  export type MatiereCreateManyUniteEnseignementInputEnvelope = {
    data: MatiereCreateManyUniteEnseignementInput | MatiereCreateManyUniteEnseignementInput[]
    skipDuplicates?: boolean
  }

  export type SemestreUpsertWithoutUniteEnseignementInput = {
    update: XOR<SemestreUpdateWithoutUniteEnseignementInput, SemestreUncheckedUpdateWithoutUniteEnseignementInput>
    create: XOR<SemestreCreateWithoutUniteEnseignementInput, SemestreUncheckedCreateWithoutUniteEnseignementInput>
    where?: SemestreWhereInput
  }

  export type SemestreUpdateToOneWithWhereWithoutUniteEnseignementInput = {
    where?: SemestreWhereInput
    data: XOR<SemestreUpdateWithoutUniteEnseignementInput, SemestreUncheckedUpdateWithoutUniteEnseignementInput>
  }

  export type SemestreUpdateWithoutUniteEnseignementInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numero?: IntFieldUpdateOperationsInput | number
    grade?: EnumTypeDiplomeFieldUpdateOperationsInput | $Enums.TypeDiplome
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreSemaine?: IntFieldUpdateOperationsInput | number
    Classe?: ClasseUpdateOneWithoutSemestresNestedInput
  }

  export type SemestreUncheckedUpdateWithoutUniteEnseignementInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numero?: IntFieldUpdateOperationsInput | number
    grade?: EnumTypeDiplomeFieldUpdateOperationsInput | $Enums.TypeDiplome
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreSemaine?: IntFieldUpdateOperationsInput | number
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MatiereUpsertWithWhereUniqueWithoutUniteEnseignementInput = {
    where: MatiereWhereUniqueInput
    update: XOR<MatiereUpdateWithoutUniteEnseignementInput, MatiereUncheckedUpdateWithoutUniteEnseignementInput>
    create: XOR<MatiereCreateWithoutUniteEnseignementInput, MatiereUncheckedCreateWithoutUniteEnseignementInput>
  }

  export type MatiereUpdateWithWhereUniqueWithoutUniteEnseignementInput = {
    where: MatiereWhereUniqueInput
    data: XOR<MatiereUpdateWithoutUniteEnseignementInput, MatiereUncheckedUpdateWithoutUniteEnseignementInput>
  }

  export type MatiereUpdateManyWithWhereWithoutUniteEnseignementInput = {
    where: MatiereScalarWhereInput
    data: XOR<MatiereUpdateManyMutationInput, MatiereUncheckedUpdateManyWithoutUniteEnseignementInput>
  }

  export type MatiereScalarWhereInput = {
    AND?: MatiereScalarWhereInput | MatiereScalarWhereInput[]
    OR?: MatiereScalarWhereInput[]
    NOT?: MatiereScalarWhereInput | MatiereScalarWhereInput[]
    id?: IntFilter<"Matiere"> | number
    createdAt?: DateTimeFilter<"Matiere"> | Date | string
    updatedAt?: DateTimeFilter<"Matiere"> | Date | string
    code?: StringFilter<"Matiere"> | string
    nom?: StringFilter<"Matiere"> | string
    credit?: IntFilter<"Matiere"> | number
    coefficient?: IntFilter<"Matiere"> | number
    nbHeure?: IntNullableFilter<"Matiere"> | number | null
    uniteEnseignementId?: IntFilter<"Matiere"> | number
  }

  export type CoursCreateWithoutMatiereInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    salle?: SalleCreateNestedOneWithoutCoursInput
    classe?: ClasseCreateNestedOneWithoutCoursInput
    professeur?: ProfesseurCreateNestedOneWithoutCoursInput
    evaluationEtudiant?: EvaluationEtudiantsCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutCoursInput
  }

  export type CoursUncheckedCreateWithoutMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    salleId?: number | null
    classeId?: number | null
    professeurId?: number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutCoursInput
  }

  export type CoursCreateOrConnectWithoutMatiereInput = {
    where: CoursWhereUniqueInput
    create: XOR<CoursCreateWithoutMatiereInput, CoursUncheckedCreateWithoutMatiereInput>
  }

  export type CoursCreateManyMatiereInputEnvelope = {
    data: CoursCreateManyMatiereInput | CoursCreateManyMatiereInput[]
    skipDuplicates?: boolean
  }

  export type UniteEnseignementCreateWithoutMatieresInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    numero?: number
    credit: number
    semestre?: SemestreCreateNestedOneWithoutUniteEnseignementInput
  }

  export type UniteEnseignementUncheckedCreateWithoutMatieresInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    numero?: number
    credit: number
    semestreId?: number | null
  }

  export type UniteEnseignementCreateOrConnectWithoutMatieresInput = {
    where: UniteEnseignementWhereUniqueInput
    create: XOR<UniteEnseignementCreateWithoutMatieresInput, UniteEnseignementUncheckedCreateWithoutMatieresInput>
  }

  export type CoursUpsertWithWhereUniqueWithoutMatiereInput = {
    where: CoursWhereUniqueInput
    update: XOR<CoursUpdateWithoutMatiereInput, CoursUncheckedUpdateWithoutMatiereInput>
    create: XOR<CoursCreateWithoutMatiereInput, CoursUncheckedCreateWithoutMatiereInput>
  }

  export type CoursUpdateWithWhereUniqueWithoutMatiereInput = {
    where: CoursWhereUniqueInput
    data: XOR<CoursUpdateWithoutMatiereInput, CoursUncheckedUpdateWithoutMatiereInput>
  }

  export type CoursUpdateManyWithWhereWithoutMatiereInput = {
    where: CoursScalarWhereInput
    data: XOR<CoursUpdateManyMutationInput, CoursUncheckedUpdateManyWithoutMatiereInput>
  }

  export type UniteEnseignementUpsertWithoutMatieresInput = {
    update: XOR<UniteEnseignementUpdateWithoutMatieresInput, UniteEnseignementUncheckedUpdateWithoutMatieresInput>
    create: XOR<UniteEnseignementCreateWithoutMatieresInput, UniteEnseignementUncheckedCreateWithoutMatieresInput>
    where?: UniteEnseignementWhereInput
  }

  export type UniteEnseignementUpdateToOneWithWhereWithoutMatieresInput = {
    where?: UniteEnseignementWhereInput
    data: XOR<UniteEnseignementUpdateWithoutMatieresInput, UniteEnseignementUncheckedUpdateWithoutMatieresInput>
  }

  export type UniteEnseignementUpdateWithoutMatieresInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    credit?: IntFieldUpdateOperationsInput | number
    semestre?: SemestreUpdateOneWithoutUniteEnseignementNestedInput
  }

  export type UniteEnseignementUncheckedUpdateWithoutMatieresInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    credit?: IntFieldUpdateOperationsInput | number
    semestreId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdresseCreateWithoutEtablissementsInput = {
    pays: string
    region: string
    ville: string
    codePostal?: string | null
    geolocalisation?: string | null
    utilisateurs?: UtilisateurCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutEtablissementsInput = {
    id?: number
    pays: string
    region: string
    ville: string
    codePostal?: string | null
    geolocalisation?: string | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutEtablissementsInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutEtablissementsInput, AdresseUncheckedCreateWithoutEtablissementsInput>
  }

  export type ContactCreateWithoutEtablissementsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    telephone: string
    fix?: string | null
    fax?: string | null
    email: string
    siteWeb?: string | null
    reseauxSociaux?: ReseauSocialCreateNestedManyWithoutContactInput
    utilisateurs?: UtilisateurCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutEtablissementsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    telephone: string
    fix?: string | null
    fax?: string | null
    email: string
    siteWeb?: string | null
    reseauxSociaux?: ReseauSocialUncheckedCreateNestedManyWithoutContactInput
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutEtablissementsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutEtablissementsInput, ContactUncheckedCreateWithoutEtablissementsInput>
  }

  export type UtilisateurCreateWithoutEtablissementInput = {
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    accountId?: number | null
    contact?: ContactCreateNestedOneWithoutUtilisateursInput
    adresse?: AdresseCreateNestedOneWithoutUtilisateursInput
    etudiant?: EtudiantCreateNestedOneWithoutProfileInput
    permissions?: PermissionCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurUncheckedCreateWithoutEtablissementInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    contactId?: number | null
    adresseId?: number | null
    accountId?: number | null
    etudiant?: EtudiantUncheckedCreateNestedOneWithoutProfileInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutUtilisateursInput
    Professeur?: ProfesseurUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UtilisateurCreateOrConnectWithoutEtablissementInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutEtablissementInput, UtilisateurUncheckedCreateWithoutEtablissementInput>
  }

  export type UtilisateurCreateManyEtablissementInputEnvelope = {
    data: UtilisateurCreateManyEtablissementInput | UtilisateurCreateManyEtablissementInput[]
    skipDuplicates?: boolean
  }

  export type DomaineCreateWithoutEtablissementsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    mentions?: MentionCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUncheckedCreateWithoutEtablissementsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    mentions?: MentionUncheckedCreateNestedManyWithoutDomaineInput
  }

  export type DomaineCreateOrConnectWithoutEtablissementsInput = {
    where: DomaineWhereUniqueInput
    create: XOR<DomaineCreateWithoutEtablissementsInput, DomaineUncheckedCreateWithoutEtablissementsInput>
  }

  export type ClasseCreateWithoutEtablissementInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    semestres?: SemestreCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionCreateNestedManyWithoutClasseInput
    specialite: SpecialiteCreateNestedOneWithoutClasseInput
    Cours?: CoursCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutClasseInput
    AnneeScolaire?: AnneeScolaireCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateWithoutEtablissementInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    specialiteId: number
    anneeScolaireId?: number | null
    semestres?: SemestreUncheckedCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutClasseInput
    Cours?: CoursUncheckedCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutEtablissementInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutEtablissementInput, ClasseUncheckedCreateWithoutEtablissementInput>
  }

  export type ClasseCreateManyEtablissementInputEnvelope = {
    data: ClasseCreateManyEtablissementInput | ClasseCreateManyEtablissementInput[]
    skipDuplicates?: boolean
  }

  export type SalleCreateWithoutEtablissementInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    estDisponible?: boolean
    cours?: CoursCreateNestedManyWithoutSalleInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutSalleInput
  }

  export type SalleUncheckedCreateWithoutEtablissementInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    estDisponible?: boolean
    cours?: CoursUncheckedCreateNestedManyWithoutSalleInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutSalleInput
  }

  export type SalleCreateOrConnectWithoutEtablissementInput = {
    where: SalleWhereUniqueInput
    create: XOR<SalleCreateWithoutEtablissementInput, SalleUncheckedCreateWithoutEtablissementInput>
  }

  export type SalleCreateManyEtablissementInputEnvelope = {
    data: SalleCreateManyEtablissementInput | SalleCreateManyEtablissementInput[]
    skipDuplicates?: boolean
  }

  export type AdresseUpsertWithoutEtablissementsInput = {
    update: XOR<AdresseUpdateWithoutEtablissementsInput, AdresseUncheckedUpdateWithoutEtablissementsInput>
    create: XOR<AdresseCreateWithoutEtablissementsInput, AdresseUncheckedCreateWithoutEtablissementsInput>
    where?: AdresseWhereInput
  }

  export type AdresseUpdateToOneWithWhereWithoutEtablissementsInput = {
    where?: AdresseWhereInput
    data: XOR<AdresseUpdateWithoutEtablissementsInput, AdresseUncheckedUpdateWithoutEtablissementsInput>
  }

  export type AdresseUpdateWithoutEtablissementsInput = {
    pays?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    geolocalisation?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurs?: UtilisateurUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutEtablissementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    pays?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    geolocalisation?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type ContactUpsertWithoutEtablissementsInput = {
    update: XOR<ContactUpdateWithoutEtablissementsInput, ContactUncheckedUpdateWithoutEtablissementsInput>
    create: XOR<ContactCreateWithoutEtablissementsInput, ContactUncheckedCreateWithoutEtablissementsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutEtablissementsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutEtablissementsInput, ContactUncheckedUpdateWithoutEtablissementsInput>
  }

  export type ContactUpdateWithoutEtablissementsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    reseauxSociaux?: ReseauSocialUpdateManyWithoutContactNestedInput
    utilisateurs?: UtilisateurUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutEtablissementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: StringFieldUpdateOperationsInput | string
    fix?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    reseauxSociaux?: ReseauSocialUncheckedUpdateManyWithoutContactNestedInput
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UtilisateurUpsertWithWhereUniqueWithoutEtablissementInput = {
    where: UtilisateurWhereUniqueInput
    update: XOR<UtilisateurUpdateWithoutEtablissementInput, UtilisateurUncheckedUpdateWithoutEtablissementInput>
    create: XOR<UtilisateurCreateWithoutEtablissementInput, UtilisateurUncheckedCreateWithoutEtablissementInput>
  }

  export type UtilisateurUpdateWithWhereUniqueWithoutEtablissementInput = {
    where: UtilisateurWhereUniqueInput
    data: XOR<UtilisateurUpdateWithoutEtablissementInput, UtilisateurUncheckedUpdateWithoutEtablissementInput>
  }

  export type UtilisateurUpdateManyWithWhereWithoutEtablissementInput = {
    where: UtilisateurScalarWhereInput
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyWithoutEtablissementInput>
  }

  export type DomaineUpsertWithWhereUniqueWithoutEtablissementsInput = {
    where: DomaineWhereUniqueInput
    update: XOR<DomaineUpdateWithoutEtablissementsInput, DomaineUncheckedUpdateWithoutEtablissementsInput>
    create: XOR<DomaineCreateWithoutEtablissementsInput, DomaineUncheckedCreateWithoutEtablissementsInput>
  }

  export type DomaineUpdateWithWhereUniqueWithoutEtablissementsInput = {
    where: DomaineWhereUniqueInput
    data: XOR<DomaineUpdateWithoutEtablissementsInput, DomaineUncheckedUpdateWithoutEtablissementsInput>
  }

  export type DomaineUpdateManyWithWhereWithoutEtablissementsInput = {
    where: DomaineScalarWhereInput
    data: XOR<DomaineUpdateManyMutationInput, DomaineUncheckedUpdateManyWithoutEtablissementsInput>
  }

  export type DomaineScalarWhereInput = {
    AND?: DomaineScalarWhereInput | DomaineScalarWhereInput[]
    OR?: DomaineScalarWhereInput[]
    NOT?: DomaineScalarWhereInput | DomaineScalarWhereInput[]
    id?: IntFilter<"Domaine"> | number
    createdAt?: DateTimeFilter<"Domaine"> | Date | string
    updatedAt?: DateTimeFilter<"Domaine"> | Date | string
    nom?: StringFilter<"Domaine"> | string
    slug?: StringNullableFilter<"Domaine"> | string | null
  }

  export type ClasseUpsertWithWhereUniqueWithoutEtablissementInput = {
    where: ClasseWhereUniqueInput
    update: XOR<ClasseUpdateWithoutEtablissementInput, ClasseUncheckedUpdateWithoutEtablissementInput>
    create: XOR<ClasseCreateWithoutEtablissementInput, ClasseUncheckedCreateWithoutEtablissementInput>
  }

  export type ClasseUpdateWithWhereUniqueWithoutEtablissementInput = {
    where: ClasseWhereUniqueInput
    data: XOR<ClasseUpdateWithoutEtablissementInput, ClasseUncheckedUpdateWithoutEtablissementInput>
  }

  export type ClasseUpdateManyWithWhereWithoutEtablissementInput = {
    where: ClasseScalarWhereInput
    data: XOR<ClasseUpdateManyMutationInput, ClasseUncheckedUpdateManyWithoutEtablissementInput>
  }

  export type SalleUpsertWithWhereUniqueWithoutEtablissementInput = {
    where: SalleWhereUniqueInput
    update: XOR<SalleUpdateWithoutEtablissementInput, SalleUncheckedUpdateWithoutEtablissementInput>
    create: XOR<SalleCreateWithoutEtablissementInput, SalleUncheckedCreateWithoutEtablissementInput>
  }

  export type SalleUpdateWithWhereUniqueWithoutEtablissementInput = {
    where: SalleWhereUniqueInput
    data: XOR<SalleUpdateWithoutEtablissementInput, SalleUncheckedUpdateWithoutEtablissementInput>
  }

  export type SalleUpdateManyWithWhereWithoutEtablissementInput = {
    where: SalleScalarWhereInput
    data: XOR<SalleUpdateManyMutationInput, SalleUncheckedUpdateManyWithoutEtablissementInput>
  }

  export type SalleScalarWhereInput = {
    AND?: SalleScalarWhereInput | SalleScalarWhereInput[]
    OR?: SalleScalarWhereInput[]
    NOT?: SalleScalarWhereInput | SalleScalarWhereInput[]
    id?: IntFilter<"Salle"> | number
    createdAt?: DateTimeFilter<"Salle"> | Date | string
    updatedAt?: DateTimeFilter<"Salle"> | Date | string
    nom?: StringFilter<"Salle"> | string
    capacite?: IntNullableFilter<"Salle"> | number | null
    batiment?: StringNullableFilter<"Salle"> | string | null
    etablissementId?: IntFilter<"Salle"> | number
    estDisponible?: BoolFilter<"Salle"> | boolean
  }

  export type EtablissementCreateWithoutClassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresse?: AdresseCreateNestedOneWithoutEtablissementsInput
    contact?: ContactCreateNestedOneWithoutEtablissementsInput
    utilisateurs?: UtilisateurCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineCreateNestedManyWithoutEtablissementsInput
    salle?: SalleCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementUncheckedCreateWithoutClassesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresseId?: number | null
    contactId?: number | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineUncheckedCreateNestedManyWithoutEtablissementsInput
    salle?: SalleUncheckedCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementCreateOrConnectWithoutClassesInput = {
    where: EtablissementWhereUniqueInput
    create: XOR<EtablissementCreateWithoutClassesInput, EtablissementUncheckedCreateWithoutClassesInput>
  }

  export type SemestreCreateWithoutClasseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    numero: number
    grade: $Enums.TypeDiplome
    dateDebut: Date | string
    dateFin: Date | string
    nombreSemaine: number
    uniteEnseignement?: UniteEnseignementCreateNestedManyWithoutSemestreInput
  }

  export type SemestreUncheckedCreateWithoutClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    numero: number
    grade: $Enums.TypeDiplome
    dateDebut: Date | string
    dateFin: Date | string
    nombreSemaine: number
    uniteEnseignement?: UniteEnseignementUncheckedCreateNestedManyWithoutSemestreInput
  }

  export type SemestreCreateOrConnectWithoutClasseInput = {
    where: SemestreWhereUniqueInput
    create: XOR<SemestreCreateWithoutClasseInput, SemestreUncheckedCreateWithoutClasseInput>
  }

  export type SemestreCreateManyClasseInputEnvelope = {
    data: SemestreCreateManyClasseInput | SemestreCreateManyClasseInput[]
    skipDuplicates?: boolean
  }

  export type InscriptionCreateWithoutClasseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    diplome: DiplomeCreateNestedOneWithoutInscriptionsInput
    etudiant: EtudiantCreateNestedOneWithoutInscriptionsInput
  }

  export type InscriptionUncheckedCreateWithoutClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    diplomeId: number
    etudiantId: number
  }

  export type InscriptionCreateOrConnectWithoutClasseInput = {
    where: InscriptionWhereUniqueInput
    create: XOR<InscriptionCreateWithoutClasseInput, InscriptionUncheckedCreateWithoutClasseInput>
  }

  export type InscriptionCreateManyClasseInputEnvelope = {
    data: InscriptionCreateManyClasseInput | InscriptionCreateManyClasseInput[]
    skipDuplicates?: boolean
  }

  export type SpecialiteCreateWithoutClasseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    mention?: MentionCreateNestedOneWithoutSpecialitesInput
    Diplome?: DiplomeCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteUncheckedCreateWithoutClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
    mentionId?: number | null
    Diplome?: DiplomeUncheckedCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteCreateOrConnectWithoutClasseInput = {
    where: SpecialiteWhereUniqueInput
    create: XOR<SpecialiteCreateWithoutClasseInput, SpecialiteUncheckedCreateWithoutClasseInput>
  }

  export type CoursCreateWithoutClasseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiere?: MatiereCreateNestedOneWithoutCoursInput
    salle?: SalleCreateNestedOneWithoutCoursInput
    professeur?: ProfesseurCreateNestedOneWithoutCoursInput
    evaluationEtudiant?: EvaluationEtudiantsCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutCoursInput
  }

  export type CoursUncheckedCreateWithoutClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    salleId?: number | null
    professeurId?: number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutCoursInput
  }

  export type CoursCreateOrConnectWithoutClasseInput = {
    where: CoursWhereUniqueInput
    create: XOR<CoursCreateWithoutClasseInput, CoursUncheckedCreateWithoutClasseInput>
  }

  export type CoursCreateManyClasseInputEnvelope = {
    data: CoursCreateManyClasseInput | CoursCreateManyClasseInput[]
    skipDuplicates?: boolean
  }

  export type EmploiDuTempsCreateWithoutClasseInput = {
    dateDebut: Date | string
    dateFin: Date | string
    cours: CoursCreateNestedOneWithoutEmploiDuTempsInput
    professeur?: ProfesseurCreateNestedOneWithoutEmploiDuTempsInput
    salle: SalleCreateNestedOneWithoutEmploiDuTempsInput
  }

  export type EmploiDuTempsUncheckedCreateWithoutClasseInput = {
    id?: number
    coursId: number
    professeurId?: number | null
    salleId: number
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type EmploiDuTempsCreateOrConnectWithoutClasseInput = {
    where: EmploiDuTempsWhereUniqueInput
    create: XOR<EmploiDuTempsCreateWithoutClasseInput, EmploiDuTempsUncheckedCreateWithoutClasseInput>
  }

  export type EmploiDuTempsCreateManyClasseInputEnvelope = {
    data: EmploiDuTempsCreateManyClasseInput | EmploiDuTempsCreateManyClasseInput[]
    skipDuplicates?: boolean
  }

  export type AnneeScolaireCreateWithoutClassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    dateDebut: number
    dateFin: number
    nom: string
  }

  export type AnneeScolaireUncheckedCreateWithoutClassesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dateDebut: number
    dateFin: number
    nom: string
  }

  export type AnneeScolaireCreateOrConnectWithoutClassesInput = {
    where: AnneeScolaireWhereUniqueInput
    create: XOR<AnneeScolaireCreateWithoutClassesInput, AnneeScolaireUncheckedCreateWithoutClassesInput>
  }

  export type EtablissementUpsertWithoutClassesInput = {
    update: XOR<EtablissementUpdateWithoutClassesInput, EtablissementUncheckedUpdateWithoutClassesInput>
    create: XOR<EtablissementCreateWithoutClassesInput, EtablissementUncheckedCreateWithoutClassesInput>
    where?: EtablissementWhereInput
  }

  export type EtablissementUpdateToOneWithWhereWithoutClassesInput = {
    where?: EtablissementWhereInput
    data: XOR<EtablissementUpdateWithoutClassesInput, EtablissementUncheckedUpdateWithoutClassesInput>
  }

  export type EtablissementUpdateWithoutClassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: AdresseUpdateOneWithoutEtablissementsNestedInput
    contact?: ContactUpdateOneWithoutEtablissementsNestedInput
    utilisateurs?: UtilisateurUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUpdateManyWithoutEtablissementsNestedInput
    salle?: SalleUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUncheckedUpdateManyWithoutEtablissementsNestedInput
    salle?: SalleUncheckedUpdateManyWithoutEtablissementNestedInput
  }

  export type SemestreUpsertWithWhereUniqueWithoutClasseInput = {
    where: SemestreWhereUniqueInput
    update: XOR<SemestreUpdateWithoutClasseInput, SemestreUncheckedUpdateWithoutClasseInput>
    create: XOR<SemestreCreateWithoutClasseInput, SemestreUncheckedCreateWithoutClasseInput>
  }

  export type SemestreUpdateWithWhereUniqueWithoutClasseInput = {
    where: SemestreWhereUniqueInput
    data: XOR<SemestreUpdateWithoutClasseInput, SemestreUncheckedUpdateWithoutClasseInput>
  }

  export type SemestreUpdateManyWithWhereWithoutClasseInput = {
    where: SemestreScalarWhereInput
    data: XOR<SemestreUpdateManyMutationInput, SemestreUncheckedUpdateManyWithoutClasseInput>
  }

  export type SemestreScalarWhereInput = {
    AND?: SemestreScalarWhereInput | SemestreScalarWhereInput[]
    OR?: SemestreScalarWhereInput[]
    NOT?: SemestreScalarWhereInput | SemestreScalarWhereInput[]
    id?: IntFilter<"Semestre"> | number
    createdAt?: DateTimeFilter<"Semestre"> | Date | string
    updatedAt?: DateTimeFilter<"Semestre"> | Date | string
    numero?: IntFilter<"Semestre"> | number
    grade?: EnumTypeDiplomeFilter<"Semestre"> | $Enums.TypeDiplome
    dateDebut?: DateTimeFilter<"Semestre"> | Date | string
    dateFin?: DateTimeFilter<"Semestre"> | Date | string
    nombreSemaine?: IntFilter<"Semestre"> | number
    classeId?: IntNullableFilter<"Semestre"> | number | null
  }

  export type InscriptionUpsertWithWhereUniqueWithoutClasseInput = {
    where: InscriptionWhereUniqueInput
    update: XOR<InscriptionUpdateWithoutClasseInput, InscriptionUncheckedUpdateWithoutClasseInput>
    create: XOR<InscriptionCreateWithoutClasseInput, InscriptionUncheckedCreateWithoutClasseInput>
  }

  export type InscriptionUpdateWithWhereUniqueWithoutClasseInput = {
    where: InscriptionWhereUniqueInput
    data: XOR<InscriptionUpdateWithoutClasseInput, InscriptionUncheckedUpdateWithoutClasseInput>
  }

  export type InscriptionUpdateManyWithWhereWithoutClasseInput = {
    where: InscriptionScalarWhereInput
    data: XOR<InscriptionUpdateManyMutationInput, InscriptionUncheckedUpdateManyWithoutClasseInput>
  }

  export type SpecialiteUpsertWithoutClasseInput = {
    update: XOR<SpecialiteUpdateWithoutClasseInput, SpecialiteUncheckedUpdateWithoutClasseInput>
    create: XOR<SpecialiteCreateWithoutClasseInput, SpecialiteUncheckedCreateWithoutClasseInput>
    where?: SpecialiteWhereInput
  }

  export type SpecialiteUpdateToOneWithWhereWithoutClasseInput = {
    where?: SpecialiteWhereInput
    data: XOR<SpecialiteUpdateWithoutClasseInput, SpecialiteUncheckedUpdateWithoutClasseInput>
  }

  export type SpecialiteUpdateWithoutClasseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    mention?: MentionUpdateOneWithoutSpecialitesNestedInput
    Diplome?: DiplomeUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteUncheckedUpdateWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    mentionId?: NullableIntFieldUpdateOperationsInput | number | null
    Diplome?: DiplomeUncheckedUpdateManyWithoutSpecialiteNestedInput
  }

  export type CoursUpsertWithWhereUniqueWithoutClasseInput = {
    where: CoursWhereUniqueInput
    update: XOR<CoursUpdateWithoutClasseInput, CoursUncheckedUpdateWithoutClasseInput>
    create: XOR<CoursCreateWithoutClasseInput, CoursUncheckedCreateWithoutClasseInput>
  }

  export type CoursUpdateWithWhereUniqueWithoutClasseInput = {
    where: CoursWhereUniqueInput
    data: XOR<CoursUpdateWithoutClasseInput, CoursUncheckedUpdateWithoutClasseInput>
  }

  export type CoursUpdateManyWithWhereWithoutClasseInput = {
    where: CoursScalarWhereInput
    data: XOR<CoursUpdateManyMutationInput, CoursUncheckedUpdateManyWithoutClasseInput>
  }

  export type EmploiDuTempsUpsertWithWhereUniqueWithoutClasseInput = {
    where: EmploiDuTempsWhereUniqueInput
    update: XOR<EmploiDuTempsUpdateWithoutClasseInput, EmploiDuTempsUncheckedUpdateWithoutClasseInput>
    create: XOR<EmploiDuTempsCreateWithoutClasseInput, EmploiDuTempsUncheckedCreateWithoutClasseInput>
  }

  export type EmploiDuTempsUpdateWithWhereUniqueWithoutClasseInput = {
    where: EmploiDuTempsWhereUniqueInput
    data: XOR<EmploiDuTempsUpdateWithoutClasseInput, EmploiDuTempsUncheckedUpdateWithoutClasseInput>
  }

  export type EmploiDuTempsUpdateManyWithWhereWithoutClasseInput = {
    where: EmploiDuTempsScalarWhereInput
    data: XOR<EmploiDuTempsUpdateManyMutationInput, EmploiDuTempsUncheckedUpdateManyWithoutClasseInput>
  }

  export type AnneeScolaireUpsertWithoutClassesInput = {
    update: XOR<AnneeScolaireUpdateWithoutClassesInput, AnneeScolaireUncheckedUpdateWithoutClassesInput>
    create: XOR<AnneeScolaireCreateWithoutClassesInput, AnneeScolaireUncheckedCreateWithoutClassesInput>
    where?: AnneeScolaireWhereInput
  }

  export type AnneeScolaireUpdateToOneWithWhereWithoutClassesInput = {
    where?: AnneeScolaireWhereInput
    data: XOR<AnneeScolaireUpdateWithoutClassesInput, AnneeScolaireUncheckedUpdateWithoutClassesInput>
  }

  export type AnneeScolaireUpdateWithoutClassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDebut?: IntFieldUpdateOperationsInput | number
    dateFin?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type AnneeScolaireUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDebut?: IntFieldUpdateOperationsInput | number
    dateFin?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type ClasseCreateWithoutAnneeScolaireInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissement: EtablissementCreateNestedOneWithoutClassesInput
    semestres?: SemestreCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionCreateNestedManyWithoutClasseInput
    specialite: SpecialiteCreateNestedOneWithoutClasseInput
    Cours?: CoursCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutClasseInput
  }

  export type ClasseUncheckedCreateWithoutAnneeScolaireInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    specialiteId: number
    semestres?: SemestreUncheckedCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutClasseInput
    Cours?: CoursUncheckedCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutAnneeScolaireInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutAnneeScolaireInput, ClasseUncheckedCreateWithoutAnneeScolaireInput>
  }

  export type ClasseCreateManyAnneeScolaireInputEnvelope = {
    data: ClasseCreateManyAnneeScolaireInput | ClasseCreateManyAnneeScolaireInput[]
    skipDuplicates?: boolean
  }

  export type ClasseUpsertWithWhereUniqueWithoutAnneeScolaireInput = {
    where: ClasseWhereUniqueInput
    update: XOR<ClasseUpdateWithoutAnneeScolaireInput, ClasseUncheckedUpdateWithoutAnneeScolaireInput>
    create: XOR<ClasseCreateWithoutAnneeScolaireInput, ClasseUncheckedCreateWithoutAnneeScolaireInput>
  }

  export type ClasseUpdateWithWhereUniqueWithoutAnneeScolaireInput = {
    where: ClasseWhereUniqueInput
    data: XOR<ClasseUpdateWithoutAnneeScolaireInput, ClasseUncheckedUpdateWithoutAnneeScolaireInput>
  }

  export type ClasseUpdateManyWithWhereWithoutAnneeScolaireInput = {
    where: ClasseScalarWhereInput
    data: XOR<ClasseUpdateManyMutationInput, ClasseUncheckedUpdateManyWithoutAnneeScolaireInput>
  }

  export type CoursCreateWithoutEvaluationEtudiantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiere?: MatiereCreateNestedOneWithoutCoursInput
    salle?: SalleCreateNestedOneWithoutCoursInput
    classe?: ClasseCreateNestedOneWithoutCoursInput
    professeur?: ProfesseurCreateNestedOneWithoutCoursInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutCoursInput
  }

  export type CoursUncheckedCreateWithoutEvaluationEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    salleId?: number | null
    classeId?: number | null
    professeurId?: number | null
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutCoursInput
  }

  export type CoursCreateOrConnectWithoutEvaluationEtudiantInput = {
    where: CoursWhereUniqueInput
    create: XOR<CoursCreateWithoutEvaluationEtudiantInput, CoursUncheckedCreateWithoutEvaluationEtudiantInput>
  }

  export type NoteEtudiantCreateWithoutEvaluationEtudiantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    note: number
    etudiant: EtudiantCreateNestedOneWithoutNotesInput
  }

  export type NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note: number
    etudiantId: number
  }

  export type NoteEtudiantCreateOrConnectWithoutEvaluationEtudiantInput = {
    where: NoteEtudiantWhereUniqueInput
    create: XOR<NoteEtudiantCreateWithoutEvaluationEtudiantInput, NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput>
  }

  export type NoteEtudiantCreateManyEvaluationEtudiantInputEnvelope = {
    data: NoteEtudiantCreateManyEvaluationEtudiantInput | NoteEtudiantCreateManyEvaluationEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type CoursUpsertWithoutEvaluationEtudiantInput = {
    update: XOR<CoursUpdateWithoutEvaluationEtudiantInput, CoursUncheckedUpdateWithoutEvaluationEtudiantInput>
    create: XOR<CoursCreateWithoutEvaluationEtudiantInput, CoursUncheckedCreateWithoutEvaluationEtudiantInput>
    where?: CoursWhereInput
  }

  export type CoursUpdateToOneWithWhereWithoutEvaluationEtudiantInput = {
    where?: CoursWhereInput
    data: XOR<CoursUpdateWithoutEvaluationEtudiantInput, CoursUncheckedUpdateWithoutEvaluationEtudiantInput>
  }

  export type CoursUpdateWithoutEvaluationEtudiantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutCoursNestedInput
    salle?: SalleUpdateOneWithoutCoursNestedInput
    classe?: ClasseUpdateOneWithoutCoursNestedInput
    professeur?: ProfesseurUpdateOneWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateWithoutEvaluationEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutCoursNestedInput
  }

  export type NoteEtudiantUpsertWithWhereUniqueWithoutEvaluationEtudiantInput = {
    where: NoteEtudiantWhereUniqueInput
    update: XOR<NoteEtudiantUpdateWithoutEvaluationEtudiantInput, NoteEtudiantUncheckedUpdateWithoutEvaluationEtudiantInput>
    create: XOR<NoteEtudiantCreateWithoutEvaluationEtudiantInput, NoteEtudiantUncheckedCreateWithoutEvaluationEtudiantInput>
  }

  export type NoteEtudiantUpdateWithWhereUniqueWithoutEvaluationEtudiantInput = {
    where: NoteEtudiantWhereUniqueInput
    data: XOR<NoteEtudiantUpdateWithoutEvaluationEtudiantInput, NoteEtudiantUncheckedUpdateWithoutEvaluationEtudiantInput>
  }

  export type NoteEtudiantUpdateManyWithWhereWithoutEvaluationEtudiantInput = {
    where: NoteEtudiantScalarWhereInput
    data: XOR<NoteEtudiantUpdateManyMutationInput, NoteEtudiantUncheckedUpdateManyWithoutEvaluationEtudiantInput>
  }

  export type EvaluationEtudiantsCreateWithoutNoteEtudiantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    typeEvaluation: $Enums.TypeEvaluation
    dateEvaluation: Date | string
    duree: number
    document: string
    description?: string | null
    cours: CoursCreateNestedOneWithoutEvaluationEtudiantInput
  }

  export type EvaluationEtudiantsUncheckedCreateWithoutNoteEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    typeEvaluation: $Enums.TypeEvaluation
    dateEvaluation: Date | string
    duree: number
    document: string
    description?: string | null
    coursId: number
  }

  export type EvaluationEtudiantsCreateOrConnectWithoutNoteEtudiantInput = {
    where: EvaluationEtudiantsWhereUniqueInput
    create: XOR<EvaluationEtudiantsCreateWithoutNoteEtudiantInput, EvaluationEtudiantsUncheckedCreateWithoutNoteEtudiantInput>
  }

  export type EtudiantCreateWithoutNotesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    feuillePresencesId?: number | null
    profile: UtilisateurCreateNestedOneWithoutEtudiantInput
    inscriptions?: InscriptionCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutNotesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    profileId: number
    feuillePresencesId?: number | null
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutNotesInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutNotesInput, EtudiantUncheckedCreateWithoutNotesInput>
  }

  export type EvaluationEtudiantsUpsertWithoutNoteEtudiantInput = {
    update: XOR<EvaluationEtudiantsUpdateWithoutNoteEtudiantInput, EvaluationEtudiantsUncheckedUpdateWithoutNoteEtudiantInput>
    create: XOR<EvaluationEtudiantsCreateWithoutNoteEtudiantInput, EvaluationEtudiantsUncheckedCreateWithoutNoteEtudiantInput>
    where?: EvaluationEtudiantsWhereInput
  }

  export type EvaluationEtudiantsUpdateToOneWithWhereWithoutNoteEtudiantInput = {
    where?: EvaluationEtudiantsWhereInput
    data: XOR<EvaluationEtudiantsUpdateWithoutNoteEtudiantInput, EvaluationEtudiantsUncheckedUpdateWithoutNoteEtudiantInput>
  }

  export type EvaluationEtudiantsUpdateWithoutNoteEtudiantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvaluation?: EnumTypeEvaluationFieldUpdateOperationsInput | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cours?: CoursUpdateOneRequiredWithoutEvaluationEtudiantNestedInput
  }

  export type EvaluationEtudiantsUncheckedUpdateWithoutNoteEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvaluation?: EnumTypeEvaluationFieldUpdateOperationsInput | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coursId?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantUpsertWithoutNotesInput = {
    update: XOR<EtudiantUpdateWithoutNotesInput, EtudiantUncheckedUpdateWithoutNotesInput>
    create: XOR<EtudiantCreateWithoutNotesInput, EtudiantUncheckedCreateWithoutNotesInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutNotesInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutNotesInput, EtudiantUncheckedUpdateWithoutNotesInput>
  }

  export type EtudiantUpdateWithoutNotesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: UtilisateurUpdateOneRequiredWithoutEtudiantNestedInput
    inscriptions?: InscriptionUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    profileId?: IntFieldUpdateOperationsInput | number
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    inscriptions?: InscriptionUncheckedUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type MatiereCreateWithoutCoursInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    credit: number
    coefficient?: number
    nbHeure?: number | null
    uniteEnseignement: UniteEnseignementCreateNestedOneWithoutMatieresInput
  }

  export type MatiereUncheckedCreateWithoutCoursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    credit: number
    coefficient?: number
    nbHeure?: number | null
    uniteEnseignementId: number
  }

  export type MatiereCreateOrConnectWithoutCoursInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutCoursInput, MatiereUncheckedCreateWithoutCoursInput>
  }

  export type SalleCreateWithoutCoursInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    estDisponible?: boolean
    etablissement: EtablissementCreateNestedOneWithoutSalleInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutSalleInput
  }

  export type SalleUncheckedCreateWithoutCoursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    etablissementId: number
    estDisponible?: boolean
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutSalleInput
  }

  export type SalleCreateOrConnectWithoutCoursInput = {
    where: SalleWhereUniqueInput
    create: XOR<SalleCreateWithoutCoursInput, SalleUncheckedCreateWithoutCoursInput>
  }

  export type ClasseCreateWithoutCoursInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissement: EtablissementCreateNestedOneWithoutClassesInput
    semestres?: SemestreCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionCreateNestedManyWithoutClasseInput
    specialite: SpecialiteCreateNestedOneWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutClasseInput
    AnneeScolaire?: AnneeScolaireCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateWithoutCoursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    specialiteId: number
    anneeScolaireId?: number | null
    semestres?: SemestreUncheckedCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutClasseInput
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutCoursInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutCoursInput, ClasseUncheckedCreateWithoutCoursInput>
  }

  export type ProfesseurCreateWithoutCoursInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UtilisateurCreateNestedOneWithoutProfesseurInput
    EmploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutProfesseurInput
  }

  export type ProfesseurUncheckedCreateWithoutCoursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: number
    EmploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutProfesseurInput
  }

  export type ProfesseurCreateOrConnectWithoutCoursInput = {
    where: ProfesseurWhereUniqueInput
    create: XOR<ProfesseurCreateWithoutCoursInput, ProfesseurUncheckedCreateWithoutCoursInput>
  }

  export type EvaluationEtudiantsCreateWithoutCoursInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    typeEvaluation: $Enums.TypeEvaluation
    dateEvaluation: Date | string
    duree: number
    document: string
    description?: string | null
    NoteEtudiant?: NoteEtudiantCreateNestedManyWithoutEvaluationEtudiantInput
  }

  export type EvaluationEtudiantsUncheckedCreateWithoutCoursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    typeEvaluation: $Enums.TypeEvaluation
    dateEvaluation: Date | string
    duree: number
    document: string
    description?: string | null
    NoteEtudiant?: NoteEtudiantUncheckedCreateNestedManyWithoutEvaluationEtudiantInput
  }

  export type EvaluationEtudiantsCreateOrConnectWithoutCoursInput = {
    where: EvaluationEtudiantsWhereUniqueInput
    create: XOR<EvaluationEtudiantsCreateWithoutCoursInput, EvaluationEtudiantsUncheckedCreateWithoutCoursInput>
  }

  export type EvaluationEtudiantsCreateManyCoursInputEnvelope = {
    data: EvaluationEtudiantsCreateManyCoursInput | EvaluationEtudiantsCreateManyCoursInput[]
    skipDuplicates?: boolean
  }

  export type FeuillePresenceCreateWithoutCoursInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    etudiant?: EtudiantCreateNestedOneWithoutFeuillePresencesInput
  }

  export type FeuillePresenceUncheckedCreateWithoutCoursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    etudiantId?: number | null
  }

  export type FeuillePresenceCreateOrConnectWithoutCoursInput = {
    where: FeuillePresenceWhereUniqueInput
    create: XOR<FeuillePresenceCreateWithoutCoursInput, FeuillePresenceUncheckedCreateWithoutCoursInput>
  }

  export type FeuillePresenceCreateManyCoursInputEnvelope = {
    data: FeuillePresenceCreateManyCoursInput | FeuillePresenceCreateManyCoursInput[]
    skipDuplicates?: boolean
  }

  export type EmploiDuTempsCreateWithoutCoursInput = {
    dateDebut: Date | string
    dateFin: Date | string
    classe: ClasseCreateNestedOneWithoutEmploiDuTempsInput
    professeur?: ProfesseurCreateNestedOneWithoutEmploiDuTempsInput
    salle: SalleCreateNestedOneWithoutEmploiDuTempsInput
  }

  export type EmploiDuTempsUncheckedCreateWithoutCoursInput = {
    id?: number
    classeId: number
    professeurId?: number | null
    salleId: number
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type EmploiDuTempsCreateOrConnectWithoutCoursInput = {
    where: EmploiDuTempsWhereUniqueInput
    create: XOR<EmploiDuTempsCreateWithoutCoursInput, EmploiDuTempsUncheckedCreateWithoutCoursInput>
  }

  export type EmploiDuTempsCreateManyCoursInputEnvelope = {
    data: EmploiDuTempsCreateManyCoursInput | EmploiDuTempsCreateManyCoursInput[]
    skipDuplicates?: boolean
  }

  export type MatiereUpsertWithoutCoursInput = {
    update: XOR<MatiereUpdateWithoutCoursInput, MatiereUncheckedUpdateWithoutCoursInput>
    create: XOR<MatiereCreateWithoutCoursInput, MatiereUncheckedCreateWithoutCoursInput>
    where?: MatiereWhereInput
  }

  export type MatiereUpdateToOneWithWhereWithoutCoursInput = {
    where?: MatiereWhereInput
    data: XOR<MatiereUpdateWithoutCoursInput, MatiereUncheckedUpdateWithoutCoursInput>
  }

  export type MatiereUpdateWithoutCoursInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    nbHeure?: NullableIntFieldUpdateOperationsInput | number | null
    uniteEnseignement?: UniteEnseignementUpdateOneRequiredWithoutMatieresNestedInput
  }

  export type MatiereUncheckedUpdateWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    nbHeure?: NullableIntFieldUpdateOperationsInput | number | null
    uniteEnseignementId?: IntFieldUpdateOperationsInput | number
  }

  export type SalleUpsertWithoutCoursInput = {
    update: XOR<SalleUpdateWithoutCoursInput, SalleUncheckedUpdateWithoutCoursInput>
    create: XOR<SalleCreateWithoutCoursInput, SalleUncheckedCreateWithoutCoursInput>
    where?: SalleWhereInput
  }

  export type SalleUpdateToOneWithWhereWithoutCoursInput = {
    where?: SalleWhereInput
    data: XOR<SalleUpdateWithoutCoursInput, SalleUncheckedUpdateWithoutCoursInput>
  }

  export type SalleUpdateWithoutCoursInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
    etablissement?: EtablissementUpdateOneRequiredWithoutSalleNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutSalleNestedInput
  }

  export type SalleUncheckedUpdateWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    etablissementId?: IntFieldUpdateOperationsInput | number
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutSalleNestedInput
  }

  export type ClasseUpsertWithoutCoursInput = {
    update: XOR<ClasseUpdateWithoutCoursInput, ClasseUncheckedUpdateWithoutCoursInput>
    create: XOR<ClasseCreateWithoutCoursInput, ClasseUncheckedCreateWithoutCoursInput>
    where?: ClasseWhereInput
  }

  export type ClasseUpdateToOneWithWhereWithoutCoursInput = {
    where?: ClasseWhereInput
    data: XOR<ClasseUpdateWithoutCoursInput, ClasseUncheckedUpdateWithoutCoursInput>
  }

  export type ClasseUpdateWithoutCoursInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissement?: EtablissementUpdateOneRequiredWithoutClassesNestedInput
    semestres?: SemestreUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUpdateManyWithoutClasseNestedInput
    specialite?: SpecialiteUpdateOneRequiredWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutClasseNestedInput
    AnneeScolaire?: AnneeScolaireUpdateOneWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
    semestres?: SemestreUncheckedUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUncheckedUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ProfesseurUpsertWithoutCoursInput = {
    update: XOR<ProfesseurUpdateWithoutCoursInput, ProfesseurUncheckedUpdateWithoutCoursInput>
    create: XOR<ProfesseurCreateWithoutCoursInput, ProfesseurUncheckedCreateWithoutCoursInput>
    where?: ProfesseurWhereInput
  }

  export type ProfesseurUpdateToOneWithWhereWithoutCoursInput = {
    where?: ProfesseurWhereInput
    data: XOR<ProfesseurUpdateWithoutCoursInput, ProfesseurUncheckedUpdateWithoutCoursInput>
  }

  export type ProfesseurUpdateWithoutCoursInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UtilisateurUpdateOneRequiredWithoutProfesseurNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutProfesseurNestedInput
  }

  export type ProfesseurUncheckedUpdateWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: IntFieldUpdateOperationsInput | number
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutProfesseurNestedInput
  }

  export type EvaluationEtudiantsUpsertWithWhereUniqueWithoutCoursInput = {
    where: EvaluationEtudiantsWhereUniqueInput
    update: XOR<EvaluationEtudiantsUpdateWithoutCoursInput, EvaluationEtudiantsUncheckedUpdateWithoutCoursInput>
    create: XOR<EvaluationEtudiantsCreateWithoutCoursInput, EvaluationEtudiantsUncheckedCreateWithoutCoursInput>
  }

  export type EvaluationEtudiantsUpdateWithWhereUniqueWithoutCoursInput = {
    where: EvaluationEtudiantsWhereUniqueInput
    data: XOR<EvaluationEtudiantsUpdateWithoutCoursInput, EvaluationEtudiantsUncheckedUpdateWithoutCoursInput>
  }

  export type EvaluationEtudiantsUpdateManyWithWhereWithoutCoursInput = {
    where: EvaluationEtudiantsScalarWhereInput
    data: XOR<EvaluationEtudiantsUpdateManyMutationInput, EvaluationEtudiantsUncheckedUpdateManyWithoutCoursInput>
  }

  export type EvaluationEtudiantsScalarWhereInput = {
    AND?: EvaluationEtudiantsScalarWhereInput | EvaluationEtudiantsScalarWhereInput[]
    OR?: EvaluationEtudiantsScalarWhereInput[]
    NOT?: EvaluationEtudiantsScalarWhereInput | EvaluationEtudiantsScalarWhereInput[]
    id?: IntFilter<"EvaluationEtudiants"> | number
    createdAt?: DateTimeFilter<"EvaluationEtudiants"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationEtudiants"> | Date | string
    typeEvaluation?: EnumTypeEvaluationFilter<"EvaluationEtudiants"> | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFilter<"EvaluationEtudiants"> | Date | string
    duree?: IntFilter<"EvaluationEtudiants"> | number
    document?: StringFilter<"EvaluationEtudiants"> | string
    description?: StringNullableFilter<"EvaluationEtudiants"> | string | null
    coursId?: IntFilter<"EvaluationEtudiants"> | number
  }

  export type FeuillePresenceUpsertWithWhereUniqueWithoutCoursInput = {
    where: FeuillePresenceWhereUniqueInput
    update: XOR<FeuillePresenceUpdateWithoutCoursInput, FeuillePresenceUncheckedUpdateWithoutCoursInput>
    create: XOR<FeuillePresenceCreateWithoutCoursInput, FeuillePresenceUncheckedCreateWithoutCoursInput>
  }

  export type FeuillePresenceUpdateWithWhereUniqueWithoutCoursInput = {
    where: FeuillePresenceWhereUniqueInput
    data: XOR<FeuillePresenceUpdateWithoutCoursInput, FeuillePresenceUncheckedUpdateWithoutCoursInput>
  }

  export type FeuillePresenceUpdateManyWithWhereWithoutCoursInput = {
    where: FeuillePresenceScalarWhereInput
    data: XOR<FeuillePresenceUpdateManyMutationInput, FeuillePresenceUncheckedUpdateManyWithoutCoursInput>
  }

  export type EmploiDuTempsUpsertWithWhereUniqueWithoutCoursInput = {
    where: EmploiDuTempsWhereUniqueInput
    update: XOR<EmploiDuTempsUpdateWithoutCoursInput, EmploiDuTempsUncheckedUpdateWithoutCoursInput>
    create: XOR<EmploiDuTempsCreateWithoutCoursInput, EmploiDuTempsUncheckedCreateWithoutCoursInput>
  }

  export type EmploiDuTempsUpdateWithWhereUniqueWithoutCoursInput = {
    where: EmploiDuTempsWhereUniqueInput
    data: XOR<EmploiDuTempsUpdateWithoutCoursInput, EmploiDuTempsUncheckedUpdateWithoutCoursInput>
  }

  export type EmploiDuTempsUpdateManyWithWhereWithoutCoursInput = {
    where: EmploiDuTempsScalarWhereInput
    data: XOR<EmploiDuTempsUpdateManyMutationInput, EmploiDuTempsUncheckedUpdateManyWithoutCoursInput>
  }

  export type EtablissementCreateWithoutSalleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresse?: AdresseCreateNestedOneWithoutEtablissementsInput
    contact?: ContactCreateNestedOneWithoutEtablissementsInput
    utilisateurs?: UtilisateurCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementUncheckedCreateWithoutSalleInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresseId?: number | null
    contactId?: number | null
    utilisateurs?: UtilisateurUncheckedCreateNestedManyWithoutEtablissementInput
    domaines?: DomaineUncheckedCreateNestedManyWithoutEtablissementsInput
    classes?: ClasseUncheckedCreateNestedManyWithoutEtablissementInput
  }

  export type EtablissementCreateOrConnectWithoutSalleInput = {
    where: EtablissementWhereUniqueInput
    create: XOR<EtablissementCreateWithoutSalleInput, EtablissementUncheckedCreateWithoutSalleInput>
  }

  export type CoursCreateWithoutSalleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiere?: MatiereCreateNestedOneWithoutCoursInput
    classe?: ClasseCreateNestedOneWithoutCoursInput
    professeur?: ProfesseurCreateNestedOneWithoutCoursInput
    evaluationEtudiant?: EvaluationEtudiantsCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutCoursInput
  }

  export type CoursUncheckedCreateWithoutSalleInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    classeId?: number | null
    professeurId?: number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutCoursInput
  }

  export type CoursCreateOrConnectWithoutSalleInput = {
    where: CoursWhereUniqueInput
    create: XOR<CoursCreateWithoutSalleInput, CoursUncheckedCreateWithoutSalleInput>
  }

  export type CoursCreateManySalleInputEnvelope = {
    data: CoursCreateManySalleInput | CoursCreateManySalleInput[]
    skipDuplicates?: boolean
  }

  export type EmploiDuTempsCreateWithoutSalleInput = {
    dateDebut: Date | string
    dateFin: Date | string
    cours: CoursCreateNestedOneWithoutEmploiDuTempsInput
    classe: ClasseCreateNestedOneWithoutEmploiDuTempsInput
    professeur?: ProfesseurCreateNestedOneWithoutEmploiDuTempsInput
  }

  export type EmploiDuTempsUncheckedCreateWithoutSalleInput = {
    id?: number
    coursId: number
    classeId: number
    professeurId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type EmploiDuTempsCreateOrConnectWithoutSalleInput = {
    where: EmploiDuTempsWhereUniqueInput
    create: XOR<EmploiDuTempsCreateWithoutSalleInput, EmploiDuTempsUncheckedCreateWithoutSalleInput>
  }

  export type EmploiDuTempsCreateManySalleInputEnvelope = {
    data: EmploiDuTempsCreateManySalleInput | EmploiDuTempsCreateManySalleInput[]
    skipDuplicates?: boolean
  }

  export type EtablissementUpsertWithoutSalleInput = {
    update: XOR<EtablissementUpdateWithoutSalleInput, EtablissementUncheckedUpdateWithoutSalleInput>
    create: XOR<EtablissementCreateWithoutSalleInput, EtablissementUncheckedCreateWithoutSalleInput>
    where?: EtablissementWhereInput
  }

  export type EtablissementUpdateToOneWithWhereWithoutSalleInput = {
    where?: EtablissementWhereInput
    data: XOR<EtablissementUpdateWithoutSalleInput, EtablissementUncheckedUpdateWithoutSalleInput>
  }

  export type EtablissementUpdateWithoutSalleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: AdresseUpdateOneWithoutEtablissementsNestedInput
    contact?: ContactUpdateOneWithoutEtablissementsNestedInput
    utilisateurs?: UtilisateurUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateWithoutSalleInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUncheckedUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutEtablissementNestedInput
  }

  export type CoursUpsertWithWhereUniqueWithoutSalleInput = {
    where: CoursWhereUniqueInput
    update: XOR<CoursUpdateWithoutSalleInput, CoursUncheckedUpdateWithoutSalleInput>
    create: XOR<CoursCreateWithoutSalleInput, CoursUncheckedCreateWithoutSalleInput>
  }

  export type CoursUpdateWithWhereUniqueWithoutSalleInput = {
    where: CoursWhereUniqueInput
    data: XOR<CoursUpdateWithoutSalleInput, CoursUncheckedUpdateWithoutSalleInput>
  }

  export type CoursUpdateManyWithWhereWithoutSalleInput = {
    where: CoursScalarWhereInput
    data: XOR<CoursUpdateManyMutationInput, CoursUncheckedUpdateManyWithoutSalleInput>
  }

  export type EmploiDuTempsUpsertWithWhereUniqueWithoutSalleInput = {
    where: EmploiDuTempsWhereUniqueInput
    update: XOR<EmploiDuTempsUpdateWithoutSalleInput, EmploiDuTempsUncheckedUpdateWithoutSalleInput>
    create: XOR<EmploiDuTempsCreateWithoutSalleInput, EmploiDuTempsUncheckedCreateWithoutSalleInput>
  }

  export type EmploiDuTempsUpdateWithWhereUniqueWithoutSalleInput = {
    where: EmploiDuTempsWhereUniqueInput
    data: XOR<EmploiDuTempsUpdateWithoutSalleInput, EmploiDuTempsUncheckedUpdateWithoutSalleInput>
  }

  export type EmploiDuTempsUpdateManyWithWhereWithoutSalleInput = {
    where: EmploiDuTempsScalarWhereInput
    data: XOR<EmploiDuTempsUpdateManyMutationInput, EmploiDuTempsUncheckedUpdateManyWithoutSalleInput>
  }

  export type CoursCreateWithoutFeuillePresencesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiere?: MatiereCreateNestedOneWithoutCoursInput
    salle?: SalleCreateNestedOneWithoutCoursInput
    classe?: ClasseCreateNestedOneWithoutCoursInput
    professeur?: ProfesseurCreateNestedOneWithoutCoursInput
    evaluationEtudiant?: EvaluationEtudiantsCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsCreateNestedManyWithoutCoursInput
  }

  export type CoursUncheckedCreateWithoutFeuillePresencesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    salleId?: number | null
    classeId?: number | null
    professeurId?: number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedCreateNestedManyWithoutCoursInput
    emploiDuTemps?: EmploiDuTempsUncheckedCreateNestedManyWithoutCoursInput
  }

  export type CoursCreateOrConnectWithoutFeuillePresencesInput = {
    where: CoursWhereUniqueInput
    create: XOR<CoursCreateWithoutFeuillePresencesInput, CoursUncheckedCreateWithoutFeuillePresencesInput>
  }

  export type EtudiantCreateWithoutFeuillePresencesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    feuillePresencesId?: number | null
    profile: UtilisateurCreateNestedOneWithoutEtudiantInput
    inscriptions?: InscriptionCreateNestedManyWithoutEtudiantInput
    notes?: NoteEtudiantCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutFeuillePresencesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    profileId: number
    feuillePresencesId?: number | null
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutEtudiantInput
    notes?: NoteEtudiantUncheckedCreateNestedManyWithoutEtudiantInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutFeuillePresencesInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutFeuillePresencesInput, EtudiantUncheckedCreateWithoutFeuillePresencesInput>
  }

  export type CoursUpsertWithoutFeuillePresencesInput = {
    update: XOR<CoursUpdateWithoutFeuillePresencesInput, CoursUncheckedUpdateWithoutFeuillePresencesInput>
    create: XOR<CoursCreateWithoutFeuillePresencesInput, CoursUncheckedCreateWithoutFeuillePresencesInput>
    where?: CoursWhereInput
  }

  export type CoursUpdateToOneWithWhereWithoutFeuillePresencesInput = {
    where?: CoursWhereInput
    data: XOR<CoursUpdateWithoutFeuillePresencesInput, CoursUncheckedUpdateWithoutFeuillePresencesInput>
  }

  export type CoursUpdateWithoutFeuillePresencesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutCoursNestedInput
    salle?: SalleUpdateOneWithoutCoursNestedInput
    classe?: ClasseUpdateOneWithoutCoursNestedInput
    professeur?: ProfesseurUpdateOneWithoutCoursNestedInput
    evaluationEtudiant?: EvaluationEtudiantsUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateWithoutFeuillePresencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutCoursNestedInput
  }

  export type EtudiantUpsertWithoutFeuillePresencesInput = {
    update: XOR<EtudiantUpdateWithoutFeuillePresencesInput, EtudiantUncheckedUpdateWithoutFeuillePresencesInput>
    create: XOR<EtudiantCreateWithoutFeuillePresencesInput, EtudiantUncheckedCreateWithoutFeuillePresencesInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutFeuillePresencesInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutFeuillePresencesInput, EtudiantUncheckedUpdateWithoutFeuillePresencesInput>
  }

  export type EtudiantUpdateWithoutFeuillePresencesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: UtilisateurUpdateOneRequiredWithoutEtudiantNestedInput
    inscriptions?: InscriptionUpdateManyWithoutEtudiantNestedInput
    notes?: NoteEtudiantUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutFeuillePresencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    profileId?: IntFieldUpdateOperationsInput | number
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    inscriptions?: InscriptionUncheckedUpdateManyWithoutEtudiantNestedInput
    notes?: NoteEtudiantUncheckedUpdateManyWithoutEtudiantNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type CoursCreateWithoutEmploiDuTempsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiere?: MatiereCreateNestedOneWithoutCoursInput
    salle?: SalleCreateNestedOneWithoutCoursInput
    classe?: ClasseCreateNestedOneWithoutCoursInput
    professeur?: ProfesseurCreateNestedOneWithoutCoursInput
    evaluationEtudiant?: EvaluationEtudiantsCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutCoursInput
  }

  export type CoursUncheckedCreateWithoutEmploiDuTempsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    salleId?: number | null
    classeId?: number | null
    professeurId?: number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedCreateNestedManyWithoutCoursInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutCoursInput
  }

  export type CoursCreateOrConnectWithoutEmploiDuTempsInput = {
    where: CoursWhereUniqueInput
    create: XOR<CoursCreateWithoutEmploiDuTempsInput, CoursUncheckedCreateWithoutEmploiDuTempsInput>
  }

  export type ClasseCreateWithoutEmploiDuTempsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissement: EtablissementCreateNestedOneWithoutClassesInput
    semestres?: SemestreCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionCreateNestedManyWithoutClasseInput
    specialite: SpecialiteCreateNestedOneWithoutClasseInput
    Cours?: CoursCreateNestedManyWithoutClasseInput
    AnneeScolaire?: AnneeScolaireCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateWithoutEmploiDuTempsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    specialiteId: number
    anneeScolaireId?: number | null
    semestres?: SemestreUncheckedCreateNestedManyWithoutClasseInput
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutClasseInput
    Cours?: CoursUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutEmploiDuTempsInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutEmploiDuTempsInput, ClasseUncheckedCreateWithoutEmploiDuTempsInput>
  }

  export type ProfesseurCreateWithoutEmploiDuTempsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UtilisateurCreateNestedOneWithoutProfesseurInput
    cours?: CoursCreateNestedManyWithoutProfesseurInput
  }

  export type ProfesseurUncheckedCreateWithoutEmploiDuTempsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: number
    cours?: CoursUncheckedCreateNestedManyWithoutProfesseurInput
  }

  export type ProfesseurCreateOrConnectWithoutEmploiDuTempsInput = {
    where: ProfesseurWhereUniqueInput
    create: XOR<ProfesseurCreateWithoutEmploiDuTempsInput, ProfesseurUncheckedCreateWithoutEmploiDuTempsInput>
  }

  export type SalleCreateWithoutEmploiDuTempsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    estDisponible?: boolean
    etablissement: EtablissementCreateNestedOneWithoutSalleInput
    cours?: CoursCreateNestedManyWithoutSalleInput
  }

  export type SalleUncheckedCreateWithoutEmploiDuTempsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    etablissementId: number
    estDisponible?: boolean
    cours?: CoursUncheckedCreateNestedManyWithoutSalleInput
  }

  export type SalleCreateOrConnectWithoutEmploiDuTempsInput = {
    where: SalleWhereUniqueInput
    create: XOR<SalleCreateWithoutEmploiDuTempsInput, SalleUncheckedCreateWithoutEmploiDuTempsInput>
  }

  export type CoursUpsertWithoutEmploiDuTempsInput = {
    update: XOR<CoursUpdateWithoutEmploiDuTempsInput, CoursUncheckedUpdateWithoutEmploiDuTempsInput>
    create: XOR<CoursCreateWithoutEmploiDuTempsInput, CoursUncheckedCreateWithoutEmploiDuTempsInput>
    where?: CoursWhereInput
  }

  export type CoursUpdateToOneWithWhereWithoutEmploiDuTempsInput = {
    where?: CoursWhereInput
    data: XOR<CoursUpdateWithoutEmploiDuTempsInput, CoursUncheckedUpdateWithoutEmploiDuTempsInput>
  }

  export type CoursUpdateWithoutEmploiDuTempsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutCoursNestedInput
    salle?: SalleUpdateOneWithoutCoursNestedInput
    classe?: ClasseUpdateOneWithoutCoursNestedInput
    professeur?: ProfesseurUpdateOneWithoutCoursNestedInput
    evaluationEtudiant?: EvaluationEtudiantsUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateWithoutEmploiDuTempsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutCoursNestedInput
  }

  export type ClasseUpsertWithoutEmploiDuTempsInput = {
    update: XOR<ClasseUpdateWithoutEmploiDuTempsInput, ClasseUncheckedUpdateWithoutEmploiDuTempsInput>
    create: XOR<ClasseCreateWithoutEmploiDuTempsInput, ClasseUncheckedCreateWithoutEmploiDuTempsInput>
    where?: ClasseWhereInput
  }

  export type ClasseUpdateToOneWithWhereWithoutEmploiDuTempsInput = {
    where?: ClasseWhereInput
    data: XOR<ClasseUpdateWithoutEmploiDuTempsInput, ClasseUncheckedUpdateWithoutEmploiDuTempsInput>
  }

  export type ClasseUpdateWithoutEmploiDuTempsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissement?: EtablissementUpdateOneRequiredWithoutClassesNestedInput
    semestres?: SemestreUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUpdateManyWithoutClasseNestedInput
    specialite?: SpecialiteUpdateOneRequiredWithoutClasseNestedInput
    Cours?: CoursUpdateManyWithoutClasseNestedInput
    AnneeScolaire?: AnneeScolaireUpdateOneWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateWithoutEmploiDuTempsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
    semestres?: SemestreUncheckedUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUncheckedUpdateManyWithoutClasseNestedInput
    Cours?: CoursUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ProfesseurUpsertWithoutEmploiDuTempsInput = {
    update: XOR<ProfesseurUpdateWithoutEmploiDuTempsInput, ProfesseurUncheckedUpdateWithoutEmploiDuTempsInput>
    create: XOR<ProfesseurCreateWithoutEmploiDuTempsInput, ProfesseurUncheckedCreateWithoutEmploiDuTempsInput>
    where?: ProfesseurWhereInput
  }

  export type ProfesseurUpdateToOneWithWhereWithoutEmploiDuTempsInput = {
    where?: ProfesseurWhereInput
    data: XOR<ProfesseurUpdateWithoutEmploiDuTempsInput, ProfesseurUncheckedUpdateWithoutEmploiDuTempsInput>
  }

  export type ProfesseurUpdateWithoutEmploiDuTempsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UtilisateurUpdateOneRequiredWithoutProfesseurNestedInput
    cours?: CoursUpdateManyWithoutProfesseurNestedInput
  }

  export type ProfesseurUncheckedUpdateWithoutEmploiDuTempsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: IntFieldUpdateOperationsInput | number
    cours?: CoursUncheckedUpdateManyWithoutProfesseurNestedInput
  }

  export type SalleUpsertWithoutEmploiDuTempsInput = {
    update: XOR<SalleUpdateWithoutEmploiDuTempsInput, SalleUncheckedUpdateWithoutEmploiDuTempsInput>
    create: XOR<SalleCreateWithoutEmploiDuTempsInput, SalleUncheckedCreateWithoutEmploiDuTempsInput>
    where?: SalleWhereInput
  }

  export type SalleUpdateToOneWithWhereWithoutEmploiDuTempsInput = {
    where?: SalleWhereInput
    data: XOR<SalleUpdateWithoutEmploiDuTempsInput, SalleUncheckedUpdateWithoutEmploiDuTempsInput>
  }

  export type SalleUpdateWithoutEmploiDuTempsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
    etablissement?: EtablissementUpdateOneRequiredWithoutSalleNestedInput
    cours?: CoursUpdateManyWithoutSalleNestedInput
  }

  export type SalleUncheckedUpdateWithoutEmploiDuTempsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    etablissementId?: IntFieldUpdateOperationsInput | number
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
    cours?: CoursUncheckedUpdateManyWithoutSalleNestedInput
  }

  export type EtudiantCreateWithoutPaiementInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    feuillePresencesId?: number | null
    profile: UtilisateurCreateNestedOneWithoutEtudiantInput
    inscriptions?: InscriptionCreateNestedManyWithoutEtudiantInput
    notes?: NoteEtudiantCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutPaiementInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug?: string | null
    ine: string
    baccaleaureat?: string | null
    anneeBaccaleaureat?: number | null
    profileId: number
    feuillePresencesId?: number | null
    inscriptions?: InscriptionUncheckedCreateNestedManyWithoutEtudiantInput
    notes?: NoteEtudiantUncheckedCreateNestedManyWithoutEtudiantInput
    feuillePresences?: FeuillePresenceUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutPaiementInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutPaiementInput, EtudiantUncheckedCreateWithoutPaiementInput>
  }

  export type EtudiantUpsertWithoutPaiementInput = {
    update: XOR<EtudiantUpdateWithoutPaiementInput, EtudiantUncheckedUpdateWithoutPaiementInput>
    create: XOR<EtudiantCreateWithoutPaiementInput, EtudiantUncheckedCreateWithoutPaiementInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutPaiementInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutPaiementInput, EtudiantUncheckedUpdateWithoutPaiementInput>
  }

  export type EtudiantUpdateWithoutPaiementInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: UtilisateurUpdateOneRequiredWithoutEtudiantNestedInput
    inscriptions?: InscriptionUpdateManyWithoutEtudiantNestedInput
    notes?: NoteEtudiantUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ine?: StringFieldUpdateOperationsInput | string
    baccaleaureat?: NullableStringFieldUpdateOperationsInput | string | null
    anneeBaccaleaureat?: NullableIntFieldUpdateOperationsInput | number | null
    profileId?: IntFieldUpdateOperationsInput | number
    feuillePresencesId?: NullableIntFieldUpdateOperationsInput | number | null
    inscriptions?: InscriptionUncheckedUpdateManyWithoutEtudiantNestedInput
    notes?: NoteEtudiantUncheckedUpdateManyWithoutEtudiantNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type PermissionUpdateWithoutUtilisateursInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: PermissionUpdateroleInput | $Enums.Role[]
    label?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: PermissionUpdateroleInput | $Enums.Role[]
    label?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateManyWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: PermissionUpdateroleInput | $Enums.Role[]
    label?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UtilisateurUpdateWithoutPermissionsInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: ContactUpdateOneWithoutUtilisateursNestedInput
    adresse?: AdresseUpdateOneWithoutUtilisateursNestedInput
    etablissement?: EtablissementUpdateOneWithoutUtilisateursNestedInput
    etudiant?: EtudiantUpdateOneWithoutProfileNestedInput
    Professeur?: ProfesseurUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    etudiant?: EtudiantUncheckedUpdateOneWithoutProfileNestedInput
    Professeur?: ProfesseurUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateManyWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UtilisateurCreateManyAdresseInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    etablissementId?: number | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    contactId?: number | null
    accountId?: number | null
  }

  export type EtablissementCreateManyAdresseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    contactId?: number | null
  }

  export type UtilisateurUpdateWithoutAdresseInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: ContactUpdateOneWithoutUtilisateursNestedInput
    etablissement?: EtablissementUpdateOneWithoutUtilisateursNestedInput
    etudiant?: EtudiantUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    etudiant?: EtudiantUncheckedUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateManyWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EtablissementUpdateWithoutAdresseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: ContactUpdateOneWithoutEtablissementsNestedInput
    utilisateurs?: UtilisateurUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUncheckedUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUncheckedUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateManyWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReseauSocialCreateManyContactInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    username: string
    url: string
  }

  export type UtilisateurCreateManyContactInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    etablissementId?: number | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    adresseId?: number | null
    accountId?: number | null
  }

  export type EtablissementCreateManyContactInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    matricule?: string | null
    sigle?: string | null
    dateCreation?: Date | string | null
    logo?: string | null
    anneeEnCours?: string | null
    adresseId?: number | null
  }

  export type ReseauSocialUpdateWithoutContactInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ReseauSocialUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ReseauSocialUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UtilisateurUpdateWithoutContactInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    adresse?: AdresseUpdateOneWithoutUtilisateursNestedInput
    etablissement?: EtablissementUpdateOneWithoutUtilisateursNestedInput
    etudiant?: EtudiantUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    etudiant?: EtudiantUncheckedUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    etablissementId?: NullableIntFieldUpdateOperationsInput | number | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EtablissementUpdateWithoutContactInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: AdresseUpdateOneWithoutEtablissementsNestedInput
    utilisateurs?: UtilisateurUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutEtablissementNestedInput
    domaines?: DomaineUncheckedUpdateManyWithoutEtablissementsNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUncheckedUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InscriptionCreateManyEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    diplomeId: number
    classeId: number
  }

  export type NoteEtudiantCreateManyEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note: number
    evaluationEtudiantId?: number | null
  }

  export type FeuillePresenceCreateManyEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    coursId: number
  }

  export type PaiementCreateManyEtudiantInput = {
    id?: number
    montant: number
    datePaiement: Date | string
    methodePaiement: string
    referencePaiement: string
    typeFrais: string
    statutPaiement: string
  }

  export type InscriptionUpdateWithoutEtudiantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    diplome?: DiplomeUpdateOneRequiredWithoutInscriptionsNestedInput
    classe?: ClasseUpdateOneRequiredWithoutInscriptionsNestedInput
  }

  export type InscriptionUncheckedUpdateWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    diplomeId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
  }

  export type InscriptionUncheckedUpdateManyWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    diplomeId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
  }

  export type NoteEtudiantUpdateWithoutEtudiantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
    evaluationEtudiant?: EvaluationEtudiantsUpdateOneWithoutNoteEtudiantNestedInput
  }

  export type NoteEtudiantUncheckedUpdateWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
    evaluationEtudiantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NoteEtudiantUncheckedUpdateManyWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
    evaluationEtudiantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FeuillePresenceUpdateWithoutEtudiantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cours?: CoursUpdateOneRequiredWithoutFeuillePresencesNestedInput
  }

  export type FeuillePresenceUncheckedUpdateWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    coursId?: IntFieldUpdateOperationsInput | number
  }

  export type FeuillePresenceUncheckedUpdateManyWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    coursId?: IntFieldUpdateOperationsInput | number
  }

  export type PaiementUpdateWithoutEtudiantInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: StringFieldUpdateOperationsInput | string
    typeFrais?: StringFieldUpdateOperationsInput | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
  }

  export type PaiementUncheckedUpdateWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: StringFieldUpdateOperationsInput | string
    typeFrais?: StringFieldUpdateOperationsInput | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
  }

  export type PaiementUncheckedUpdateManyWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: StringFieldUpdateOperationsInput | string
    typeFrais?: StringFieldUpdateOperationsInput | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
  }

  export type CoursCreateManyProfesseurInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    salleId?: number | null
    classeId?: number | null
  }

  export type EmploiDuTempsCreateManyProfesseurInput = {
    id?: number
    coursId: number
    classeId: number
    salleId: number
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type CoursUpdateWithoutProfesseurInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutCoursNestedInput
    salle?: SalleUpdateOneWithoutCoursNestedInput
    classe?: ClasseUpdateOneWithoutCoursNestedInput
    evaluationEtudiant?: EvaluationEtudiantsUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateWithoutProfesseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateManyWithoutProfesseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmploiDuTempsUpdateWithoutProfesseurInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cours?: CoursUpdateOneRequiredWithoutEmploiDuTempsNestedInput
    classe?: ClasseUpdateOneRequiredWithoutEmploiDuTempsNestedInput
    salle?: SalleUpdateOneRequiredWithoutEmploiDuTempsNestedInput
  }

  export type EmploiDuTempsUncheckedUpdateWithoutProfesseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    coursId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
    salleId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploiDuTempsUncheckedUpdateManyWithoutProfesseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    coursId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
    salleId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentionCreateManyDomaineInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
  }

  export type EtablissementUpdateWithoutDomainesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: AdresseUpdateOneWithoutEtablissementsNestedInput
    contact?: ContactUpdateOneWithoutEtablissementsNestedInput
    utilisateurs?: UtilisateurUpdateManyWithoutEtablissementNestedInput
    classes?: ClasseUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateWithoutDomainesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateurs?: UtilisateurUncheckedUpdateManyWithoutEtablissementNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutEtablissementNestedInput
    salle?: SalleUncheckedUpdateManyWithoutEtablissementNestedInput
  }

  export type EtablissementUncheckedUpdateManyWithoutDomainesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    sigle?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    anneeEnCours?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MentionUpdateWithoutDomaineInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    specialites?: SpecialiteUpdateManyWithoutMentionNestedInput
  }

  export type MentionUncheckedUpdateWithoutDomaineInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    specialites?: SpecialiteUncheckedUpdateManyWithoutMentionNestedInput
  }

  export type MentionUncheckedUpdateManyWithoutDomaineInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecialiteCreateManyMentionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    slug?: string | null
  }

  export type SpecialiteUpdateWithoutMentionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    Classe?: ClasseUpdateManyWithoutSpecialiteNestedInput
    Diplome?: DiplomeUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteUncheckedUpdateWithoutMentionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    Classe?: ClasseUncheckedUpdateManyWithoutSpecialiteNestedInput
    Diplome?: DiplomeUncheckedUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteUncheckedUpdateManyWithoutMentionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClasseCreateManySpecialiteInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    anneeScolaireId?: number | null
  }

  export type DiplomeCreateManySpecialiteInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    finalite: string
    entite: string
    habilitation: string
    partenaires?: DiplomeCreatepartenairesInput | string[]
    dateCreation: Date | string
    dateHabilitation: Date | string
    dateEcheance: Date | string
    duree: number
  }

  export type ClasseUpdateWithoutSpecialiteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissement?: EtablissementUpdateOneRequiredWithoutClassesNestedInput
    semestres?: SemestreUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUpdateManyWithoutClasseNestedInput
    Cours?: CoursUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutClasseNestedInput
    AnneeScolaire?: AnneeScolaireUpdateOneWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateWithoutSpecialiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
    semestres?: SemestreUncheckedUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUncheckedUpdateManyWithoutClasseNestedInput
    Cours?: CoursUncheckedUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateManyWithoutSpecialiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DiplomeUpdateWithoutSpecialiteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    finalite?: StringFieldUpdateOperationsInput | string
    entite?: StringFieldUpdateOperationsInput | string
    habilitation?: StringFieldUpdateOperationsInput | string
    partenaires?: DiplomeUpdatepartenairesInput | string[]
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHabilitation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    inscriptions?: InscriptionUpdateManyWithoutDiplomeNestedInput
  }

  export type DiplomeUncheckedUpdateWithoutSpecialiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    finalite?: StringFieldUpdateOperationsInput | string
    entite?: StringFieldUpdateOperationsInput | string
    habilitation?: StringFieldUpdateOperationsInput | string
    partenaires?: DiplomeUpdatepartenairesInput | string[]
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHabilitation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    inscriptions?: InscriptionUncheckedUpdateManyWithoutDiplomeNestedInput
  }

  export type DiplomeUncheckedUpdateManyWithoutSpecialiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    finalite?: StringFieldUpdateOperationsInput | string
    entite?: StringFieldUpdateOperationsInput | string
    habilitation?: StringFieldUpdateOperationsInput | string
    partenaires?: DiplomeUpdatepartenairesInput | string[]
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHabilitation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
  }

  export type InscriptionCreateManyDiplomeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    etudiantId: number
    classeId: number
  }

  export type InscriptionUpdateWithoutDiplomeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    etudiant?: EtudiantUpdateOneRequiredWithoutInscriptionsNestedInput
    classe?: ClasseUpdateOneRequiredWithoutInscriptionsNestedInput
  }

  export type InscriptionUncheckedUpdateWithoutDiplomeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    etudiantId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
  }

  export type InscriptionUncheckedUpdateManyWithoutDiplomeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    etudiantId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
  }

  export type UniteEnseignementCreateManySemestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    numero?: number
    credit: number
  }

  export type UniteEnseignementUpdateWithoutSemestreInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    credit?: IntFieldUpdateOperationsInput | number
    matieres?: MatiereUpdateManyWithoutUniteEnseignementNestedInput
  }

  export type UniteEnseignementUncheckedUpdateWithoutSemestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    credit?: IntFieldUpdateOperationsInput | number
    matieres?: MatiereUncheckedUpdateManyWithoutUniteEnseignementNestedInput
  }

  export type UniteEnseignementUncheckedUpdateManyWithoutSemestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    credit?: IntFieldUpdateOperationsInput | number
  }

  export type MatiereCreateManyUniteEnseignementInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    nom: string
    credit: number
    coefficient?: number
    nbHeure?: number | null
  }

  export type MatiereUpdateWithoutUniteEnseignementInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    nbHeure?: NullableIntFieldUpdateOperationsInput | number | null
    cours?: CoursUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutUniteEnseignementInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    nbHeure?: NullableIntFieldUpdateOperationsInput | number | null
    cours?: CoursUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateManyWithoutUniteEnseignementInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    nbHeure?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CoursCreateManyMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    salleId?: number | null
    classeId?: number | null
    professeurId?: number | null
  }

  export type CoursUpdateWithoutMatiereInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: SalleUpdateOneWithoutCoursNestedInput
    classe?: ClasseUpdateOneWithoutCoursNestedInput
    professeur?: ProfesseurUpdateOneWithoutCoursNestedInput
    evaluationEtudiant?: EvaluationEtudiantsUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateManyWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UtilisateurCreateManyEtablissementInput = {
    id?: number
    matricule: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prenom: string
    nom: string
    dateNaissance?: Date | string | null
    lieuNaissance?: string | null
    cni?: string | null
    genre: $Enums.Genre
    nationalite?: string | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    statutCompte?: string | null
    roles?: UtilisateurCreaterolesInput | $Enums.Role[]
    contactId?: number | null
    adresseId?: number | null
    accountId?: number | null
  }

  export type ClasseCreateManyEtablissementInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    specialiteId: number
    anneeScolaireId?: number | null
  }

  export type SalleCreateManyEtablissementInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    capacite?: number | null
    batiment?: string | null
    estDisponible?: boolean
  }

  export type UtilisateurUpdateWithoutEtablissementInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: ContactUpdateOneWithoutUtilisateursNestedInput
    adresse?: AdresseUpdateOneWithoutUtilisateursNestedInput
    etudiant?: EtudiantUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutEtablissementInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    etudiant?: EtudiantUncheckedUpdateOneWithoutProfileNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutUtilisateursNestedInput
    Professeur?: ProfesseurUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UtilisateurUncheckedUpdateManyWithoutEtablissementInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    cni?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: EnumGenreFieldUpdateOperationsInput | $Enums.Genre
    nationalite?: NullableStringFieldUpdateOperationsInput | string | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    statutCompte?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UtilisateurUpdaterolesInput | $Enums.Role[]
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DomaineUpdateWithoutEtablissementsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    mentions?: MentionUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUncheckedUpdateWithoutEtablissementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    mentions?: MentionUncheckedUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUncheckedUpdateManyWithoutEtablissementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClasseUpdateWithoutEtablissementInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    semestres?: SemestreUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUpdateManyWithoutClasseNestedInput
    specialite?: SpecialiteUpdateOneRequiredWithoutClasseNestedInput
    Cours?: CoursUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutClasseNestedInput
    AnneeScolaire?: AnneeScolaireUpdateOneWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateWithoutEtablissementInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    specialiteId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
    semestres?: SemestreUncheckedUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUncheckedUpdateManyWithoutClasseNestedInput
    Cours?: CoursUncheckedUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateManyWithoutEtablissementInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    specialiteId?: IntFieldUpdateOperationsInput | number
    anneeScolaireId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SalleUpdateWithoutEtablissementInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
    cours?: CoursUpdateManyWithoutSalleNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutSalleNestedInput
  }

  export type SalleUncheckedUpdateWithoutEtablissementInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
    cours?: CoursUncheckedUpdateManyWithoutSalleNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutSalleNestedInput
  }

  export type SalleUncheckedUpdateManyWithoutEtablissementInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    capacite?: NullableIntFieldUpdateOperationsInput | number | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    estDisponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SemestreCreateManyClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    numero: number
    grade: $Enums.TypeDiplome
    dateDebut: Date | string
    dateFin: Date | string
    nombreSemaine: number
  }

  export type InscriptionCreateManyClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference: string
    premiereInscription?: boolean
    dernierDiplome?: string | null
    autreEtablissement?: string | null
    activiteProfessionnel?: string | null
    niveau?: string | null
    statut?: string | null
    diplomeId: number
    etudiantId: number
  }

  export type CoursCreateManyClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    salleId?: number | null
    professeurId?: number | null
  }

  export type EmploiDuTempsCreateManyClasseInput = {
    id?: number
    coursId: number
    professeurId?: number | null
    salleId: number
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type SemestreUpdateWithoutClasseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numero?: IntFieldUpdateOperationsInput | number
    grade?: EnumTypeDiplomeFieldUpdateOperationsInput | $Enums.TypeDiplome
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreSemaine?: IntFieldUpdateOperationsInput | number
    uniteEnseignement?: UniteEnseignementUpdateManyWithoutSemestreNestedInput
  }

  export type SemestreUncheckedUpdateWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numero?: IntFieldUpdateOperationsInput | number
    grade?: EnumTypeDiplomeFieldUpdateOperationsInput | $Enums.TypeDiplome
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreSemaine?: IntFieldUpdateOperationsInput | number
    uniteEnseignement?: UniteEnseignementUncheckedUpdateManyWithoutSemestreNestedInput
  }

  export type SemestreUncheckedUpdateManyWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numero?: IntFieldUpdateOperationsInput | number
    grade?: EnumTypeDiplomeFieldUpdateOperationsInput | $Enums.TypeDiplome
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreSemaine?: IntFieldUpdateOperationsInput | number
  }

  export type InscriptionUpdateWithoutClasseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    diplome?: DiplomeUpdateOneRequiredWithoutInscriptionsNestedInput
    etudiant?: EtudiantUpdateOneRequiredWithoutInscriptionsNestedInput
  }

  export type InscriptionUncheckedUpdateWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    diplomeId?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
  }

  export type InscriptionUncheckedUpdateManyWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    premiereInscription?: BoolFieldUpdateOperationsInput | boolean
    dernierDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    autreEtablissement?: NullableStringFieldUpdateOperationsInput | string | null
    activiteProfessionnel?: NullableStringFieldUpdateOperationsInput | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    diplomeId?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
  }

  export type CoursUpdateWithoutClasseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutCoursNestedInput
    salle?: SalleUpdateOneWithoutCoursNestedInput
    professeur?: ProfesseurUpdateOneWithoutCoursNestedInput
    evaluationEtudiant?: EvaluationEtudiantsUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateManyWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmploiDuTempsUpdateWithoutClasseInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cours?: CoursUpdateOneRequiredWithoutEmploiDuTempsNestedInput
    professeur?: ProfesseurUpdateOneWithoutEmploiDuTempsNestedInput
    salle?: SalleUpdateOneRequiredWithoutEmploiDuTempsNestedInput
  }

  export type EmploiDuTempsUncheckedUpdateWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    coursId?: IntFieldUpdateOperationsInput | number
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploiDuTempsUncheckedUpdateManyWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    coursId?: IntFieldUpdateOperationsInput | number
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClasseCreateManyAnneeScolaireInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    code: string
    niveau: string
    etablissementId: number
    specialiteId: number
  }

  export type ClasseUpdateWithoutAnneeScolaireInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissement?: EtablissementUpdateOneRequiredWithoutClassesNestedInput
    semestres?: SemestreUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUpdateManyWithoutClasseNestedInput
    specialite?: SpecialiteUpdateOneRequiredWithoutClasseNestedInput
    Cours?: CoursUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateWithoutAnneeScolaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
    semestres?: SemestreUncheckedUpdateManyWithoutClasseNestedInput
    inscriptions?: InscriptionUncheckedUpdateManyWithoutClasseNestedInput
    Cours?: CoursUncheckedUpdateManyWithoutClasseNestedInput
    EmploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateManyWithoutAnneeScolaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveau?: StringFieldUpdateOperationsInput | string
    etablissementId?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
  }

  export type NoteEtudiantCreateManyEvaluationEtudiantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note: number
    etudiantId: number
  }

  export type NoteEtudiantUpdateWithoutEvaluationEtudiantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
    etudiant?: EtudiantUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteEtudiantUncheckedUpdateWithoutEvaluationEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
  }

  export type NoteEtudiantUncheckedUpdateManyWithoutEvaluationEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: FloatFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationEtudiantsCreateManyCoursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    typeEvaluation: $Enums.TypeEvaluation
    dateEvaluation: Date | string
    duree: number
    document: string
    description?: string | null
  }

  export type FeuillePresenceCreateManyCoursInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    etudiantId?: number | null
  }

  export type EmploiDuTempsCreateManyCoursInput = {
    id?: number
    classeId: number
    professeurId?: number | null
    salleId: number
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type EvaluationEtudiantsUpdateWithoutCoursInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvaluation?: EnumTypeEvaluationFieldUpdateOperationsInput | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    NoteEtudiant?: NoteEtudiantUpdateManyWithoutEvaluationEtudiantNestedInput
  }

  export type EvaluationEtudiantsUncheckedUpdateWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvaluation?: EnumTypeEvaluationFieldUpdateOperationsInput | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    NoteEtudiant?: NoteEtudiantUncheckedUpdateManyWithoutEvaluationEtudiantNestedInput
  }

  export type EvaluationEtudiantsUncheckedUpdateManyWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvaluation?: EnumTypeEvaluationFieldUpdateOperationsInput | $Enums.TypeEvaluation
    dateEvaluation?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeuillePresenceUpdateWithoutCoursInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    etudiant?: EtudiantUpdateOneWithoutFeuillePresencesNestedInput
  }

  export type FeuillePresenceUncheckedUpdateWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    etudiantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FeuillePresenceUncheckedUpdateManyWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    etudiantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmploiDuTempsUpdateWithoutCoursInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    classe?: ClasseUpdateOneRequiredWithoutEmploiDuTempsNestedInput
    professeur?: ProfesseurUpdateOneWithoutEmploiDuTempsNestedInput
    salle?: SalleUpdateOneRequiredWithoutEmploiDuTempsNestedInput
  }

  export type EmploiDuTempsUncheckedUpdateWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploiDuTempsUncheckedUpdateManyWithoutCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    salleId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursCreateManySalleInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    description?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    heureDebut: Date | string
    heureFin: Date | string
    matiereId?: number | null
    classeId?: number | null
    professeurId?: number | null
  }

  export type EmploiDuTempsCreateManySalleInput = {
    id?: number
    coursId: number
    classeId: number
    professeurId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
  }

  export type CoursUpdateWithoutSalleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutCoursNestedInput
    classe?: ClasseUpdateOneWithoutCoursNestedInput
    professeur?: ProfesseurUpdateOneWithoutCoursNestedInput
    evaluationEtudiant?: EvaluationEtudiantsUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateWithoutSalleInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationEtudiant?: EvaluationEtudiantsUncheckedUpdateManyWithoutCoursNestedInput
    feuillePresences?: FeuillePresenceUncheckedUpdateManyWithoutCoursNestedInput
    emploiDuTemps?: EmploiDuTempsUncheckedUpdateManyWithoutCoursNestedInput
  }

  export type CoursUncheckedUpdateManyWithoutSalleInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    heureFin?: DateTimeFieldUpdateOperationsInput | Date | string
    matiereId?: NullableIntFieldUpdateOperationsInput | number | null
    classeId?: NullableIntFieldUpdateOperationsInput | number | null
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmploiDuTempsUpdateWithoutSalleInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cours?: CoursUpdateOneRequiredWithoutEmploiDuTempsNestedInput
    classe?: ClasseUpdateOneRequiredWithoutEmploiDuTempsNestedInput
    professeur?: ProfesseurUpdateOneWithoutEmploiDuTempsNestedInput
  }

  export type EmploiDuTempsUncheckedUpdateWithoutSalleInput = {
    id?: IntFieldUpdateOperationsInput | number
    coursId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploiDuTempsUncheckedUpdateManyWithoutSalleInput = {
    id?: IntFieldUpdateOperationsInput | number
    coursId?: IntFieldUpdateOperationsInput | number
    classeId?: IntFieldUpdateOperationsInput | number
    professeurId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UtilisateurCountOutputTypeDefaultArgs instead
     */
    export type UtilisateurCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UtilisateurCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdresseCountOutputTypeDefaultArgs instead
     */
    export type AdresseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdresseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactCountOutputTypeDefaultArgs instead
     */
    export type ContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtudiantCountOutputTypeDefaultArgs instead
     */
    export type EtudiantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtudiantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfesseurCountOutputTypeDefaultArgs instead
     */
    export type ProfesseurCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfesseurCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DomaineCountOutputTypeDefaultArgs instead
     */
    export type DomaineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DomaineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentionCountOutputTypeDefaultArgs instead
     */
    export type MentionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecialiteCountOutputTypeDefaultArgs instead
     */
    export type SpecialiteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialiteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiplomeCountOutputTypeDefaultArgs instead
     */
    export type DiplomeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiplomeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SemestreCountOutputTypeDefaultArgs instead
     */
    export type SemestreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SemestreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UniteEnseignementCountOutputTypeDefaultArgs instead
     */
    export type UniteEnseignementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UniteEnseignementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatiereCountOutputTypeDefaultArgs instead
     */
    export type MatiereCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatiereCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtablissementCountOutputTypeDefaultArgs instead
     */
    export type EtablissementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtablissementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClasseCountOutputTypeDefaultArgs instead
     */
    export type ClasseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClasseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnneeScolaireCountOutputTypeDefaultArgs instead
     */
    export type AnneeScolaireCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnneeScolaireCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationEtudiantsCountOutputTypeDefaultArgs instead
     */
    export type EvaluationEtudiantsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationEtudiantsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoursCountOutputTypeDefaultArgs instead
     */
    export type CoursCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalleCountOutputTypeDefaultArgs instead
     */
    export type SalleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UtilisateurDefaultArgs instead
     */
    export type UtilisateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UtilisateurDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdresseDefaultArgs instead
     */
    export type AdresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdresseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReseauSocialDefaultArgs instead
     */
    export type ReseauSocialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReseauSocialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtudiantDefaultArgs instead
     */
    export type EtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtudiantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfesseurDefaultArgs instead
     */
    export type ProfesseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfesseurDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InscriptionDefaultArgs instead
     */
    export type InscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DomaineDefaultArgs instead
     */
    export type DomaineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DomaineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentionDefaultArgs instead
     */
    export type MentionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecialiteDefaultArgs instead
     */
    export type SpecialiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiplomeDefaultArgs instead
     */
    export type DiplomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiplomeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SemestreDefaultArgs instead
     */
    export type SemestreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SemestreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UniteEnseignementDefaultArgs instead
     */
    export type UniteEnseignementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UniteEnseignementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatiereDefaultArgs instead
     */
    export type MatiereArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatiereDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtablissementDefaultArgs instead
     */
    export type EtablissementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtablissementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClasseDefaultArgs instead
     */
    export type ClasseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClasseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnneeScolaireDefaultArgs instead
     */
    export type AnneeScolaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnneeScolaireDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationEtudiantsDefaultArgs instead
     */
    export type EvaluationEtudiantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationEtudiantsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteEtudiantDefaultArgs instead
     */
    export type NoteEtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteEtudiantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoursDefaultArgs instead
     */
    export type CoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalleDefaultArgs instead
     */
    export type SalleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeuillePresenceDefaultArgs instead
     */
    export type FeuillePresenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeuillePresenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmploiDuTempsDefaultArgs instead
     */
    export type EmploiDuTempsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmploiDuTempsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaiementDefaultArgs instead
     */
    export type PaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaiementDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}