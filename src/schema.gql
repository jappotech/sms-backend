# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account {
  createdAt: DateTime
  etablissementId: Int!
  id: ID!
  isActive: Boolean!
  password: String
  roles: [String!]!
  uid: String
  updatedAt: DateTime
  userId: Float
  username: String
}

input AccountOrderByWithRelationInput {
  createdAt: SortOrder!
  id: SortOrder!
  isActive: SortOrder!
  password: SortOrder!
  roles: SortOrder!
  uid: SortOrder!
  updatedAt: SortOrder!
  userId: SortOrder!
  username: SortOrder!
}

enum AccountScalarFieldEnum {
  createdAt
  id
  isActive
  password
  roles
  uid
  updatedAt
  userId
  username
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  isActive: BoolFilter
  password: StringFilter
  roles: StringFilter
  uid: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  username: StringFilter
}

input AccountWhereUniqueInput {
  id: Float!
}

type Adresse {
  codePostal: String
  geolocalisation: String
  id: Float
  pays: String
  region: String
  ville: String
}

input AdresseOrderByWithRelationInput {
  codePostal: SortOrder
  etablissements: EtablissementOrderByRelationAggregateInput
  geolocalisation: SortOrder
  id: SortOrder
  pays: SortOrder
  region: SortOrder
  utilisateurs: UtilisateurOrderByRelationAggregateInput
  ville: SortOrder
}

input AdresseRelationFilter {
  is: [AdresseWhereInput!]
  isNot: [AdresseWhereInput!]
}

enum AdresseScalarFieldEnum {
  codePostal
  geolocalisation
  id
  pays
  region
  ville
}

input AdresseWhereInput {
  AND: [AdresseWhereInput!]
  NOT: [AdresseWhereInput!]
  OR: [AdresseWhereInput!]
  codePostal: StringFilter
  etablissements: EtablissementListRelationFilter
  geolocalisation: StringFilter
  id: IntFilter
  pays: StringFilter
  region: StringFilter
  utilisateurs: UtilisateurListRelationFilter
  ville: StringFilter
}

input AdresseWhereUniqueInput {
  id: Float
}

type AnneeScolaire {
  createdAt: DateTime
  dateDebut: Float
  dateFin: Float
  id: Float
  nom: String
  updatedAt: DateTime
}

input AnneeScolaireOrderByWithRelationInput {
  classes: CoursOrderByRelationAggregateInput
  createdAt: SortOrder
  dateDebut: SortOrder
  dateFin: SortOrder
  id: SortOrder
  nom: SortOrder
  updatedAt: SortOrder
}

input AnneeScolaireRelationFilter {
  is: AnneeScolaireWhereInput
  isNot: AnneeScolaireWhereInput
}

enum AnneeScolaireScalarFieldEnum {
  createdAt
  dateDebut
  dateFin
  id
  nom
  updatedAt
}

input AnneeScolaireWhereInput {
  AND: [AnneeScolaireWhereInput!]
  NOT: [AnneeScolaireWhereInput!]
  OR: [AnneeScolaireWhereInput!]
  classes: ClasseListRelationFilter
  createdAt: DateTimeFilter
  dateDebut: IntFilter
  dateFin: IntFilter
  id: IntFilter
  nom: StringFilter
  updatedAt: DateTimeFilter
}

input AnneeScolaireWhereUniqueInput {
  id: Float!
}

input BoolFilter {
  equals: Boolean
  not: Boolean
}

type BulletinNotes {
  donnees: [ListeNotes!]
  etudiant: Etudiant
  moyenneGenerale: MoyenneGenerale
}

input BulletinNotesAnnuelWhereUniqueInput {
  classeId: Float!
  etudiantId: Float!
}

input BulletinNotesWhereUniqueInput {
  classeId: Float!
  etudiantId: Float!
  semestreId: Float!
}

type Classe {
  anneeScolaire: AnneeScolaire!
  anneeScolaireId: Float
  code: String
  cours: [Cours!]!
  createdAt: DateTime
  etablissementId: Float
  evaluations: [EvaluationEtudiants!]!
  id: Float
  inscriptions: [Inscription!]!
  niveau: String
  nom: String
  semestres: [Semestre!]!
  specialite: Specialite!
  specialiteId: Float
  uniteEnseignements: [UniteEnseignement!]
  updatedAt: DateTime
}

input ClasseListRelationFilter {
  every: ClasseWhereInput
  none: ClasseWhereInput
  some: ClasseWhereInput
}

input ClasseOrderByRelationAggregateInput {
  _count: SortOrder
}

input ClasseOrderByWithRelationInput {
  AnneeScolaire: SortOrder
  Cours: CoursOrderByRelationAggregateInput
  EmploiDuTemps: EmploiDuTempsOrderByRelationAggregateInput
  anneeScolaireId: SortOrder
  code: SortOrder
  createdAt: SortOrder
  etablissement: EtablissementOrderByWithRelationInput
  etablissementId: SortOrder
  id: SortOrder
  inscriptions: InscriptionOrderByRelationAggregateInput
  niveau: SortOrder
  nom: SortOrder
  specialite: SpecialiteOrderByWithRelationInput
  specialiteId: SortOrder
  uniteEnseignements: UniteEnseignementOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input ClasseRelationFilter {
  is: ClasseWhereInput
  isNot: ClasseWhereInput
}

enum ClasseScalarFieldEnum {
  anneeScolaireId
  code
  createdAt
  etablissementId
  id
  niveau
  nom
  specialiteId
  updatedAt
}

input ClasseWhereInput {
  AND: [ClasseWhereInputStrict!]
  AnneeScolaire: AnneeScolaireRelationFilter
  Cours: CoursListRelationFilter
  EmploiDuTemps: EmploiDuTempsListRelationFilter
  NOT: [ClasseWhereInputStrict!]
  OR: [ClasseWhereInputStrict!]
  anneeScolaireId: IntFilter
  code: StringFilter
  createdAt: DateTimeFilter
  etablissement: EtablissementRelationFilter
  etablissementId: IntFilter
  id: IntFilter
  inscriptions: InscriptionListRelationFilter
  niveau: StringFilter
  nom: StringFilter
  specialite: SpecialiteRelationFilter
  specialiteId: IntFilter
  uniteEnseignements: UniteEnseignementListRelationFilter
  updatedAt: DateTimeFilter
}

input ClasseWhereInputStrict {
  AND: [ClasseWhereInputStrict!]
  AnneeScolaire: AnneeScolaireRelationFilter
  Cours: CoursListRelationFilter
  EmploiDuTemps: EmploiDuTempsListRelationFilter
  NOT: [ClasseWhereInputStrict!]
  OR: [ClasseWhereInputStrict!]
  anneeScolaireId: IntFilter
  code: StringFilter
  createdAt: DateTimeFilter
  etablissement: EtablissementRelationFilter
  etablissementId: IntFilter
  id: IntFilter
  inscriptions: InscriptionListRelationFilter
  niveau: StringFilter
  nom: StringFilter
  specialite: SpecialiteRelationFilter
  specialiteId: IntFilter
  uniteEnseignements: UniteEnseignementListRelationFilter
  updatedAt: DateTimeFilter
}

input ClasseWhereUniqueInput {
  id: Float
}

type Contact {
  createdAt: DateTime
  email: String
  fax: String
  fix: String
  id: Float
  siteWeb: String
  telephone: String!
  updatedAt: DateTime
}

input ContactOrderByWithRelationInput {
  createdAt: SortOrder
  email: SortOrder
  etablissements: EtablissementOrderByRelationAggregateInput
  fax: SortOrder
  fix: SortOrder
  id: SortOrder
  reseauxSociaux: ReseauSocialOrderByRelationAggregateInput
  siteWeb: SortOrder
  telephone: SortOrder
  updatedAt: SortOrder
  utilisateurs: UtilisateurOrderByRelationAggregateInput
}

input ContactRelationFilter {
  is: ContactWhereInput
  isNot: ContactWhereInput
}

enum ContactScalarFieldEnum {
  createdAt
  email
  fax
  fix
  id
  siteWeb
  telephone
  updatedAt
}

input ContactWhereInput {
  AND: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  etablissements: EtablissementListRelationFilter
  fax: StringFilter
  fix: StringFilter
  id: IntFilter
  reseauxSociaux: ReseauSocialListRelationFilter
  siteWeb: StringFilter
  telephone: StringFilter
  updatedAt: DateTimeFilter
  utilisateurs: UtilisateurListRelationFilter
}

input ContactWhereUniqueInput {
  id: Float
}

type Cours {
  classe: Classe!
  classeId: Float
  createdAt: DateTime
  dateDebut: DateTime
  dateFin: DateTime
  description: String
  heureDebut: DateTime
  heureFin: DateTime
  id: Float
  matiere: Matiere!
  matiereId: Float
  nom: String
  professeur: Professeur!
  professeurId: Float
  salle: Salle!
  salleId: Float
  updatedAt: DateTime
}

input CoursListRelationFilter {
  every: CoursWhereInput
  none: CoursWhereInput
  some: CoursWhereInput
}

input CoursOrderByRelationAggregateInput {
  _count: SortOrder
}

input CoursOrderByWithRelationInput {
  classe: ClasseOrderByWithRelationInput
  classeId: SortOrder
  createdAt: SortOrder
  dateDebut: SortOrder
  dateFin: SortOrder
  description: SortOrder
  emploiDuTemps: EmploiDuTempsOrderByRelationAggregateInput
  evaluationEtudiant: EvaluationEtudiantsOrderByRelationAggregateInput
  feuillePresences: FeuillePresenceOrderByRelationAggregateInput
  heureDebut: SortOrder
  heureFin: SortOrder
  id: SortOrder
  matiere: MatiereOrderByWithRelationInput
  matiereId: SortOrder
  nom: SortOrder
  professeur: ProfesseurOrderByWithRelationInput
  professeurId: SortOrder
  salle: SalleOrderByWithRelationInput
  salleId: SortOrder
  updatedAt: SortOrder
}

input CoursRelationFilter {
  is: CoursWhereInput
  isNot: CoursWhereInput
}

enum CoursScalarFieldEnum {
  classeId
  createdAt
  dateDebut
  dateFin
  description
  heureDebut
  heureFin
  id
  matiereId
  nom
  professeurId
  salleId
  updatedAt
}

input CoursWhereInput {
  AND: [CoursWhereInput!]
  AnneeScolaire: AnneeScolaireRelationFilter
  NOT: [CoursWhereInput!]
  OR: [CoursWhereInput!]
  anneeScolaireId: IntFilter
  classe: ClasseRelationFilter
  classeId: IntFilter
  createdAt: DateTimeFilter
  dateDebut: DateTimeFilter
  dateFin: DateTimeFilter
  description: StringFilter
  emploiDuTemps: EmploiDuTempsListRelationFilter
  evaluationEtudiant: EvaluationEtudiantsListRelationFilter
  feuillePresences: FeuillePresenceListRelationFilter
  heureDebut: DateTimeFilter
  heureFin: DateTimeFilter
  id: IntFilter
  matiere: MatiereRelationFilter
  matiereId: IntFilter
  nom: StringFilter
  professeur: ProfesseurRelationFilter
  professeurId: IntFilter
  salle: SalleRelationFilter
  salleId: IntFilter
  updatedAt: DateTimeFilter
}

input CoursWhereUniqueInput {
  id: Float!
}

input CreateAccountInput {
  password: String
  roles: [String!]! = ["UTILISATEUR"]
  userId: Float
  username: String
}

input CreateAdresseInput {
  codePostal: String
  geolocalisation: String
  pays: String
  region: String
  ville: String
}

input CreateAnneeScolaireInput {
  dateDebut: Float
  dateFin: Float
  nom: String
}

input CreateClasseInput {
  anneeScolaireId: Float
  code: String
  etablissementId: Float
  niveau: String
  nom: String
  specialiteId: Float
}

input CreateContactInput {
  email: String
  fax: String
  fix: String
  siteWeb: String
  telephone: String!
}

input CreateCoursInput {
  classeId: Float
  dateDebut: DateTime
  dateFin: DateTime
  description: String
  heureDebut: DateTime
  heureFin: DateTime
  matiereId: Float
  nom: String
  professeurId: Float
  salleId: Float
}

input CreateDiplomeInput {
  dateCreation: DateTime
  dateEcheance: DateTime
  dateHabilitation: DateTime
  duree: Float
  entite: String
  finalite: String
  habilitation: String
  nom: String
  partenaires: [String!]
  specialiteId: Float
}

input CreateDomaineInput {
  mentions: [CreateMentionInput!]
  nom: String
}

input CreateDomaineInputWithId {
  id: Float
  nom: String
}

input CreateEmploiDuTempsInput {
  classeId: Float
  color: String
  coursId: Float
  daysOfWeek: [String!]
  endRecur: String
  endTime: String
  professeurId: Float
  salleId: Float
  startRecur: String
  startTime: String
  title: String
}

input CreateEtablissementInput {
  adresseId: Float
  anneeEnCours: String
  contactId: Float
  dateCreation: DateTime
  domaines: [CreateDomaineInputWithId!]
  logo: String
  matricule: String
  nom: String
  sigle: String
}

input CreateEtudiantInput {
  anneeBaccaleaureat: Float
  baccaleaureat: String
  feuillePresencesId: Float
  ine: String
  profile: UtilisateurWithAccount!
}

input CreateEvaluationEtudiantsInput {
  coursId: Float
  dateEvaluation: DateTime
  description: String
  document: String
  duree: Float
  typeEvaluation: String!
}

input CreateFeuillePresenceInput {
  coursId: Float
  date: DateTime
  etudiantId: Float
  heureDebut: DateTime
  heureFin: DateTime
}

input CreateInscriptionInput {
  activiteProfessionnel: String
  autreEtablissement: String
  classeId: Float
  dernierDiplome: String
  diplomeId: Float
  etudiantId: Float
  niveau: String
  premiereInscription: Boolean! = false
  reference: String
  statut: String
}

input CreateMatiereInput {
  code: String
  coefficient: Float
  credit: Float
  nbHeure: Float
  nom: String
  uniteEnseignementId: Float
}

input CreateMentionInput {
  domaineId: Float
  nom: String
  specialites: [CreateSpecialiteInput!]
}

input CreateNoteEtudiantInput {
  etudiantId: Float
  evaluationEtudiantId: Float
  note: Float
}

input CreatePaiementInput {
  datePaiement: DateTime
  etudiantId: Float
  methodePaiement: String
  montant: Float
  referencePaiement: String
  statutPaiement: String
  typeFrais: String
}

input CreatePermissionInput {
  label: String
  role: [String!]!
}

input CreateProfesseurInput {
  profile: UtilisateurWithAccount!
}

input CreateReseauSocialInput {
  contactId: Float
  nom: String
  url: String
  username: String
}

input CreateSalleInput {
  batiment: String
  capacite: Float
  estDisponible: Boolean
  etablissementId: Float
  nom: String
}

input CreateSemestreInput {
  dateDebut: DateTime
  dateFin: DateTime
  etablissementId: Float
  grade: String!
  nombreSemaine: Float
  numero: Float
}

input CreateSpecialiteInput {
  etablissementId: Float
  mentionId: Float
  nom: String
}

input CreateUniteEnseignementInput {
  classeId: Float
  code: String
  credit: Float
  nom: String
  numero: Float
  semestreId: Float
}

input CreateUtilisateurInput {
  account: CreateAccountInput
  adresseId: Float
  cni: String
  contactId: Float
  dateNaissance: DateTime
  etablissementId: Float
  genre: String! = "Masculin"
  groupeSanguin: String
  lieuNaissance: String
  matricule: String
  nationalite: String
  nom: String
  prenom: String
  roles: [String!]
  statutCompte: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  notIn: [String!]
}

type Diplome {
  createdAt: DateTime
  dateCreation: DateTime
  dateEcheance: DateTime
  dateHabilitation: DateTime
  duree: Float
  entite: String
  finalite: String
  habilitation: String
  id: Float
  nom: String
  partenaires: [String!]
  specialiteId: Float
  updatedAt: DateTime
}

input DiplomeListRelationFilter {
  every: DiplomeWhereInput
  none: DiplomeWhereInput
  some: DiplomeWhereInput
}

input DiplomeOrderByRelationAggregateInput {
  _count: SortOrder
}

input DiplomeOrderByWithRelationInput {
  createdAt: SortOrder
  dateCreation: SortOrder
  dateEcheance: SortOrder
  dateHabilitation: SortOrder
  duree: SortOrder
  entite: SortOrder
  finalite: SortOrder
  habilitation: SortOrder
  id: SortOrder
  inscriptions: InscriptionOrderByRelationAggregateInput
  nom: SortOrder
  partenaires: SortOrder
  specialite: SpecialiteOrderByWithRelationInput
  specialiteId: SortOrder
  updatedAt: SortOrder
}

input DiplomeRelationFilter {
  is: DiplomeWhereInput
  isNot: DiplomeWhereInput
}

enum DiplomeScalarFieldEnum {
  createdAt
  dateCreation
  dateEcheance
  dateHabilitation
  duree
  entite
  finalite
  habilitation
  id
  nom
  partenaires
  specialiteId
  updatedAt
}

input DiplomeWhereInput {
  AND: [DiplomeWhereInput!]
  NOT: [DiplomeWhereInput!]
  OR: [DiplomeWhereInput!]
  createdAt: DateTimeFilter
  dateCreation: DateTimeFilter
  dateEcheance: DateTimeFilter
  dateHabilitation: DateTimeFilter
  duree: IntFilter
  entite: StringFilter
  finalite: StringFilter
  habilitation: StringFilter
  id: IntFilter
  inscriptions: InscriptionListRelationFilter
  nom: StringFilter
  partenaires: StringListFilter
  specialite: SpecialiteRelationFilter
  specialiteId: IntFilter
  updatedAt: DateTimeFilter
}

input DiplomeWhereUniqueInput {
  id: Float
}

type Domaine {
  createdAt: DateTime
  id: Float
  mentions: [Mention!]!
  nom: String
  slug: String
  updatedAt: DateTime
}

input DomaineListRelationFilter {
  every: DomaineWhereInput
  none: DomaineWhereInput
  some: DomaineWhereInput
}

input DomaineOrderByWithRelationInput {
  createdAt: SortOrder
  etablissements: EtablissementOrderByRelationAggregateInput
  id: SortOrder
  mentions: MentionOrderByRelationAggregateInput
  nom: SortOrder
  slug: SortOrder
  updatedAt: SortOrder
}

input DomaineRelationFilter {
  is: DomaineWhereInput
  isNot: DomaineWhereInput
}

enum DomaineScalarFieldEnum {
  createdAt
  id
  nom
  slug
  updatedAt
}

input DomaineWhereInput {
  AND: [DomaineWhereInput!]
  NOT: [DomaineWhereInput!]
  OR: [DomaineWhereInput!]
  createdAt: DateTimeFilter
  etablissements: EtablissementListRelationFilter
  id: IntFilter
  mentions: MentionListRelationFilter
  nom: StringFilter
  slug: StringFilter
  updatedAt: DateTimeFilter
}

input DomaineWhereUniqueInput {
  id: Float
}

type EmploiDuTemps {
  classeId: Float
  color: String
  coursId: Float
  daysOfWeek: [String!]
  endRecur: String
  endTime: String
  id: Float
  professeurId: Float
  salleId: Float
  startRecur: String
  startTime: String
  title: String
}

input EmploiDuTempsListRelationFilter {
  every: EmploiDuTempsWhereInput
  none: EmploiDuTempsWhereInput
  some: EmploiDuTempsWhereInput
}

input EmploiDuTempsOrderByRelationAggregateInput {
  _count: SortOrder
}

input EmploiDuTempsWhereInput {
  AND: [EmploiDuTempsWhereInput!]
  NOT: [EmploiDuTempsWhereInput!]
  OR: [EmploiDuTempsWhereInput!]
  classe: ClasseRelationFilter
  classeId: IntFilter
  color: StringFilter
  cours: CoursRelationFilter
  coursId: IntFilter
  daysOfWeek: StringListFilter
  endRecur: StringFilter
  endTime: StringFilter
  id: IntFilter
  professeur: ProfesseurRelationFilter
  professeurId: IntFilter
  salle: SalleRelationFilter
  salleId: IntFilter
  startRecur: StringFilter
  startTime: StringFilter
  title: StringFilter
}

input EmploiDuTempsWhereUniqueInput {
  id: Float
}

type Etablissement {
  adresse: Adresse!
  adresseId: Float
  anneeEnCours: String
  contact: Contact!
  contactId: Float
  createdAt: DateTime
  dateCreation: DateTime
  domaines: [Domaine!]!
  id: Float
  logo: String
  matricule: String
  nom: String
  sigle: String
  updatedAt: DateTime
}

input EtablissementListRelationFilter {
  every: EtablissementWhereInput
  none: EtablissementWhereInput
  some: EtablissementWhereInput
}

input EtablissementOrderByRelationAggregateInput {
  _count: SortOrder
}

input EtablissementOrderByWithRelationInput {
  adresse: SortOrder
  adresseId: SortOrder
  anneeEnCours: SortOrder
  classes: SortOrder
  contact: SortOrder
  contactId: SortOrder
  createdAt: SortOrder
  dateCreation: SortOrder
  domaines: SortOrder
  id: SortOrder
  logo: SortOrder
  matricule: SortOrder
  nom: SortOrder
  salle: SortOrder
  sigle: SortOrder
  updatedAt: SortOrder
  utilisateurs: SortOrder
}

input EtablissementRelationFilter {
  is: EtablissementWhereInput
  isNot: EtablissementWhereInput
}

enum EtablissementScalarFieldEnum {
  adresseId
  anneeEnCours
  contactId
  createdAt
  dateCreation
  id
  logo
  matricule
  nom
  sigle
  updatedAt
}

input EtablissementWhereInput {
  AND: [EtablissementWhereInput!]
  NOT: [EtablissementWhereInput!]
  OR: [EtablissementWhereInput!]
  adresse: AdresseRelationFilter
  adresseId: IntFilter
  anneeEnCours: StringFilter
  classes: ClasseListRelationFilter
  contact: ContactRelationFilter
  contactId: IntFilter
  createdAt: DateTimeFilter
  dateCreation: StringFilter
  domaines: DomaineListRelationFilter
  id: IntFilter
  logo: StringFilter
  matricule: StringFilter
  nom: StringFilter
  salle: SalleListRelationFilter
  sigle: StringFilter
  updatedAt: DateTimeFilter
  utilisateurs: UtilisateurListRelationFilter
}

input EtablissementWhereUniqueInput {
  id: Float
}

type Etudiant {
  anneeBaccaleaureat: Float
  baccaleaureat: String
  createdAt: DateTime
  feuillePresencesId: Float
  id: Float
  ine: String
  inscriptions: [Inscription!]!
  notes: [NoteEtudiant!]!
  profile: Utilisateur!
  profileId: Float
  slug: String
  updatedAt: DateTime
}

input EtudiantOrderByWithRelationInput {
  Paiement: PaiementOrderByRelationAggregateInput
  anneeBaccaleaureat: SortOrder
  baccaleaureat: SortOrder
  createdAt: SortOrder
  feuillePresences: FeuillePresenceOrderByRelationAggregateInput
  feuillePresencesId: SortOrder
  id: SortOrder
  ine: SortOrder
  inscriptions: InscriptionOrderByRelationAggregateInput
  notes: NoteEtudiantOrderByRelationAggregateInput
  profile: UtilisateurOrderByWithRelationInput
  profileId: SortOrder
  slug: SortOrder
  updatedAt: SortOrder
}

input EtudiantRelationFilter {
  is: EtudiantWhereInput
  isNot: EtudiantWhereInput
}

enum EtudiantScalarFieldEnum {
  anneeBaccaleaureat
  baccaleaureat
  createdAt
  feuillePresencesId
  id
  ine
  profileId
  slug
  updatedAt
}

input EtudiantWhereInput {
  AND: [EtudiantWhereInput!]
  NOT: [EtudiantWhereInput!]
  OR: [EtudiantWhereInput!]
  Paiement: PaiementListRelationFilter
  anneeBaccaleaureat: IntFilter
  baccaleaureat: StringFilter
  createdAt: DateTimeFilter
  feuillePresences: FeuillePresenceListRelationFilter
  feuillePresencesId: IntFilter
  id: IntFilter
  ine: StringFilter
  inscriptions: InscriptionListRelationFilter
  notes: NoteEtudiantListRelationFilter
  profile: UtilisateurRelationFilter
  profileId: IntFilter
  slug: StringFilter
  updatedAt: DateTimeFilter
}

input EtudiantWhereUniqueInput {
  id: Float
}

type EvaluationEtudiants {
  Cours: Cours!
  NoteEtudiant: [NoteEtudiant!]!
  coursId: Float
  createdAt: DateTime
  dateEvaluation: DateTime
  description: String
  document: String
  duree: Float
  id: Float
  typeEvaluation: String!
  updatedAt: DateTime
}

input EvaluationEtudiantsListRelationFilter {
  every: EvaluationEtudiantsWhereInput
  none: EvaluationEtudiantsWhereInput
  some: EvaluationEtudiantsWhereInput
}

input EvaluationEtudiantsOrderByRelationAggregateInput {
  _count: SortOrder
}

input EvaluationEtudiantsOrderByWithRelationInput {
  NoteEtudiant: NoteEtudiantOrderByRelationAggregateInput
  cours: CoursOrderByWithRelationInput
  coursId: SortOrder
  createdAt: SortOrder
  dateEvaluation: SortOrder
  description: SortOrder
  document: SortOrder
  duree: SortOrder
  id: SortOrder
  typeEvaluation: SortOrder
  updatedAt: SortOrder
}

input EvaluationEtudiantsRelationFilter {
  is: EvaluationEtudiantsWhereInput
  isNot: EvaluationEtudiantsWhereInput
}

enum EvaluationEtudiantsScalarFieldEnum {
  coursId
  createdAt
  dateEvaluation
  description
  document
  duree
  id
  typeEvaluation
  updatedAt
}

input EvaluationEtudiantsWhereInput {
  AND: [EvaluationEtudiantsWhereInput!]
  NOT: [EvaluationEtudiantsWhereInput!]
  NoteEtudiant: NoteEtudiantListRelationFilter
  OR: [EvaluationEtudiantsWhereInput!]
  cours: CoursRelationFilter
  coursId: IntFilter
  createdAt: DateTimeFilter
  dateEvaluation: DateTimeFilter
  description: StringFilter
  document: StringFilter
  duree: IntFilter
  id: IntFilter
  typeEvaluation: StringFilter
  updatedAt: DateTimeFilter
}

input EvaluationEtudiantsWhereUniqueInput {
  id: Float
}

type FeuillePresence {
  coursId: Float
  createdAt: DateTime
  date: DateTime
  etudiantId: Float
  heureDebut: DateTime
  heureFin: DateTime
  id: Float
  updatedAt: DateTime
}

input FeuillePresenceListRelationFilter {
  every: FeuillePresenceWhereInput
  none: FeuillePresenceWhereInput
  some: FeuillePresenceWhereInput
}

input FeuillePresenceOrderByRelationAggregateInput {
  _count: SortOrder
}

input FeuillePresenceOrderByWithRelationInput {
  cours: CoursOrderByWithRelationInput
  coursId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  etudiant: EtudiantOrderByWithRelationInput
  etudiantId: SortOrder
  heureDebut: SortOrder
  heureFin: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

enum FeuillePresenceScalarFieldEnum {
  coursId
  createdAt
  date
  etudiantId
  heureDebut
  heureFin
  id
  updatedAt
}

input FeuillePresenceWhereInput {
  AND: [FeuillePresenceWhereInput!]
  NOT: [FeuillePresenceWhereInput!]
  OR: [FeuillePresenceWhereInput!]
  cours: CoursRelationFilter
  coursId: IntFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  etudiant: EtudiantRelationFilter
  etudiantId: IntFilter
  heureDebut: DateTimeFilter
  heureFin: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
}

input FeuillePresenceWhereUniqueInput {
  id: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  not: Float
}

input ImportInscriptionsInput {
  """ID de la classe où les étudiants seront inscrits"""
  classeId: String!

  """Fichier Excel ou CSV contenant les inscriptions"""
  file: Upload!

  """
  Nom de la feuille Excel à utiliser. Si non spécifié, la première feuille sera utilisée.
  """
  sheetName: String

  """Statut par défaut des inscriptions"""
  statut: String

  """Type de paiement par défaut"""
  typePaiement: String
}

type ImportResult {
  count: Int!
  inscriptions: [Inscription!]!
  success: Boolean!
}

type Inscription {
  activiteProfessionnel: String
  autreEtablissement: String
  classe: Classe!
  classeId: Float
  createdAt: DateTime!
  dernierDiplome: String
  diplome: Diplome!
  diplomeId: Float
  etudiant: Etudiant!
  etudiantId: Float
  id: Float
  niveau: String
  premiereInscription: Boolean!
  reference: String
  statut: String
  updatedAt: DateTime
}

input InscriptionListRelationFilter {
  every: InscriptionWhereInput
  none: InscriptionWhereInput
  some: InscriptionWhereInput
}

input InscriptionOrderByRelationAggregateInput {
  _count: SortOrder
}

input InscriptionOrderByWithRelationInput {
  activiteProfessionnel: SortOrder
  autreEtablissement: SortOrder
  classe: ClasseOrderByWithRelationInput
  classeId: SortOrder
  createdAt: SortOrder
  dernierDiplome: SortOrder
  diplome: DiplomeOrderByWithRelationInput
  diplomeId: SortOrder
  etudiant: EtudiantOrderByWithRelationInput
  etudiantId: SortOrder
  id: SortOrder
  niveau: SortOrder
  premiereInscription: SortOrder
  reference: SortOrder
  statut: SortOrder
  updatedAt: SortOrder
}

enum InscriptionScalarFieldEnum {
  activiteProfessionnel
  autreEtablissement
  classeId
  createdAt
  dernierDiplome
  diplomeId
  etudiantId
  id
  niveau
  premiereInscription
  reference
  statut
  updatedAt
}

input InscriptionWhereInput {
  AND: [InscriptionWhereInput!]
  NOT: [InscriptionWhereInput!]
  OR: [InscriptionWhereInput!]
  activiteProfessionnel: StringFilter
  autreEtablissement: StringFilter
  classe: ClasseRelationFilter
  classeId: IntFilter
  createdAt: DateTimeFilter
  dernierDiplome: StringFilter
  diplome: DiplomeRelationFilter
  diplomeId: IntFilter
  etudiant: EtudiantRelationFilter
  etudiantId: IntFilter
  id: IntFilter
  niveau: StringFilter
  premiereInscription: BoolFilter
  reference: StringFilter
  statut: StringFilter
  updatedAt: DateTimeFilter
}

input InscriptionWhereUniqueInput {
  id: Float
}

input IntFilter {
  equals: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
}

type ListeNotes {
  creditObtenu: Float
  decision: String
  moyenneUE: Float
  notes: [Note!]
  uniteEnseignement: UniteEnseignement
}

input LoginInput {
  password: String!
  username: String!
}

type LoginResponse {
  access_token: String!
}

type Matiere {
  code: String
  coefficient: Float
  createdAt: DateTime
  credit: Float
  id: Float
  nbHeure: Float
  nom: String
  uniteEnseignement: UniteEnseignement!
  uniteEnseignementId: Float
  updatedAt: DateTime
}

input MatiereListRelationFilter {
  every: MatiereWhereInput
  none: MatiereWhereInput
  some: MatiereWhereInput
}

input MatiereOrderByRelationAggregateInput {
  _count: SortOrder
}

input MatiereOrderByWithRelationInput {
  code: SortOrder
  coefficient: SortOrder
  cours: CoursOrderByRelationAggregateInput
  createdAt: SortOrder
  credit: SortOrder
  id: SortOrder
  nbHeure: SortOrder
  nom: SortOrder
  uniteEnseignement: UniteEnseignementOrderByWithRelationInput
  uniteEnseignementId: SortOrder
  updatedAt: SortOrder
}

input MatiereRelationFilter {
  is: MatiereWhereInput
  isNot: MatiereWhereInput
}

enum MatiereScalarFieldEnum {
  code
  coefficient
  createdAt
  credit
  id
  nbHeure
  nom
  uniteEnseignementId
  updatedAt
}

input MatiereWhereInput {
  AND: [MatiereWhereInput!]
  NOT: [MatiereWhereInput!]
  OR: [MatiereWhereInput!]
  code: StringFilter
  coefficient: IntFilter
  cours: CoursListRelationFilter
  createdAt: DateTimeFilter
  credit: IntFilter
  id: IntFilter
  nbHeure: IntFilter
  nom: StringFilter
  uniteEnseignement: UniteEnseignementRelationFilter
  uniteEnseignementId: IntFilter
  updatedAt: DateTimeFilter
}

input MatiereWhereUniqueInput {
  id: Float
}

type Mention {
  createdAt: DateTime
  domaine: Domaine!
  domaineId: Float
  id: Float
  nom: String
  slug: String
  specialites: [Specialite!]!
  updatedAt: DateTime
}

input MentionListRelationFilter {
  every: MentionWhereInput
  none: MentionWhereInput
  some: MentionWhereInput
}

input MentionOrderByRelationAggregateInput {
  _count: SortOrder
}

input MentionOrderByWithRelationInput {
  createdAt: SortOrder
  domaine: DomaineOrderByWithRelationInput
  domaineId: SortOrder
  id: SortOrder
  nom: SortOrder
  slug: SortOrder
  specialites: SpecialiteOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input MentionRelationFilter {
  is: MentionWhereInput
  isNot: MentionWhereInput
}

enum MentionScalarFieldEnum {
  createdAt
  domaineId
  id
  nom
  slug
  updatedAt
}

input MentionWhereInput {
  AND: [MentionWhereInput!]
  NOT: [MentionWhereInput!]
  OR: [MentionWhereInput!]
  createdAt: DateTimeFilter
  domaine: DomaineRelationFilter
  domaineId: IntFilter
  id: IntFilter
  nom: StringFilter
  slug: StringFilter
  specialites: SpecialiteListRelationFilter
  updatedAt: DateTimeFilter
}

input MentionWhereUniqueInput {
  id: Float
}

type MoyenneGenerale {
  moyenneSemestre: Float
  moyenneTotalCoef: Float
  nbCreditsObtenus: Float
  totalCoef: Float
  totalCredit: Float
}

type Mutation {
  createAccount(createAccountInput: CreateAccountInput!): Account!
  createAdresse(createAdresseInput: CreateAdresseInput!): Adresse!
  createAnneeScolaire(createAnneeScolaireInput: CreateAnneeScolaireInput!): AnneeScolaire!
  createClasse(createClasseInput: CreateClasseInput!): Classe!
  createContact(createContactInput: CreateContactInput!): Contact!
  createCours(createCoursInput: CreateCoursInput!): Cours!
  createDiplome(createDiplomeInput: CreateDiplomeInput!): Diplome!
  createDomaine(createDomaineInput: CreateDomaineInput!): Domaine!
  createEmploiDuTemps(createEmploiDuTempsInput: CreateEmploiDuTempsInput!): EmploiDuTemps!
  createEtablissement(createEtablissementInput: CreateEtablissementInput!): Etablissement!
  createEtudiant(createEtudiantInput: CreateEtudiantInput!): Etudiant!
  createEvaluationEtudiants(createEvaluationEtudiantsInput: CreateEvaluationEtudiantsInput!): EvaluationEtudiants!
  createFeuillePresence(createFeuillePresenceInput: CreateFeuillePresenceInput!): FeuillePresence!
  createInscription(createInscriptionInput: CreateInscriptionInput!): Inscription!
  createMatiere(createMatiereInput: CreateMatiereInput!): Matiere!
  createMention(createMentionInput: CreateMentionInput!): Mention!
  createNoteEtudiant(createNoteEtudiantInput: CreateNoteEtudiantInput!): NoteEtudiant!
  createPaiement(createPaiementInput: CreatePaiementInput!): Paiement!
  createPermission(createPermissionInput: CreatePermissionInput!): Permission!
  createProfesseur(createProfesseurInput: CreateProfesseurInput!): Professeur!
  createReseauSocial(createReseauSocialInput: CreateReseauSocialInput!): ReseauSocial!
  createSalle(createSalleInput: CreateSalleInput!): Salle!
  createSemestre(createSemestreInput: CreateSemestreInput!): Semestre!
  createSpecialite(createSpecialiteInput: CreateSpecialiteInput!): Specialite!
  createUniteEnseignement(createUniteEnseignementInput: CreateUniteEnseignementInput!): UniteEnseignement!
  createUtilisateur(createUtilisateurInput: CreateUtilisateurInput!): Utilisateur!
  genererCodeUniteEnseignement(genererCodeUniteEnseignement: UpdateUniteEnseignementInput!): UniteEnseignement!
  importInscriptions(importInput: ImportInscriptionsInput!): ImportResult!
  login(loginInput: LoginInput!): LoginResponse!
  removeAccount(where: AccountWhereUniqueInput!): Account!
  removeAdresse(where: AdresseWhereUniqueInput!): Adresse!
  removeAnneeScolaire(where: AnneeScolaireWhereUniqueInput!): AnneeScolaire!
  removeClasse(where: ClasseWhereUniqueInput!): Classe!
  removeContact(where: ContactWhereUniqueInput!): Contact!
  removeCours(where: CoursWhereUniqueInput!): Cours!
  removeDiplome(where: DiplomeWhereUniqueInput!): Diplome!
  removeDomaine(where: DomaineWhereUniqueInput!): Domaine!
  removeEmploiDuTemps(where: EmploiDuTempsWhereUniqueInput!): EmploiDuTemps!
  removeEtablissement(where: EtablissementWhereUniqueInput!): Etablissement!
  removeEtudiant(where: EtudiantWhereUniqueInput!): Etudiant!
  removeEvaluationEtudiants(where: EvaluationEtudiantsWhereUniqueInput!): EvaluationEtudiants!
  removeFeuillePresence(where: FeuillePresenceWhereUniqueInput!): FeuillePresence!
  removeInscription(where: InscriptionWhereUniqueInput!): Inscription!
  removeMatiere(where: MatiereWhereUniqueInput!): Matiere!
  removeMention(where: MentionWhereUniqueInput!): Mention!
  removeNoteEtudiant(where: NoteEtudiantWhereUniqueInput!): NoteEtudiant!
  removePaiement(where: PaiementWhereUniqueInput!): Paiement!
  removePermission(where: PermissionWhereUniqueInput!): Permission!
  removeProfesseur(where: ProfesseurWhereUniqueInput!): Professeur!
  removeReseauSocial(where: ReseauSocialWhereUniqueInput!): ReseauSocial!
  removeSalle(where: SalleWhereUniqueInput!): Salle!
  removeSemestre(where: SemestreWhereUniqueInput!): Semestre!
  removeSpecialite(where: SpecialiteWhereUniqueInput!): Specialite!
  removeUniteEnseignement(where: UniteEnseignementWhereUniqueInput!): UniteEnseignement!
  removeUtilisateur(where: UtilisateurWhereUniqueInput!): Utilisateur!
  updateAccount(updateAccountInput: UpdateAccountInput!): Account!
  updateAdresse(updateAdresseInput: UpdateAdresseInput!): Adresse!
  updateAnneeScolaire(updateAnneeScolaireInput: UpdateAnneeScolaireInput!): AnneeScolaire!
  updateClasse(updateClasseInput: UpdateClasseInput!): Classe!
  updateContact(updateContactInput: UpdateContactInput!): Contact!
  updateCours(updateCoursInput: UpdateCoursInput!): Cours!
  updateDiplome(updateDiplomeInput: UpdateDiplomeInput!): Diplome!
  updateDomaine(updateDomaineInput: UpdateDomaineInput!): Domaine!
  updateEmploiDuTemps(updateEmploiDuTempsInput: UpdateEmploiDuTempsInput!): EmploiDuTemps!
  updateEtablissement(updateEtablissementInput: UpdateEtablissementInput!): Etablissement!
  updateEtudiant(updateEtudiantInput: UpdateEtudiantInput!): Etudiant!
  updateEvaluationEtudiants(updateEvaluationEtudiantsInput: UpdateEvaluationEtudiantsInput!): EvaluationEtudiants!
  updateFeuillePresence(updateFeuillePresenceInput: UpdateFeuillePresenceInput!): FeuillePresence!
  updateInscription(updateInscriptionInput: UpdateInscriptionInput!): Inscription!
  updateMatiere(updateMatiereInput: UpdateMatiereInput!): Matiere!
  updateMention(updateMentionInput: UpdateMentionInput!): Mention!
  updateNoteEtudiant(updateNoteEtudiantInput: UpdateNoteEtudiantInput!): NoteEtudiant!
  updatePaiement(updatePaiementInput: UpdatePaiementInput!): Paiement!
  updatePermission(updatePermissionInput: UpdatePermissionInput!): Permission!
  updateProfesseur(updateProfesseurInput: UpdateProfesseurInput!): Professeur!
  updateReseauSocial(updateReseauSocialInput: UpdateReseauSocialInput!): ReseauSocial!
  updateSalle(updateSalleInput: UpdateSalleInput!): Salle!
  updateSemestre(updateSemestreInput: UpdateSemestreInput!): Semestre!
  updateSpecialite(updateSpecialiteInput: UpdateSpecialiteInput!): Specialite!
  updateUniteEnseignement(updateUniteEnseignementInput: UpdateUniteEnseignementInput!): UniteEnseignement!
  updateUtilisateur(updateUtilisateurInput: UpdateUtilisateurInput!): Utilisateur!
}

type Note {
  matiere: Matiere
  moyenne: Float
  moyenneCoeff: Float
  note: [NoteEtudiant!]
  resultat: Boolean
}

type NoteEtudiant {
  createdAt: DateTime
  etudiant: Etudiant!
  etudiantId: Float
  evaluation: EvaluationEtudiants!
  evaluationEtudiantId: Float
  id: Float
  note: Float
  updatedAt: DateTime
}

input NoteEtudiantListRelationFilter {
  every: NoteEtudiantWhereInput
  none: NoteEtudiantWhereInput
  some: NoteEtudiantWhereInput
}

input NoteEtudiantOrderByRelationAggregateInput {
  _count: SortOrder
}

input NoteEtudiantOrderByWithRelationInput {
  createdAt: SortOrder
  etudiant: EtudiantOrderByWithRelationInput
  etudiantId: SortOrder
  evaluationEtudiant: EvaluationEtudiantsOrderByWithRelationInput
  evaluationEtudiantId: SortOrder
  id: SortOrder
  note: SortOrder
  updatedAt: SortOrder
}

enum NoteEtudiantScalarFieldEnum {
  createdAt
  etudiantId
  evaluationEtudiantId
  id
  note
  updatedAt
}

input NoteEtudiantWhereInput {
  AND: [NoteEtudiantWhereInput!]
  NOT: [NoteEtudiantWhereInput!]
  OR: [NoteEtudiantWhereInput!]
  createdAt: DateTimeFilter
  etudiant: EtudiantRelationFilter
  etudiantId: IntFilter
  evaluationEtudiant: EvaluationEtudiantsRelationFilter
  evaluationEtudiantId: IntFilter
  id: IntFilter
  note: FloatFilter
  updatedAt: DateTimeFilter
}

input NoteEtudiantWhereUniqueInput {
  id: Float
}

type Paiement {
  datePaiement: DateTime
  etudiantId: Float
  id: Float
  methodePaiement: String
  montant: Float
  referencePaiement: String
  statutPaiement: String
  typeFrais: String
}

input PaiementListRelationFilter {
  every: PaiementWhereInput
  none: PaiementWhereInput
  some: PaiementWhereInput
}

input PaiementOrderByRelationAggregateInput {
  _count: SortOrder
}

input PaiementOrderByWithRelationInput {
  datePaiement: SortOrder
  etudiant: EtudiantOrderByWithRelationInput
  etudiantId: SortOrder
  id: SortOrder
  methodePaiement: SortOrder
  montant: SortOrder
  referencePaiement: SortOrder
  statutPaiement: SortOrder
  typeFrais: SortOrder
}

enum PaiementScalarFieldEnum {
  datePaiement
  etudiantId
  id
  methodePaiement
  montant
  referencePaiement
  statutPaiement
  typeFrais
}

input PaiementWhereInput {
  AND: [PaiementWhereInput!]
  NOT: [PaiementWhereInput!]
  OR: [PaiementWhereInput!]
  datePaiement: DateTimeFilter
  etudiant: EtudiantRelationFilter
  etudiantId: IntFilter
  id: IntFilter
  methodePaiement: StringFilter
  montant: FloatFilter
  referencePaiement: StringFilter
  statutPaiement: StringFilter
  typeFrais: StringFilter
}

input PaiementWhereUniqueInput {
  id: Float
}

type Permission {
  createdAt: DateTime
  id: Float
  label: String
  role: [String!]!
  slug: String
  updatedAt: DateTime
}

input PermissionListRelationFilter {
  every: PermissionWhereInput
  none: PermissionWhereInput
  some: PermissionWhereInput
}

input PermissionOrderByRelationAggregateInput {
  _count: SortOrder
}

input PermissionOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  label: SortOrder
  role: SortOrder
  slug: SortOrder
  updatedAt: SortOrder
  utilisateurs: UtilisateurOrderByRelationAggregateInput
}

enum PermissionScalarFieldEnum {
  createdAt
  id
  label
  role
  slug
  updatedAt
}

input PermissionWhereInput {
  AND: [PermissionWhereInput!]
  NOT: [PermissionWhereInput!]
  OR: [PermissionWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  label: StringFilter
  role: StringFilter
  slug: StringFilter
  updatedAt: DateTimeFilter
  utilisateurs: UtilisateurListRelationFilter
}

input PermissionWhereUniqueInput {
  id: Float
}

type Professeur {
  createdAt: DateTime
  id: Float
  profile: Utilisateur!
  profileId: Float
  updatedAt: DateTime
}

input ProfesseurOrderByWithRelationInput {
  EmploiDuTemps: EmploiDuTempsOrderByRelationAggregateInput
  cours: CoursOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  profile: UtilisateurOrderByWithRelationInput
  profileId: SortOrder
  updatedAt: SortOrder
}

input ProfesseurRelationFilter {
  is: ProfesseurWhereInput
  isNot: ProfesseurWhereInput
}

enum ProfesseurScalarFieldEnum {
  createdAt
  id
  profileId
  updatedAt
}

input ProfesseurWhereInput {
  AND: [ProfesseurWhereInput!]
  EmploiDuTemps: EmploiDuTempsListRelationFilter
  NOT: [ProfesseurWhereInput!]
  OR: [ProfesseurWhereInput!]
  cours: CoursListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  profile: UtilisateurRelationFilter
  profileId: IntFilter
  updatedAt: DateTimeFilter
}

input ProfesseurWhereUniqueInput {
  id: Float
}

type Query {
  account(where: AccountWhereUniqueInput!): Account!
  accounts(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationInput!], skip: Float, take: Float, where: AccountWhereInput): [Account!]!
  adresse(where: AdresseWhereUniqueInput!): Adresse!
  adresses(cursor: AdresseWhereUniqueInput, distinct: [AdresseScalarFieldEnum!], orderBy: [AdresseOrderByWithRelationInput!], skip: Float, take: Float, where: AdresseWhereInput): [Adresse!]!
  all_cours(cursor: CoursWhereUniqueInput, distinct: [CoursScalarFieldEnum!], orderBy: [CoursOrderByWithRelationInput!], skip: Float, take: Float, where: CoursWhereInput): [Cours!]!
  anneeScolaire(where: AnneeScolaireWhereUniqueInput!): AnneeScolaire!
  anneeScolaires(cursor: AnneeScolaireWhereUniqueInput, distinct: [AnneeScolaireScalarFieldEnum!], orderBy: [AnneeScolaireOrderByWithRelationInput!], skip: Float, take: Float, where: AnneeScolaireWhereInput): [AnneeScolaire!]!
  bulletinNotesAnnuel(where: BulletinNotesAnnuelWhereUniqueInput!): [BulletinNotes!]!
  bulletinNotesSemestre(where: BulletinNotesWhereUniqueInput!): BulletinNotes!
  bulletinNotesValidationAnnee(where: BulletinNotesAnnuelWhereUniqueInput!): ResultatAnnuel!
  bulletinNotesValidationSemestre(where: BulletinNotesWhereUniqueInput!): String!
  classe(where: ClasseWhereUniqueInput!): Classe!
  classes(cursor: ClasseWhereUniqueInput, distinct: [ClasseScalarFieldEnum!], orderBy: [ClasseOrderByWithRelationInput!], skip: Float, take: Float, where: ClasseWhereInput): [Classe!]!
  contact(where: ContactWhereUniqueInput!): Contact!
  contacts(cursor: ContactWhereUniqueInput, distinct: [ContactScalarFieldEnum!], orderBy: [ContactOrderByWithRelationInput!], skip: Float, take: Float, where: ContactWhereInput): [Contact!]!
  cours(where: CoursWhereUniqueInput!): Cours!
  diplome(where: DiplomeWhereUniqueInput!): Diplome!
  diplomes(cursor: DiplomeWhereUniqueInput, distinct: [DiplomeScalarFieldEnum!], orderBy: [DiplomeOrderByWithRelationInput!], skip: Float, take: Float, where: DiplomeWhereInput): [Diplome!]!
  domaine(where: DomaineWhereUniqueInput!): Domaine!
  domaines(cursor: DomaineWhereUniqueInput, distinct: [DomaineScalarFieldEnum!], orderBy: [DomaineOrderByWithRelationInput!], skip: Float, take: Float, where: DomaineWhereInput): [Domaine!]!
  domaines_etablissement(cursor: DomaineWhereUniqueInput, distinct: [DomaineScalarFieldEnum!], orderBy: [DomaineOrderByWithRelationInput!], skip: Float, take: Float, where: DomaineWhereInput): [Domaine!]!
  emploiDuTemps(where: EmploiDuTempsWhereUniqueInput!): EmploiDuTemps!
  etablissement(where: EtablissementWhereUniqueInput!): Etablissement!
  etablissements(cursor: EtablissementWhereUniqueInput, distinct: [EtablissementScalarFieldEnum!], orderBy: [EtablissementOrderByWithRelationInput!], skip: Float, take: Float, where: EtablissementWhereInput): [Etablissement!]!
  etudiant(where: EtudiantWhereUniqueInput!): Etudiant!
  etudiants(cursor: EtudiantWhereUniqueInput, distinct: [EtudiantScalarFieldEnum!], orderBy: [EtudiantOrderByWithRelationInput!], skip: Float, take: Float, where: EtudiantWhereInput): [Etudiant!]!
  evaluationEtudiants(where: EvaluationEtudiantsWhereUniqueInput!): EvaluationEtudiants!
  evaluationsEtudiants(cursor: EvaluationEtudiantsWhereUniqueInput, distinct: [EvaluationEtudiantsScalarFieldEnum!], orderBy: [EvaluationEtudiantsOrderByWithRelationInput!], skip: Float, take: Float, where: EvaluationEtudiantsWhereInput): [EvaluationEtudiants!]!
  feuillePresence(where: FeuillePresenceWhereUniqueInput!): FeuillePresence!
  feuillesPresences(cursor: FeuillePresenceWhereUniqueInput, distinct: [FeuillePresenceScalarFieldEnum!], orderBy: [FeuillePresenceOrderByWithRelationInput!], skip: Float, take: Float, where: FeuillePresenceWhereInput): [FeuillePresence!]!
  inscription(where: InscriptionWhereUniqueInput!): Inscription!
  inscriptions(cursor: InscriptionWhereUniqueInput, distinct: [InscriptionScalarFieldEnum!], orderBy: [InscriptionOrderByWithRelationInput!], skip: Float, take: Float, where: InscriptionWhereInput): [Inscription!]!
  matiere(where: MatiereWhereUniqueInput!): Matiere!
  matieres(cursor: MatiereWhereUniqueInput, distinct: [MatiereScalarFieldEnum!], orderBy: [MatiereOrderByWithRelationInput!], skip: Float, take: Float, where: MatiereWhereInput): [Matiere!]!
  me: Utilisateur!
  mention(where: MentionWhereUniqueInput!): Mention!
  mentions(cursor: MentionWhereUniqueInput, distinct: [MentionScalarFieldEnum!], orderBy: [MentionOrderByWithRelationInput!], skip: Float, take: Float, where: MentionWhereInput): [Mention!]!
  noteEtudiant(where: NoteEtudiantWhereUniqueInput!): NoteEtudiant!
  noteEtudiants(cursor: NoteEtudiantWhereUniqueInput, distinct: [NoteEtudiantScalarFieldEnum!], orderBy: [NoteEtudiantOrderByWithRelationInput!], skip: Float, take: Float, where: NoteEtudiantWhereInput): [NoteEtudiant!]!
  paiement(where: PaiementWhereUniqueInput!): Paiement!
  paiements(cursor: PaiementWhereUniqueInput, distinct: [PaiementScalarFieldEnum!], orderBy: [PaiementOrderByWithRelationInput!], skip: Float, take: Float, where: PaiementWhereInput): [Paiement!]!
  permission(where: PermissionWhereUniqueInput!): Permission!
  permissions(cursor: PermissionWhereUniqueInput, distinct: [PermissionScalarFieldEnum!], orderBy: [PermissionOrderByWithRelationInput!], skip: Float, take: Float, where: PermissionWhereInput): [Permission!]!
  professeur(where: ProfesseurWhereUniqueInput!): Professeur!
  professeurs(cursor: ProfesseurWhereUniqueInput, distinct: [ProfesseurScalarFieldEnum!], orderBy: [ProfesseurOrderByWithRelationInput!], skip: Float, take: Float, where: ProfesseurWhereInput): [Professeur!]!
  reseauSocial(where: ReseauSocialWhereUniqueInput!): ReseauSocial!
  reseauSociaux(cursor: ReseauSocialWhereUniqueInput, distinct: [ReseauSocialScalarFieldEnum!], orderBy: [ReseauSocialOrderByWithRelationInput!], skip: Float, take: Float, where: ReseauSocialWhereInput): [ReseauSocial!]!
  salle(where: SalleWhereUniqueInput!): Salle!
  salles(cursor: SalleWhereUniqueInput, distinct: [SalleScalarFieldEnum!], orderBy: [SalleOrderByWithRelationInput!], skip: Float, take: Float, where: SalleWhereInput): [Salle!]!
  semestre(where: SemestreWhereUniqueInput!): Semestre!
  semestres(cursor: SemestreWhereUniqueInput, distinct: [SemestreScalarFieldEnum!], orderBy: [SemestreOrderByWithRelationInput!], skip: Float, take: Float, where: SemestreWhereInput): [Semestre!]!
  specialite(where: SpecialiteWhereUniqueInput!): Specialite!
  specialites(cursor: SpecialiteWhereUniqueInput, distinct: [SpecialiteScalarFieldEnum!], orderBy: [SpecialiteOrderByWithRelationInput!], skip: Float, take: Float, where: SpecialiteWhereInput): [Specialite!]!
  uniteEnseignement(where: UniteEnseignementWhereUniqueInput!): UniteEnseignement!
  uniteEnseignements(cursor: UniteEnseignementWhereUniqueInput, distinct: [UniteEnseignementScalarFieldEnum!], orderBy: [UniteEnseignementOrderByWithRelationInput!], skip: Float, take: Float, where: UniteEnseignementWhereInput): [UniteEnseignement!]!
  utilisateur(where: UtilisateurWhereUniqueInput!): Utilisateur!
  utilisateurs(cursor: UtilisateurWhereInput, distinct: [UtilisateurScalarFieldEnum!], orderBy: [UtilisateurOrderByWithRelationInput!], skip: Float, take: Float, where: UtilisateurWhereInput): [Utilisateur!]!
}

enum QueryMode {
  default
  insensitive
}

type ReseauSocial {
  contactId: Float
  createdAt: DateTime
  id: Float
  nom: String
  updatedAt: DateTime
  url: String
  username: String
}

input ReseauSocialListRelationFilter {
  every: ReseauSocialWhereInput
  none: ReseauSocialWhereInput
  some: ReseauSocialWhereInput
}

input ReseauSocialOrderByRelationAggregateInput {
  _count: SortOrder
}

input ReseauSocialOrderByWithRelationInput {
  contact: ContactOrderByWithRelationInput
  contactId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  nom: SortOrder
  updatedAt: SortOrder
  url: SortOrder
  username: SortOrder
}

enum ReseauSocialScalarFieldEnum {
  contactId
  createdAt
  id
  nom
  updatedAt
  url
  username
}

input ReseauSocialWhereInput {
  AND: [ReseauSocialWhereInput!]
  NOT: [ReseauSocialWhereInput!]
  OR: [ReseauSocialWhereInput!]
  contact: ContactRelationFilter
  contactId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  nom: StringFilter
  updatedAt: DateTimeFilter
  url: StringFilter
  username: StringFilter
}

input ReseauSocialWhereUniqueInput {
  id: Float
}

type ResultatAnnuel {
  moyenneAnnuelle: String
  resultat: String
  totalCredit: Float
}

type Salle {
  batiment: String
  capacite: Float
  createdAt: DateTime
  estDisponible: Boolean
  etablissementId: Float
  id: Float
  nom: String
  updatedAt: DateTime
}

input SalleListRelationFilter {
  every: SalleWhereInput
  none: SalleWhereInput
  some: SalleWhereInput
}

input SalleOrderByWithRelationInput {
  EmploiDuTemps: EmploiDuTempsOrderByRelationAggregateInput
  batiment: SortOrder
  capacite: SortOrder
  cours: CoursOrderByRelationAggregateInput
  createdAt: SortOrder
  estDisponible: SortOrder
  etablissement: EtablissementOrderByWithRelationInput
  etablissementId: SortOrder
  id: SortOrder
  nom: SortOrder
  updatedAt: SortOrder
}

input SalleRelationFilter {
  is: SalleWhereInput
  isNot: SalleWhereInput
}

enum SalleScalarFieldEnum {
  batiment
  capacite
  createdAt
  estDisponible
  etablissementId
  id
  nom
  updatedAt
}

input SalleWhereInput {
  AND: [SalleWhereInput!]
  EmploiDuTemps: EmploiDuTempsListRelationFilter
  NOT: [SalleWhereInput!]
  OR: [SalleWhereInput!]
  batiment: StringFilter
  capacite: IntFilter
  cours: CoursListRelationFilter
  createdAt: DateTimeFilter
  estDisponible: BoolFilter
  etablissement: EtablissementRelationFilter
  etablissementId: IntFilter
  id: IntFilter
  nom: StringFilter
  updatedAt: DateTimeFilter
}

input SalleWhereUniqueInput {
  id: Float
}

type Semestre {
  createdAt: DateTime
  dateDebut: DateTime
  dateFin: DateTime
  etablissementId: Float
  grade: String!
  id: Float
  nombreSemaine: Float
  numero: Float
  uniteEnseignements: [UniteEnseignement!]!
  updatedAt: DateTime
}

input SemestreOrderByWithRelationInput {
  createdAt: SortOrder
  dateDebut: SortOrder
  dateFin: SortOrder
  etablissementId: SortOrder
  grade: SortOrder
  id: SortOrder
  nombreSemaine: SortOrder
  numero: SortOrder
  uniteEnseignement: UniteEnseignementOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input SemestreRelationFilter {
  is: SemestreWhereInput
  isNot: SemestreWhereInput
}

enum SemestreScalarFieldEnum {
  createdAt
  dateDebut
  dateFin
  etablissementId
  grade
  id
  nombreSemaine
  numero
  updatedAt
}

input SemestreWhereInput {
  AND: [SemestreWhereInput!]
  NOT: [SemestreWhereInput!]
  OR: [SemestreWhereInput!]
  createdAt: DateTimeFilter
  dateDebut: DateTimeFilter
  dateFin: DateTimeFilter
  etablissementId: IntFilter
  grade: StringFilter
  id: IntFilter
  nombreSemaine: IntFilter
  numero: IntFilter
  uniteEnseignement: UniteEnseignementListRelationFilter
  updatedAt: DateTimeFilter
}

input SemestreWhereUniqueInput {
  id: Float
}

enum SortOrder {
  asc
  desc
}

type Specialite {
  classes: [Classe!]!
  createdAt: DateTime
  etablissementId: Float
  id: Float
  mention: Mention!
  mentionId: Float
  nom: String
  slug: String
  updatedAt: DateTime
}

input SpecialiteListRelationFilter {
  every: SpecialiteWhereInput
  none: SpecialiteWhereInput
  some: SpecialiteWhereInput
}

input SpecialiteOrderByRelationAggregateInput {
  _count: SortOrder
}

input SpecialiteOrderByWithRelationInput {
  Classe: ClasseOrderByRelationAggregateInput
  Diplome: DiplomeOrderByRelationAggregateInput
  createdAt: SortOrder
  etablissementId: SortOrder
  id: SortOrder
  mention: MentionOrderByWithRelationInput
  mentionId: SortOrder
  nom: SortOrder
  slug: SortOrder
  updatedAt: SortOrder
}

input SpecialiteRelationFilter {
  is: SpecialiteWhereInput
  isNot: SpecialiteWhereInput
}

enum SpecialiteScalarFieldEnum {
  createdAt
  etablissementId
  id
  mentionId
  nom
  slug
  updatedAt
}

input SpecialiteWhereInput {
  AND: [SpecialiteWhereInput!]
  Classe: ClasseListRelationFilter
  Diplome: DiplomeListRelationFilter
  NOT: [SpecialiteWhereInput!]
  OR: [SpecialiteWhereInput!]
  createdAt: DateTimeFilter
  etablissementId: IntFilter
  id: IntFilter
  mention: MentionRelationFilter
  mentionId: IntFilter
  nom: StringFilter
  slug: StringFilter
  updatedAt: DateTimeFilter
}

input SpecialiteWhereUniqueInput {
  id: Float
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: String
  notIn: [String!]
  startsWith: String
}

input StringListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

type UniteEnseignement {
  classeId: Float
  code: String
  createdAt: DateTime
  credit: Float
  id: Float
  matieres: [Matiere!]
  nom: String
  numero: Float
  semestre: Semestre
  semestreId: Float
  updatedAt: DateTime
}

input UniteEnseignementListRelationFilter {
  every: UniteEnseignementWhereInput
  none: UniteEnseignementWhereInput
  some: UniteEnseignementWhereInput
}

input UniteEnseignementOrderByRelationAggregateInput {
  _count: SortOrder
}

input UniteEnseignementOrderByWithRelationInput {
  classe: ClasseOrderByWithRelationInput
  classeId: SortOrder
  code: SortOrder
  createdAt: SortOrder
  credit: SortOrder
  id: SortOrder
  matieres: MatiereOrderByRelationAggregateInput
  nom: SortOrder
  numero: SortOrder
  semestre: SemestreOrderByWithRelationInput
  semestreId: SortOrder
  updatedAt: SortOrder
}

input UniteEnseignementRelationFilter {
  is: UniteEnseignementWhereInput
  isNot: UniteEnseignementWhereInput
}

enum UniteEnseignementScalarFieldEnum {
  classeId
  code
  createdAt
  credit
  id
  nom
  numero
  semestreId
  updatedAt
}

input UniteEnseignementWhereInput {
  AND: [UniteEnseignementWhereInputStrict!]
  NOT: [UniteEnseignementWhereInputStrict!]
  OR: [UniteEnseignementWhereInputStrict!]
  classe: ClasseRelationFilter
  classeId: IntFilter
  code: StringFilter
  createdAt: DateTimeFilter
  credit: IntFilter
  id: IntFilter
  matieres: MatiereListRelationFilter
  nom: StringFilter
  numero: IntFilter
  semestre: SemestreRelationFilter
  semestreId: IntFilter
  updatedAt: DateTimeFilter
}

input UniteEnseignementWhereInputStrict {
  AND: [UniteEnseignementWhereInputStrict!]
  NOT: [UniteEnseignementWhereInputStrict!]
  OR: [UniteEnseignementWhereInputStrict!]
  classe: ClasseRelationFilter
  classeId: IntFilter
  code: StringFilter
  createdAt: DateTimeFilter
  credit: IntFilter
  id: IntFilter
  matieres: MatiereListRelationFilter
  nom: StringFilter
  numero: IntFilter
  semestre: SemestreRelationFilter
  semestreId: IntFilter
  updatedAt: DateTimeFilter
}

input UniteEnseignementWhereUniqueInput {
  id: Float
}

input UpdateAccountInput {
  id: Float!
  password: String
  roles: [String!] = ["UTILISATEUR"]
  userId: Float
  username: String
}

input UpdateAdresseInput {
  codePostal: String
  geolocalisation: String
  id: Float!
  pays: String
  region: String
  ville: String
}

input UpdateAnneeScolaireInput {
  dateDebut: Float
  dateFin: Float
  id: Float!
  nom: String
}

input UpdateClasseInput {
  anneeScolaireId: Float
  code: String
  etablissementId: Float
  id: Float!
  niveau: String
  nom: String
  specialiteId: Float
}

input UpdateContactInput {
  email: String
  fax: String
  fix: String
  id: Float!
  siteWeb: String
  telephone: String
}

input UpdateCoursInput {
  classeId: Float
  dateDebut: DateTime
  dateFin: DateTime
  description: String
  heureDebut: DateTime
  heureFin: DateTime
  id: Float!
  matiereId: Float
  nom: String
  professeurId: Float
  salleId: Float
}

input UpdateDiplomeInput {
  dateCreation: DateTime
  dateEcheance: DateTime
  dateHabilitation: DateTime
  duree: Float
  entite: String
  finalite: String
  habilitation: String
  id: Float!
  nom: String
  partenaires: [String!]
  specialiteId: Float
}

input UpdateDomaineInput {
  id: Float!
  mentions: [CreateMentionInput!]
  nom: String
}

input UpdateEmploiDuTempsInput {
  classeId: Float
  color: String
  coursId: Float
  daysOfWeek: [String!]
  endRecur: String
  endTime: String
  id: Float!
  professeurId: Float
  salleId: Float
  startRecur: String
  startTime: String
  title: String
}

input UpdateEtablissementInput {
  adresseId: Float
  anneeEnCours: String
  contactId: Float
  dateCreation: DateTime
  domaines: [CreateDomaineInputWithId!]
  id: Float!
  logo: String
  matricule: String
  nom: String
  sigle: String
}

input UpdateEtudiantInput {
  anneeBaccaleaureat: Float
  baccaleaureat: String
  feuillePresencesId: Float
  id: Float!
  ine: String
  profile: UtilisateurWithAccount
}

input UpdateEvaluationEtudiantsInput {
  coursId: Float
  dateEvaluation: DateTime
  description: String
  document: String
  duree: Float
  id: Float!
  typeEvaluation: String
}

input UpdateFeuillePresenceInput {
  coursId: Float
  date: DateTime
  etudiantId: Float
  heureDebut: DateTime
  heureFin: DateTime
  id: Float!
}

input UpdateInscriptionInput {
  activiteProfessionnel: String
  autreEtablissement: String
  classeId: Float
  dernierDiplome: String
  diplomeId: Float
  etudiantId: Float
  id: Float!
  niveau: String
  premiereInscription: Boolean = false
  reference: String
  statut: String
}

input UpdateMatiereInput {
  code: String
  coefficient: Float
  credit: Float
  id: Float!
  nbHeure: Float
  nom: String
  uniteEnseignementId: Float
}

input UpdateMentionInput {
  domaineId: Float
  id: Float!
  nom: String
  specialites: [CreateSpecialiteInput!]
}

input UpdateNoteEtudiantInput {
  etudiantId: Float
  evaluationEtudiantId: Float
  id: Float!
  note: Float
}

input UpdatePaiementInput {
  datePaiement: DateTime
  etudiantId: Float
  id: Float!
  methodePaiement: String
  montant: Float
  referencePaiement: String
  statutPaiement: String
  typeFrais: String
}

input UpdatePermissionInput {
  id: Float!
  label: String
  role: [String!]
}

input UpdateProfesseurInput {
  id: Float!
  profile: UtilisateurWithAccount
}

input UpdateReseauSocialInput {
  contactId: Float
  id: Float!
  nom: String
  url: String
  username: String
}

input UpdateSalleInput {
  batiment: String
  capacite: Float
  estDisponible: Boolean
  etablissementId: Float
  id: Float!
  nom: String
}

input UpdateSemestreInput {
  dateDebut: DateTime
  dateFin: DateTime
  etablissementId: Float
  grade: String
  id: Float!
  nombreSemaine: Float
  numero: Float
}

input UpdateSpecialiteInput {
  etablissementId: Float
  id: Float!
  mentionId: Float
  nom: String
}

input UpdateUniteEnseignementInput {
  classeId: Float
  code: String
  credit: Float
  id: Float!
  nom: String
  numero: Float
  semestreId: Float
}

input UpdateUtilisateurInput {
  account: CreateAccountInput
  adresseId: Float
  cni: String
  contactId: Float
  dateNaissance: DateTime
  etablissementId: Float
  genre: String = "Masculin"
  groupeSanguin: String
  id: Float!
  lieuNaissance: String
  matricule: String
  nationalite: String
  nom: String
  prenom: String
  roles: [String!]
  statutCompte: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type Utilisateur {
  accountId: Float
  adresse: Adresse!
  adresseId: Float
  cni: String
  contact: Contact!
  contactId: Float
  createdAt: DateTime
  dateNaissance: DateTime
  etablissement: Etablissement!
  etablissementId: Float
  genre: String
  groupeSanguin: String
  id: Float
  lieuNaissance: String
  matricule: String
  nationalite: String
  nom: String
  prenom: String
  roles: [String!]!
  statutCompte: String
  updatedAt: DateTime
}

input UtilisateurListRelationFilter {
  every: UtilisateurWhereInput
  none: UtilisateurWhereInput
  some: UtilisateurWhereInput
}

input UtilisateurOrderByRelationAggregateInput {
  _count: SortOrder
}

input UtilisateurOrderByWithRelationInput {
  Professeur: ProfesseurOrderByWithRelationInput
  accountId: SortOrder
  adresse: AdresseOrderByWithRelationInput
  adresseId: SortOrder
  cni: SortOrder
  contact: ContactOrderByWithRelationInput
  contactId: SortOrder
  createdAt: SortOrder
  dateNaissance: SortOrder
  etablissement: EtablissementOrderByWithRelationInput
  etablissementId: SortOrder
  etudiant: EtudiantOrderByWithRelationInput
  genre: SortOrder
  groupeSanguin: SortOrder
  id: SortOrder
  lieuNaissance: SortOrder
  matricule: SortOrder
  nationalite: SortOrder
  nom: SortOrder
  permissions: PermissionOrderByRelationAggregateInput
  prenom: SortOrder
  roles: SortOrder
  statutCompte: SortOrder
  updatedAt: SortOrder
}

input UtilisateurRelationFilter {
  is: UtilisateurWhereInput
  isNot: UtilisateurWhereInput
}

enum UtilisateurScalarFieldEnum {
  accountId
  adresseId
  cni
  contactId
  createdAt
  dateNaissance
  etablissementId
  genre
  groupeSanguin
  id
  lieuNaissance
  matricule
  nationalite
  nom
  prenom
  roles
  statutCompte
  updatedAt
}

input UtilisateurWhereInput {
  AND: [UtilisateurWhereInput!]
  NOT: [UtilisateurWhereInput!]
  OR: [UtilisateurWhereInput!]
  Professeur: ProfesseurRelationFilter
  accountId: IntFilter
  adresse: AdresseRelationFilter
  adresseId: IntFilter
  cni: StringFilter
  contact: ContactRelationFilter
  contactId: IntFilter
  createdAt: DateTimeFilter
  dateNaissance: DateTimeFilter
  etablissement: EtablissementRelationFilter
  etablissementId: IntFilter
  etudiant: EtudiantRelationFilter
  genre: StringFilter
  groupeSanguin: StringFilter
  id: IntFilter
  lieuNaissance: StringFilter
  matricule: StringFilter
  nationalite: StringFilter
  nom: StringFilter
  permissions: PermissionListRelationFilter
  prenom: StringFilter
  roles: StringListFilter
  statutCompte: StringFilter
  updatedAt: DateTimeFilter
}

input UtilisateurWhereUniqueInput {
  id: Float
}

input UtilisateurWithAccount {
  account: CreateAccountInput
  accountId: Float
  adresseId: Float
  cni: String
  contactId: Float
  createdAt: DateTime
  dateNaissance: DateTime
  etablissementId: Float
  genre: String! = "Masculin"
  groupeSanguin: String
  id: Float
  lieuNaissance: String
  matricule: String
  nationalite: String
  nom: String
  prenom: String
  roles: [String!]
  statutCompte: String
  updatedAt: DateTime
}